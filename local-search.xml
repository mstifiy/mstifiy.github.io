<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo搭建个人博客网站</title>
    <link href="/2023/01/02/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
    <url>/2023/01/02/hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-Hexo搭建步骤"><a href="#1-Hexo搭建步骤" class="headerlink" title="1. Hexo搭建步骤"></a>1. Hexo搭建步骤</h1><h2 id="1-1-安装Git"><a href="#1-1-安装Git" class="headerlink" title="1.1 安装Git"></a>1.1 安装Git</h2><p>Windows下载：<a href="https://gitforwindows.org/">Git for Windows</a></p><p>Linux下载：<code>sudo apt-get install git</code></p><h2 id="1-2-安装Node-js"><a href="#1-2-安装Node-js" class="headerlink" title="1.2 安装Node.js"></a>1.2 安装Node.js</h2><p>Windows下载：<a href="https://nodejs.org/en/download/">Download | Node.js (nodejs.org)</a></p><p>Linux下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install nodejs<br>sudo apt-get install npm<br></code></pre></td></tr></table></figure><h2 id="1-3-安装Hexo"><a href="#1-3-安装Hexo" class="headerlink" title="1.3 安装Hexo"></a>1.3 安装Hexo</h2><ul><li><p>新建文件夹命名blog。</p></li><li><p>运行git bash，<code>cd</code>到blog文件夹下。输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<span class="hljs-comment"># 安装hexo</span><br>hexo -v<span class="hljs-comment"># 检查是否安装成功</span><br>hexo init mstifiyblog<span class="hljs-comment"># 初始化hexo，&quot;mstifiyblog&quot;为生成的hexo文件夹名，可自定义</span><br><span class="hljs-built_in">cd</span> mstifiyblog <span class="hljs-comment"># 进入这个mstifiyblog文件夹</span><br>npm install<br></code></pre></td></tr></table></figure><p><strong>mstifiyblog文件夹目录内容：</strong></p><ul><li>node_modules：依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>** _config.yml: 博客的配置文件**</li></ul><p><strong>本地查看博客网页</strong></p><p>开启hexo服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br>hexo server<br></code></pre></td></tr></table></figure><p>浏览器输入<code>localhost:4000</code>。</p></li></ul><h2 id="1-4-GitHub创建个人仓库"><a href="#1-4-GitHub创建个人仓库" class="headerlink" title="1.4 GitHub创建个人仓库"></a>1.4 GitHub创建个人仓库</h2><p>创建public仓库<code>&lt;github用户名&gt;.github.io</code>。</p><h2 id="1-5-生成SSH添加到GitHub"><a href="#1-5-生成SSH添加到GitHub" class="headerlink" title="1.5 生成SSH添加到GitHub"></a>1.5 生成SSH添加到GitHub</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 配置git</span><br>git config --global user.name <span class="hljs-string">&quot;yourname&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;youremail&quot;</span><br><span class="hljs-comment"># 验证配置</span><br>git config user.name<br>git config user.email<br><span class="hljs-comment"># 创建SSH</span><br>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></td></tr></table></figure><p>生成<code>id_rsa</code>（私人秘钥），<code>id_rsa.pub</code>（公共秘钥）。</p><p>GitHub-&gt;setting-&gt;SSH keys-&gt;New SSH key，把<code>id_rsa.pub</code>里面的信息复制进去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com<span class="hljs-comment"># 验证SSH</span><br></code></pre></td></tr></table></figure><h2 id="1-6-将hexo部署到GitHub"><a href="#1-6-将hexo部署到GitHub" class="headerlink" title="1.6 将hexo部署到GitHub"></a>1.6 将hexo部署到GitHub</h2><p><code>_config.yml</code>，文件末尾修改：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/&lt;github账户名&gt;/&lt;github账户名&gt;.github.io.git</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<span class="hljs-comment"># 安装deploy-git</span><br>hexo clean<span class="hljs-comment"># 清除原数据</span><br>hexo generate<span class="hljs-comment"># 生成静态文章，命令缩写：hexo g</span><br>hexo deploy<span class="hljs-comment"># 部署文章，命令缩写：hexo d</span><br></code></pre></td></tr></table></figure><p>配置成功后，通过浏览器输入：<code>http://&lt;github账户名&gt;.github.io</code>即可查看博客了。</p><h2 id="1-7-设置个人域名"><a href="#1-7-设置个人域名" class="headerlink" title="1.7 设置个人域名"></a>1.7 设置个人域名</h2><p><font color=gray>目前没有个人域名的需求，暂不记录。</font></p><h2 id="1-8-发布文章"><a href="#1-8-发布文章" class="headerlink" title="1.8 发布文章"></a>1.8 发布文章</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new newpapername<br></code></pre></td></tr></table></figure><p>在<code>source/_post</code>中打开markdown文件编辑，写完后再：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure><p>更新成功。</p><h1 id="2-拓展部分"><a href="#2-拓展部分" class="headerlink" title="2. 拓展部分"></a>2. 拓展部分</h1><h2 id="2-1-hexo基本配置"><a href="#2-1-hexo基本配置" class="headerlink" title="2.1 hexo基本配置"></a>2.1 hexo基本配置</h2><p>参考hexo官方文档：<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p><h2 id="2-2-更换主题"><a href="#2-2-更换主题" class="headerlink" title="2.2 更换主题"></a>2.2 更换主题</h2><p>将主题源码从github上下载下来，放到<code>theme</code>文件夹下。然后在<code>_config.yml</code>配置文件中把<code>theme</code>换成目标主题文件夹的名字，它就会自动在<code>theme</code>文件夹中搜索配置的主题。</p><p>在目标主题文件夹下，也有一个配置文件<code>_config.xml</code>。这个配置文件是修改整个主题的配置文件。</p><p><strong>menu（菜单栏）</strong></p><p>新建自定义菜单栏选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new page yourdiy<span class="hljs-comment"># yourdir为菜单栏名</span><br></code></pre></td></tr></table></figure><p>然后在主题配置文件的menu菜单栏添加一个 <code>Yourdiy : /yourdiy</code>，注意冒号后面要有空格，以及前面的空格要和menu中默认的保持整齐。然后在<code>languages</code>文件夹中，找到<code>zh-CN.yml</code>，在index中添加<code>yourdiy: &#39;中文意思&#39;</code>就可以显示中文了。</p><p><strong>fluid主题</strong></p><p><a href="https://hexo.fluid-dev.com/docs/guide/">配置指南 | Hexo Fluid 用户手册 (fluid-dev.com)</a></p><h2 id="2-3-git分支进行多终端工作"><a href="#2-3-git分支进行多终端工作" class="headerlink" title="2.3 git分支进行多终端工作"></a>2.3 git分支进行多终端工作</h2><h2 id="2-4-其他拓展"><a href="#2-4-其他拓展" class="headerlink" title="2.4 其他拓展"></a>2.4 其他拓展</h2><p>参考文章：<a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">hexo史上最全搭建教程</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pybind11学习 在Python中构建编译生成pyd文件</title>
    <link href="/2022/12/31/pybind11%E5%AD%A6%E4%B9%A0%20%E5%9C%A8Python%E4%B8%AD%E6%9E%84%E5%BB%BA%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90pyd%E6%96%87%E4%BB%B6/"/>
    <url>/2022/12/31/pybind11%E5%AD%A6%E4%B9%A0%20%E5%9C%A8Python%E4%B8%AD%E6%9E%84%E5%BB%BA%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90pyd%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="0-准备"><a href="#0-准备" class="headerlink" title="0 准备"></a>0 准备</h1><p>项目文件夹结构树如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">pybind11_setup_demo<br>    └─demo<span class="hljs-comment"># demo包</span><br>        │  setup.py<span class="hljs-comment"># 用于编译C++代码，生成C/C++ python扩展</span><br>        │  test.py<span class="hljs-comment"># 用于测试生成的拓展</span><br>        │<br>        └─src<span class="hljs-comment"># 源码文件夹</span><br>            example.cpp<br></code></pre></td></tr></table></figure><p><code>example.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pybind11/pybind11.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> py = pybind11;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-built_in">PYBIND11_MODULE</span>(example, m) &#123;<br>    m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;square&quot;</span>, &amp;square);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>test.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> example<br><br><span class="hljs-built_in">help</span>(example)<br><br>result = example.square(<span class="hljs-number">5</span>)<br><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><h1 id="1-setuptools"><a href="#1-setuptools" class="headerlink" title="1. setuptools"></a>1. setuptools</h1><p>参考文章：<a href="https://www.jianshu.com/p/819e3e8fbe5e">pybind11—python C/C++扩展编译 - 简书 (jianshu.com)</a></p><p><code>setup.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup<br><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> Extension<br><br>example_module = Extension(name = <span class="hljs-string">&#x27;example&#x27;</span>,  <span class="hljs-comment"># 模块名称</span><br>                           sources = [<span class="hljs-string">&#x27;src/example.cpp&#x27;</span>],  <span class="hljs-comment"># 源码</span><br>                           <span class="hljs-comment"># 依赖的第三方库的头文件</span><br>                           include_dirs = [<span class="hljs-string">r&#x27;D:\anaconda3\envs\pybind11\include&#x27;</span>,    <span class="hljs-comment"># Python头文件路径</span><br>                                           <span class="hljs-string">r&#x27;D:\anaconda3\envs\pybind11\Lib\site-packages\pybind11\include&#x27;</span>  <span class="hljs-comment"># pybind11头文件路径</span><br>                                           ]<br>                           )<br><br>setup(ext_modules = [example_module])<br></code></pre></td></tr></table></figure><p>打开终端，进入到<code>setup.py</code>文件所在目录，运行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python setup.py build_ext --inplace<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">running build_ext<br>building <span class="hljs-string">&#x27;example&#x27;</span> extension<br>creating build<br>creating build\temp.win-amd64-cpython-38<br>creating build\temp.win-amd64-cpython-38\Release<br>creating build\temp.win-amd64-cpython-38\Release\src<br>...<br>正在创建库 build\temp.win-amd64-cpython-38\Release\src\example.cp38-win_amd64.lib 和对象 build\temp.win-amd64-cpython-38\Release\src\example.cp38-win_amd64.exp<br>正在生成代码<br>已完成代码的生成<br>copying build\lib.win-amd64-cpython-38\example.cp38-win_amd64.pyd -&gt;<br></code></pre></td></tr></table></figure><p>测试拓展模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python test.py<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">Help on module example:<br><br>NAME<br>    example<br><br>FUNCTIONS<br>    square(...) method of builtins.PyCapsule instance<br>        square(arg0: int) -&gt; int<br><br>FILE<br>    d:\pybind11_setup_demo\demo\example.cp38-win_amd64.pyd<br><br><br>25<br></code></pre></td></tr></table></figure><h1 id="2-pybind11-setup-helpers"><a href="#2-pybind11-setup-helpers" class="headerlink" title="2. pybind11.setup_helpers"></a>2. pybind11.setup_helpers</h1><p>参考文档网址：<a href="https://pybind11.readthedocs.io/en/stable/compiling.html#building-with-setuptools">Build systems - pybind11 documentation</a></p><p>这种方法和上一种方法的区别在于，后者需要安装在Python环境中<code>pip install pybind11</code>。pybind11提供了<code>setup_helpers</code>用于简化setuptools的构建过程（作用有点类似于pybind11提供的CMake函数<code>pybind11_add_module</code>）。</p><p><code>setup.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> setuptools <span class="hljs-keyword">import</span> setup<br><span class="hljs-keyword">from</span> pybind11.setup_helpers <span class="hljs-keyword">import</span> Pybind11Extension, build_ext<br><br>ext_modules = [<br>    Pybind11Extension(<br>        <span class="hljs-string">&quot;example&quot;</span>,<br>        [<span class="hljs-string">&quot;src/example.cpp&quot;</span>],<br>    ),<br>]<br><br>setup(cmdclass = &#123;<span class="hljs-string">&quot;build_ext&quot;</span>: build_ext&#125;, ext_modules = ext_modules)<br></code></pre></td></tr></table></figure><p>同样，打开终端，进入到<code>setup.py</code>文件所在目录，运行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python setup.py build_ext --inplace<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">running build_ext<br>building <span class="hljs-string">&#x27;example&#x27;</span> extension<br>creating build<br>creating build\temp.win-amd64-cpython-38<br>creating build\temp.win-amd64-cpython-38\Release<br>creating build\temp.win-amd64-cpython-38\Release\src<br>...<br>  正在创建库 build\temp.win-amd64-cpython-38\Release\src\example.cp38-win_amd64.lib 和对象 build\temp.win-amd64-cpython-38\Release\src\example.cp38-win_amd64.exp<br>正在生成代码<br>已完成代码的生成<br>copying build\lib.win-amd64-cpython-38\example.cp38-win_amd64.pyd -&gt;<br></code></pre></td></tr></table></figure><p>测试拓展模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python test.py<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">Help on module example:<br><br>NAME<br>    example<br><br>FUNCTIONS<br>    square(...) method of builtins.PyCapsule instance<br>        square(arg0: int) -&gt; int<br><br>FILE<br>    d:\pybind11_setup_demo\demo\example.cp38-win_amd64.pyd<br><br><br>25<br></code></pre></td></tr></table></figure><p>效果和第一种没有差别，但在<code>setup.py</code>文件的编写上更加方便。</p><h1 id="3-cppimport"><a href="#3-cppimport" class="headerlink" title="3. cppimport"></a>3. cppimport</h1><p>参考网址：<a href="https://github.com/tbenthompson/cppimport">tbenthompson/cppimport: Import C++ files directly from Python! (github.com)</a></p><p>这种方法更加简单，甚至不需要编写<code>setup.py</code>文件。只需在Python环境中安装<code>cppimport</code>库即可。</p><p>修改<code>example.cpp</code>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// cppimport</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pybind11/pybind11.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> py = pybind11;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-built_in">PYBIND11_MODULE</span>(example, m) &#123;<br>    m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;square&quot;</span>, &amp;square);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&lt;%</span><br><span class="hljs-comment">setup_pybind11(cfg)</span><br><span class="hljs-comment">%&gt;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>打开终端，进入到<code>example.cpp</code>文件所在的<code>src</code>目录下，打开python解释器运行下面代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cppimport.import_hook<br><span class="hljs-keyword">import</span> example <span class="hljs-comment">#This will pause for a moment to compile the module</span><br>example.square(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">PS D:\pybind11_setup_demo\demo\src&gt; python<br>Python 3.8.12 (default, Oct 12 2021, 03:01:40) [MSC v.1916 64 bit (AMD64)] :: Anaconda, Inc. on win32<br>Type <span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-string">&quot;copyright&quot;</span>, <span class="hljs-string">&quot;credits&quot;</span> or <span class="hljs-string">&quot;license&quot;</span> <span class="hljs-keyword">for</span> more information.<br>&gt;&gt;&gt; import cppimport.import_hook<br>&gt;&gt;&gt; import example<br>cl: 命令行 warning D9002 :忽略未知选项“-std=c++11”<br>cl: 命令行 warning D9002 :忽略未知选项“-fvisibility=hidden”<br>.rendered.example.cpp<br>  正在创建库 ...\pybind11_setup_demo\demo\src\example.cp38-win_amd64.lib 和对象 ...\pybind11_setup_demo\demo\src\example.cp38-win_amd64.exp<br>正在生成代码<br>已完成代码的生成<br>&gt;&gt;&gt; example.square(5)<br>25<br></code></pre></td></tr></table></figure><p>运行成功后，在同目录下会自动生成一个pyd文件。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>在<strong>pycharm</strong>中运行<code>setup.py</code>文件进行拓展编译<strong>报错</strong>：<code>error: Microsoft Visual C++ 14.0 or greater is required.Get it with &quot;Microsoft C++ Build Tools&quot;: https://visualstudio.microsoft.com/visual-cpp-build-tools/</code></p><p>按照这篇文章将<a href="https://blog.csdn.net/eric3012/article/details/123824423">python pip error:Microsoft Visual C++ 14.0 or greater is required</a>将Microsoft C++ Build Tools安装成功后，仍然不能在pycharm的终端中运行。只能通过powershell进入文件夹目录下运行<code>setup.py</code>文件。这个问题目前还尚待解决。</p></li><li><p>对于包含第三方C++库的pybind11项目编译中<code>setup.py</code>文件如何修改的问题，可以参见文章：<a href="https://www.jianshu.com/p/819e3e8fbe5e">pybind11—python C/C++扩展编译 - 简书 (jianshu.com)</a>。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pybind11  绑定CGAL几何算法（numpy数据交换）</title>
    <link href="/2022/12/30/pybind11%20%20%E7%BB%91%E5%AE%9ACGAL%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95%EF%BC%88numpy%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%EF%BC%89/"/>
    <url>/2022/12/30/pybind11%20%20%E7%BB%91%E5%AE%9ACGAL%E5%87%A0%E4%BD%95%E7%AE%97%E6%B3%95%EF%BC%88numpy%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h1><p>对于CGAL，前段时间也用过相关的Python绑定，详情见文章：<a href="https://blog.csdn.net/qq_39784672/article/details/128001123">【CGAL+Python】安装CGAL的Python绑定</a>。如果我们想要调用[Polygon Mesh Processing](<a href="https://doc.cgal.org/latest/Polygon_mesh_processing/index.html#Chapter_PolygonMeshProcessing">CGAL 5.5.1 - Polygon Mesh Processing: User Manual</a>)中的算法，在不就地读取网格文件的前提下，需要在Python代码中构建CGAL的多边形网格对象，显得非常的不方便和蹩脚。正好，我在之前使用过libigl库的Python绑定，其数据通过numpy进行交换，即输入和输出都是numpy数组。于是，在对pybind11进行了一段时间的学习后，我开始尝试通过pybind11对CGAL的相关函数进行绑定生成Python调用接口，更重要的是使用numpy数组进行数据交换。</p><h1 id="二-numpy数据交换"><a href="#二-numpy数据交换" class="headerlink" title="二 numpy数据交换"></a>二 numpy数据交换</h1><h2 id="2-1-pybind11对numpy的支持"><a href="#2-1-pybind11对numpy的支持" class="headerlink" title="2.1 pybind11对numpy的支持"></a>2.1 pybind11对numpy的支持</h2><p>在<code>pybind11/numpy.h</code>头文件中，提供了对Numpy array的支持。我们可以通过<code>py::array_t&lt;T&gt;</code>来实现一个Numpy array。</p><p><code>py::array_t</code>支持一些基于Numpy的API：</p><ul><li><code>.dtype()</code>返回数组元素的类型。</li><li><code>.strides()</code>返回数组strides的指针。</li><li><code>.reshape(&#123;i, j, ...&#125;)</code>返回指定shape的数组视图。<code>.resize(&#123;&#125;)</code>也可以。</li><li><code>.index_at(i, j, ...)</code>获取数组指定索引的元素。</li></ul><p>为了更高效地访问大型数组，pybind11提供了不带检查的代理类<code>unchecked&lt;N&gt;</code>和<code>mutable_unchecked&lt;N&gt;</code>，其中<code>N</code>为数组所需的维数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;sum_3d&quot;</span>, [](py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt; x) &#123;<br>    <span class="hljs-keyword">auto</span> r = x.unchecked&lt;<span class="hljs-number">3</span>&gt;(); <span class="hljs-comment">// x must have ndim = 3; can be non-writeable</span><br>    <span class="hljs-keyword">double</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (py::<span class="hljs-keyword">ssize_t</span> i = <span class="hljs-number">0</span>; i &lt; r.<span class="hljs-built_in">shape</span>(<span class="hljs-number">0</span>); i++)<br>        <span class="hljs-keyword">for</span> (py::<span class="hljs-keyword">ssize_t</span> j = <span class="hljs-number">0</span>; j &lt; r.<span class="hljs-built_in">shape</span>(<span class="hljs-number">1</span>); j++)<br>            <span class="hljs-keyword">for</span> (py::<span class="hljs-keyword">ssize_t</span> k = <span class="hljs-number">0</span>; k &lt; r.<span class="hljs-built_in">shape</span>(<span class="hljs-number">2</span>); k++)<br>                sum += <span class="hljs-built_in">r</span>(i, j, k);<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;);<br>m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;increment_3d&quot;</span>, [](py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt; x) &#123;<br>    <span class="hljs-keyword">auto</span> r = x.mutable_unchecked&lt;<span class="hljs-number">3</span>&gt;(); <span class="hljs-comment">// Will throw if ndim != 3 or flags.writeable is false</span><br>    <span class="hljs-keyword">for</span> (py::<span class="hljs-keyword">ssize_t</span> i = <span class="hljs-number">0</span>; i &lt; r.<span class="hljs-built_in">shape</span>(<span class="hljs-number">0</span>); i++)<br>        <span class="hljs-keyword">for</span> (py::<span class="hljs-keyword">ssize_t</span> j = <span class="hljs-number">0</span>; j &lt; r.<span class="hljs-built_in">shape</span>(<span class="hljs-number">1</span>); j++)<br>            <span class="hljs-keyword">for</span> (py::<span class="hljs-keyword">ssize_t</span> k = <span class="hljs-number">0</span>; k &lt; r.<span class="hljs-built_in">shape</span>(<span class="hljs-number">2</span>); k++)<br>                <span class="hljs-built_in">r</span>(i, j, k) += <span class="hljs-number">1.0</span>;<br>&#125;, py::<span class="hljs-built_in">arg</span>().<span class="hljs-built_in">noconvert</span>());<br></code></pre></td></tr></table></figure><p>这两个代理类的区别就是：当只用从一个<code>array_t&lt;T&gt;</code>对象中读取数据时，我们使用<code>unchecked&lt;N&gt;</code>对它进行代理访问；当我们需要修改一个<code>array_t&lt;T&gt;</code>对象中的数据时，我们使用<code>mutable_unchecked&lt;N&gt;</code>对它进行代理访问。</p><p>同时Numpy array支持缓冲协议（buffer protocol），因此我们也可以通过<code>.request()</code>对其的缓冲区信息进行访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_info</span> &#123;</span><br>    <span class="hljs-keyword">void</span> *ptr;<span class="hljs-comment">// Pointer to the underlying storage</span><br>    py::<span class="hljs-keyword">ssize_t</span> itemsize;<span class="hljs-comment">// Size of individual items in bytes</span><br>    std::string format;<br>    py::<span class="hljs-keyword">ssize_t</span> ndim;<span class="hljs-comment">// Number of dimensions</span><br>    std::vector&lt;py::<span class="hljs-keyword">ssize_t</span>&gt; shape; <span class="hljs-comment">// Shape of the tensor (1 entry per dimension)</span><br>    std::vector&lt;py::<span class="hljs-keyword">ssize_t</span>&gt; strides;<span class="hljs-comment">//Number of bytes between adjacent entries</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>其他详细信息参见文档：<a href="https://pybind11.readthedocs.io/en/stable/advanced/pycpp/numpy.html">NumPy - pybind11 documentation</a>。</p><h2 id="2-2-Numpy-VF-py-array-t-与CGAL-mesh-Surface-Mesh-之间的转换"><a href="#2-2-Numpy-VF-py-array-t-与CGAL-mesh-Surface-Mesh-之间的转换" class="headerlink" title="2.2 Numpy VF(py::array_t)与CGAL mesh(Surface Mesh)之间的转换"></a>2.2 Numpy VF(py::array_t)与CGAL mesh(Surface Mesh)之间的转换</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将Numpy VF转换成CGAL mesh</span><br><span class="hljs-function">CGAL_Mesh <span class="hljs-title">convert_mesh_from_Numpy_to_CGAL</span><span class="hljs-params">(py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt;&amp; V, py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; F)</span></span><br><span class="hljs-function"></span>&#123;<br>    CGAL_Mesh CGAL_mesh;<br>    <span class="hljs-comment">// 获取V, F的信息</span><br>    py::buffer_info buf_v = V.<span class="hljs-built_in">request</span>();<br>    py::buffer_info buf_f = F.<span class="hljs-built_in">request</span>();<br>    <span class="hljs-keyword">if</span> (buf_v.shape[<span class="hljs-number">1</span>] != <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;vertex must be 3 dims &quot;</span>);<br>    <span class="hljs-keyword">if</span> (buf_f.shape[<span class="hljs-number">1</span>] != <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;face must be 3 dims &quot;</span>);<br><br>    <span class="hljs-keyword">auto</span> v = V.unchecked&lt;<span class="hljs-number">2</span>&gt;();<br>    <span class="hljs-keyword">auto</span> f = F.unchecked&lt;<span class="hljs-number">2</span>&gt;();<br><br>    <span class="hljs-comment">// clear and reserve the mesh</span><br>    CGAL_mesh.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">int</span> vn = buf_v.shape[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 顶点个数</span><br>    <span class="hljs-keyword">int</span> fn = buf_f.shape[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 面个数</span><br>    <span class="hljs-keyword">int</span> e = <span class="hljs-number">0</span>;<br>    CGAL_mesh.<span class="hljs-built_in">reserve</span>(vn, <span class="hljs-number">2</span> * fn, e);<br><br>    <span class="hljs-comment">//copy the vertices</span><br>    <span class="hljs-keyword">double</span> x, y, z;<br>    <span class="hljs-keyword">for</span> (py::<span class="hljs-keyword">ssize_t</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">shape</span>(<span class="hljs-number">0</span>); i++)<br>    &#123;<br>        Point p;<br>        x = <span class="hljs-built_in">v</span>(i, <span class="hljs-number">0</span>);<br>        y = <span class="hljs-built_in">v</span>(i, <span class="hljs-number">1</span>);<br>        z = <span class="hljs-built_in">v</span>(i, <span class="hljs-number">2</span>);<br>        p = <span class="hljs-built_in">Point</span>(x, y, z);<br>        CGAL_mesh.<span class="hljs-built_in">add_vertex</span>(p);<br>    &#125;<br><br>    <span class="hljs-comment">// copy the faces</span><br>    std::vector &lt;<span class="hljs-keyword">int</span>&gt; vertices;<br>    <span class="hljs-keyword">for</span> (py::<span class="hljs-keyword">ssize_t</span> i = <span class="hljs-number">0</span>; i &lt; f.<span class="hljs-built_in">shape</span>(<span class="hljs-number">0</span>); i++)<br>    &#123;<br>        vertices.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>);<br>        vertices[<span class="hljs-number">0</span>] = <span class="hljs-built_in">f</span>(i, <span class="hljs-number">0</span>);<br>        vertices[<span class="hljs-number">1</span>] = <span class="hljs-built_in">f</span>(i, <span class="hljs-number">1</span>);<br>        vertices[<span class="hljs-number">2</span>] = <span class="hljs-built_in">f</span>(i, <span class="hljs-number">2</span>);<br>        CGAL_mesh.<span class="hljs-built_in">add_face</span>(CGAL_Mesh::<span class="hljs-built_in">Vertex_index</span>(vertices[<span class="hljs-number">0</span>]),<br>            CGAL_Mesh::<span class="hljs-built_in">Vertex_index</span>(vertices[<span class="hljs-number">1</span>]),<br>            CGAL_Mesh::<span class="hljs-built_in">Vertex_index</span>(vertices[<span class="hljs-number">2</span>]));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> CGAL_mesh;<br>&#125;<br><br><span class="hljs-comment">// 将CGAL mesh转换成Numpy VF</span><br>std::pair&lt;py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt;, py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">convert_mesh_from_CGAL_to_Numpy</span>(CGAL_Mesh&amp; CGAL_mesh)<br>&#123;<br>    <span class="hljs-comment">//申请内存</span><br>    py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt; V = py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt;(CGAL_mesh.<span class="hljs-built_in">number_of_vertices</span>() * <span class="hljs-number">3</span>);<br>    py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">int</span>&gt; F = py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">int</span>&gt;(CGAL_mesh.<span class="hljs-built_in">number_of_faces</span>() * <span class="hljs-number">3</span>);<br>    std::pair&lt;py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt;, py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">VF</span>(V,F);<br><br>    V.<span class="hljs-built_in">resize</span>(&#123; <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(CGAL_mesh.<span class="hljs-built_in">number_of_vertices</span>()), <span class="hljs-number">3</span> &#125;);<br>    F.<span class="hljs-built_in">resize</span>(&#123; <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(CGAL_mesh.<span class="hljs-built_in">number_of_faces</span>()), <span class="hljs-number">3</span> &#125;);<br><br>    <span class="hljs-keyword">auto</span> v = V.mutable_unchecked&lt;<span class="hljs-number">2</span>&gt;();  <span class="hljs-comment">// mutable_unchecked: can be writeable</span><br>    <span class="hljs-keyword">auto</span> f = F.mutable_unchecked&lt;<span class="hljs-number">2</span>&gt;();<br><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (CGAL_Mesh::Vertex_index vd : <span class="hljs-built_in">vertices</span>(CGAL_mesh))<br>    &#123;<br>        <span class="hljs-built_in">v</span>(i, <span class="hljs-number">0</span>) = CGAL_mesh.<span class="hljs-built_in">point</span>(vd).<span class="hljs-built_in">x</span>();<br>        <span class="hljs-built_in">v</span>(i, <span class="hljs-number">1</span>) = CGAL_mesh.<span class="hljs-built_in">point</span>(vd).<span class="hljs-built_in">y</span>();<br>        <span class="hljs-built_in">v</span>(i, <span class="hljs-number">2</span>) = CGAL_mesh.<span class="hljs-built_in">point</span>(vd).<span class="hljs-built_in">z</span>();<br>        i++;<br>    &#125;<br><br>    i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (CGAL_Mesh::Face_index fd : <span class="hljs-built_in">faces</span>(CGAL_mesh))<br>    &#123;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (CGAL_Mesh::Vertex_index vd : CGAL::<span class="hljs-built_in">vertices_around_face</span>(CGAL_mesh.<span class="hljs-built_in">halfedge</span>(fd), CGAL_mesh))<br>        &#123;<br>            <span class="hljs-built_in">f</span>(i, j) = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(vd);<br>            j++;<br>        &#125;<br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> VF;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三-绑定CGAL算法示例"><a href="#三-绑定CGAL算法示例" class="headerlink" title="三 绑定CGAL算法示例"></a>三 绑定CGAL算法示例</h1><h2 id="3-1-示例函数"><a href="#3-1-示例函数" class="headerlink" title="3.1 示例函数"></a>3.1 示例函数</h2><p>在本文中我们尝试绑定[Polygon Mesh Processing](<a href="https://doc.cgal.org/latest/Polygon_mesh_processing/index.html#Chapter_PolygonMeshProcessing">CGAL 5.5.1 - Polygon Mesh Processing: User Manual</a>)中的<code>isotropic_remeshing</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">halfedge2edge</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-built_in">halfedge2edge</span>(<span class="hljs-keyword">const</span> CGAL_Mesh&amp; m, std::vector&lt;edge_descriptor&gt;&amp; edges)<br>        : <span class="hljs-built_in">m_mesh</span>(m), <span class="hljs-built_in">m_edges</span>(edges)<br>    &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> halfedge_descriptor&amp; h)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_edges.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(h, m_mesh));<br>    &#125;<br>    <span class="hljs-keyword">const</span> CGAL_Mesh&amp; m_mesh;<br>    std::vector&lt;edge_descriptor&gt;&amp; m_edges;<br>&#125;;<br><br>std::pair&lt;py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt;, py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">isotropic_remeshing</span>(py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt;&amp; V, py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; F, <span class="hljs-keyword">double</span> target_edge_length = <span class="hljs-number">1</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nb_iter = <span class="hljs-number">5</span>)<br>&#123;<br>    CGAL_Mesh mesh = <span class="hljs-built_in">convert_mesh_from_Numpy_to_CGAL</span>(V, F);<br>    std::vector&lt;edge_descriptor&gt; border;<br>    PMP::<span class="hljs-built_in">border_halfedges</span>(<span class="hljs-built_in">faces</span>(mesh), mesh, boost::<span class="hljs-built_in">make_function_output_iterator</span>(<span class="hljs-built_in">halfedge2edge</span>(mesh, border)));<br>    PMP::<span class="hljs-built_in">split_long_edges</span>(border, target_edge_length, mesh);<br>    PMP::<span class="hljs-built_in">isotropic_remeshing</span>(<span class="hljs-built_in">faces</span>(mesh), target_edge_length, mesh,<br>        CGAL::parameters::<span class="hljs-built_in">number_of_iterations</span>(nb_iter)<br>        .<span class="hljs-built_in">protect_constraints</span>(<span class="hljs-literal">true</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">convert_mesh_from_CGAL_to_Numpy</span>(mesh);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-绑定部分代码"><a href="#3-2-绑定部分代码" class="headerlink" title="3.2 绑定部分代码"></a>3.2 绑定部分代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">PYBIND11_MODULE</span>(numpy_cgal, m) &#123;<br><br>    m.<span class="hljs-built_in">doc</span>() = <span class="hljs-string">&quot;The CGAL geometry algorithms which called via the Numpy array&quot;</span>;<br>    m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;isotropic_remeshing&quot;</span>, &amp;isotropic_remeshing, <span class="hljs-string">&quot;remeshes a triangular mesh&quot;</span>,<br>        py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;V&quot;</span>), py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;F&quot;</span>), <br>        py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;target_edge_length&quot;</span>) = <span class="hljs-number">1</span>, py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;nb_iter&quot;</span>) = <span class="hljs-number">5</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-示例完整代码"><a href="#3-3-示例完整代码" class="headerlink" title="3.3 示例完整代码"></a>3.3 示例完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pybind11/pybind11.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pybind11/numpy.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;CGAL/Surface_mesh.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;CGAL/Simple_cartesian.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;CGAL/Polygon_mesh_processing/remesh.h&gt;</span></span><br><span class="hljs-keyword">namespace</span> PMP = CGAL::Polygon_mesh_processing;<br><span class="hljs-keyword">namespace</span> py = pybind11;<br><span class="hljs-keyword">typedef</span> CGAL::Simple_cartesian&lt;<span class="hljs-keyword">double</span>&gt;                          Kernal;<br><span class="hljs-keyword">typedef</span> Kernal::Point_3                                         Point;<br><span class="hljs-keyword">typedef</span> CGAL::Surface_mesh&lt;Point&gt;                               CGAL_Mesh;<br><span class="hljs-keyword">typedef</span> boost::graph_traits&lt;CGAL_Mesh&gt;::halfedge_descriptor     halfedge_descriptor;<br><span class="hljs-keyword">typedef</span> boost::graph_traits&lt;CGAL_Mesh&gt;::edge_descriptor         edge_descriptor;<br><br><br><span class="hljs-comment">// 将Numpy VF转换成CGAL mesh</span><br><span class="hljs-function">CGAL_Mesh <span class="hljs-title">convert_mesh_from_Numpy_to_CGAL</span><span class="hljs-params">(py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt;&amp; V, py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; F)</span></span><br><span class="hljs-function"></span>&#123;<br>    CGAL_Mesh CGAL_mesh;<br>    <span class="hljs-comment">// 获取V, F的信息</span><br>    py::buffer_info buf_v = V.<span class="hljs-built_in">request</span>();<br>    py::buffer_info buf_f = F.<span class="hljs-built_in">request</span>();<br>    <span class="hljs-comment">// Validate</span><br>    <span class="hljs-keyword">if</span> (buf_v.ndim != <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Number of dimensions of `V` must be 2&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (buf_v.shape[<span class="hljs-number">1</span>] != <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Number of columns in `V` must be 3&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (buf_f.ndim != <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Number of dimensions of `F` must be 2&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (buf_f.shape[<span class="hljs-number">1</span>] != <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Number of columns in `F` must be 3&quot;</span>);<br><br>    <span class="hljs-keyword">auto</span> v = V.unchecked&lt;<span class="hljs-number">2</span>&gt;(); <span class="hljs-comment">// unchecked: can be non - writeable</span><br>    <span class="hljs-keyword">auto</span> f = F.unchecked&lt;<span class="hljs-number">2</span>&gt;();<br><br>    <span class="hljs-comment">// clear and reserve the mesh</span><br>    CGAL_mesh.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">int</span> vn = buf_v.shape[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 顶点个数</span><br>    <span class="hljs-keyword">int</span> fn = buf_f.shape[<span class="hljs-number">0</span>];    <span class="hljs-comment">// 面个数</span><br>    <span class="hljs-keyword">int</span> e = <span class="hljs-number">0</span>;<br>    CGAL_mesh.<span class="hljs-built_in">reserve</span>(vn, e, fn);<br><br>    <span class="hljs-comment">//copy the vertices</span><br>    <span class="hljs-keyword">double</span> x, y, z;<br>    <span class="hljs-keyword">for</span> (py::<span class="hljs-keyword">ssize_t</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">shape</span>(<span class="hljs-number">0</span>); i++)<br>    &#123;<br>        Point p;<br>        x = <span class="hljs-built_in">v</span>(i, <span class="hljs-number">0</span>);<br>        y = <span class="hljs-built_in">v</span>(i, <span class="hljs-number">1</span>);<br>        z = <span class="hljs-built_in">v</span>(i, <span class="hljs-number">2</span>);<br>        p = <span class="hljs-built_in">Point</span>(x, y, z);<br>        CGAL_mesh.<span class="hljs-built_in">add_vertex</span>(p);<br>    &#125;<br><br>    <span class="hljs-comment">// copy the faces</span><br>    std::vector &lt;<span class="hljs-keyword">int</span>&gt; vertices;<br>    <span class="hljs-keyword">for</span> (py::<span class="hljs-keyword">ssize_t</span> i = <span class="hljs-number">0</span>; i &lt; f.<span class="hljs-built_in">shape</span>(<span class="hljs-number">0</span>); i++)<br>    &#123;<br>        vertices.<span class="hljs-built_in">resize</span>(<span class="hljs-number">3</span>);<br>        vertices[<span class="hljs-number">0</span>] = <span class="hljs-built_in">f</span>(i, <span class="hljs-number">0</span>);<br>        vertices[<span class="hljs-number">1</span>] = <span class="hljs-built_in">f</span>(i, <span class="hljs-number">1</span>);<br>        vertices[<span class="hljs-number">2</span>] = <span class="hljs-built_in">f</span>(i, <span class="hljs-number">2</span>);<br>        CGAL_mesh.<span class="hljs-built_in">add_face</span>(CGAL_Mesh::<span class="hljs-built_in">Vertex_index</span>(vertices[<span class="hljs-number">0</span>]),<br>            CGAL_Mesh::<span class="hljs-built_in">Vertex_index</span>(vertices[<span class="hljs-number">1</span>]),<br>            CGAL_Mesh::<span class="hljs-built_in">Vertex_index</span>(vertices[<span class="hljs-number">2</span>]));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> CGAL_mesh;<br>&#125;<br><br><span class="hljs-comment">// 将CGAL mesh转换成Numpy VF</span><br>std::pair&lt;py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt;, py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">convert_mesh_from_CGAL_to_Numpy</span>(CGAL_Mesh&amp; CGAL_mesh)<br>&#123;<br>    <span class="hljs-comment">//申请内存</span><br>    py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt; V = py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt;(CGAL_mesh.<span class="hljs-built_in">number_of_vertices</span>() * <span class="hljs-number">3</span>);<br>    py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">int</span>&gt; F = py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">int</span>&gt;(CGAL_mesh.<span class="hljs-built_in">number_of_faces</span>() * <span class="hljs-number">3</span>);<br>    std::pair&lt;py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt;, py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">VF</span>(V,F);<br><br>    V.<span class="hljs-built_in">resize</span>(&#123; <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(CGAL_mesh.<span class="hljs-built_in">number_of_vertices</span>()), <span class="hljs-number">3</span> &#125;);<br>    F.<span class="hljs-built_in">resize</span>(&#123; <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(CGAL_mesh.<span class="hljs-built_in">number_of_faces</span>()), <span class="hljs-number">3</span> &#125;);<br><br>    <span class="hljs-keyword">auto</span> v = V.mutable_unchecked&lt;<span class="hljs-number">2</span>&gt;();  <span class="hljs-comment">// mutable_unchecked: can be writeable</span><br>    <span class="hljs-keyword">auto</span> f = F.mutable_unchecked&lt;<span class="hljs-number">2</span>&gt;();<br><br>    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (CGAL_Mesh::Vertex_index vd : <span class="hljs-built_in">vertices</span>(CGAL_mesh))<br>    &#123;<br>        <span class="hljs-built_in">v</span>(i, <span class="hljs-number">0</span>) = CGAL_mesh.<span class="hljs-built_in">point</span>(vd).<span class="hljs-built_in">x</span>();<br>        <span class="hljs-built_in">v</span>(i, <span class="hljs-number">1</span>) = CGAL_mesh.<span class="hljs-built_in">point</span>(vd).<span class="hljs-built_in">y</span>();<br>        <span class="hljs-built_in">v</span>(i, <span class="hljs-number">2</span>) = CGAL_mesh.<span class="hljs-built_in">point</span>(vd).<span class="hljs-built_in">z</span>();<br>        i++;<br>    &#125;<br><br>    i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (CGAL_Mesh::Face_index fd : <span class="hljs-built_in">faces</span>(CGAL_mesh))<br>    &#123;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (CGAL_Mesh::Vertex_index vd : CGAL::<span class="hljs-built_in">vertices_around_face</span>(CGAL_mesh.<span class="hljs-built_in">halfedge</span>(fd), CGAL_mesh))<br>        &#123;<br>            <span class="hljs-built_in">f</span>(i, j) = <span class="hljs-built_in"><span class="hljs-keyword">int</span></span>(vd);<br>            j++;<br>        &#125;<br>        i++;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> VF;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">halfedge2edge</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-built_in">halfedge2edge</span>(<span class="hljs-keyword">const</span> CGAL_Mesh&amp; m, std::vector&lt;edge_descriptor&gt;&amp; edges)<br>        : <span class="hljs-built_in">m_mesh</span>(m), <span class="hljs-built_in">m_edges</span>(edges)<br>    &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> halfedge_descriptor&amp; h)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        m_edges.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(h, m_mesh));<br>    &#125;<br>    <span class="hljs-keyword">const</span> CGAL_Mesh&amp; m_mesh;<br>    std::vector&lt;edge_descriptor&gt;&amp; m_edges;<br>&#125;;<br><br>std::pair&lt;py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt;, py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">isotropic_remeshing</span>(py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">double</span>&gt;&amp; V, py::<span class="hljs-keyword">array_t</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; F, <span class="hljs-keyword">double</span> target_edge_length = <span class="hljs-number">1</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nb_iter = <span class="hljs-number">5</span>)<br>&#123;<br>    CGAL_Mesh mesh = <span class="hljs-built_in">convert_mesh_from_Numpy_to_CGAL</span>(V, F);<br>    std::vector&lt;edge_descriptor&gt; border;<br>    PMP::<span class="hljs-built_in">border_halfedges</span>(<span class="hljs-built_in">faces</span>(mesh), mesh, boost::<span class="hljs-built_in">make_function_output_iterator</span>(<span class="hljs-built_in">halfedge2edge</span>(mesh, border)));<br>    PMP::<span class="hljs-built_in">split_long_edges</span>(border, target_edge_length, mesh);<br>    PMP::<span class="hljs-built_in">isotropic_remeshing</span>(<span class="hljs-built_in">faces</span>(mesh), target_edge_length, mesh,<br>        CGAL::parameters::<span class="hljs-built_in">number_of_iterations</span>(nb_iter)<br>        .<span class="hljs-built_in">protect_constraints</span>(<span class="hljs-literal">true</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">convert_mesh_from_CGAL_to_Numpy</span>(mesh);<br>&#125;<br><br><span class="hljs-comment">// 绑定代码</span><br><span class="hljs-built_in">PYBIND11_MODULE</span>(numpy_cgal, m) <br>&#123;<br>    m.<span class="hljs-built_in">doc</span>() = <span class="hljs-string">&quot;The CGAL geometry algorithms which called via the Numpy array&quot;</span>;<br>    m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;isotropic_remeshing&quot;</span>, &amp;isotropic_remeshing, <span class="hljs-string">&quot;remeshes a triangular mesh&quot;</span>,<br>        py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;V&quot;</span>), py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;F&quot;</span>), <br>        py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;target_edge_length&quot;</span>) = <span class="hljs-number">1</span>, py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;nb_iter&quot;</span>) = <span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里为了图方便将所有代码全写在了一个源文件里，正常来说应当将绑定代码和绑定对象分开。</p><h1 id="四-编译生成和测试"><a href="#四-编译生成和测试" class="headerlink" title="四 编译生成和测试"></a>四 编译生成和测试</h1><h2 id="4-1-编译生成pyd文件"><a href="#4-1-编译生成pyd文件" class="headerlink" title="4.1 编译生成pyd文件"></a>4.1 编译生成pyd文件</h2><p>在这个示例中，我是直接使用Visual Studio编译生成pyd文件。操作很简单，首先是按照这篇文章：<a href="https://blog.csdn.net/qq_39784672/article/details/128390124">pybind11学习 | VS2022下安装配置</a>在VS中配置好pybind11，然后按照这篇文章：<a href="https://blog.csdn.net/qq_39784672/article/details/125839069">CGAL的安装与在VS中的配置</a>在VS中配置好CGAL。在pybind11和CGAL都配置成功的前提下，生成解决方案即可得到pyd文件。如果电脑上没装Visual Studio，也可以尝试使用CMake进行构建，也是十分简单的，只需在这篇文章：<a href="https://blog.csdn.net/qq_39784672/article/details/128468179">pybind11学习 | 使用CMake构建系统并生成pyd文件</a>的示例基础上在<code>CMakeLists.txt</code>中添加CGAL的库文件和头文件即可。</p><h2 id="4-2-Python调用测试"><a href="#4-2-Python调用测试" class="headerlink" title="4.2 Python调用测试"></a>4.2 Python调用测试</h2><p>测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">import</span> igl<br><span class="hljs-keyword">import</span> numpy as np<br>from CGAL <span class="hljs-keyword">import</span> CGAL_Polygon_mesh_processing<br>from CGAL.CGAL_Polyhedron_3 <span class="hljs-keyword">import</span> Polyhedron_3<br><span class="hljs-keyword">import</span> os.<span class="hljs-function">path</span><br><span class="hljs-function"></span><br><span class="hljs-function"></span><br><span class="hljs-function">def <span class="hljs-title">isotropic_remeshing_off</span><span class="hljs-params">(filename, targetedgelength, remeshIter)</span>:</span><br><span class="hljs-function">    if os.path.isfile(filename + <span class="hljs-string">&quot;.off&quot;</span>):</span><br><span class="hljs-function">        V, F, _ =</span> igl.<span class="hljs-built_in">read_off</span>(filename + <span class="hljs-string">&quot;_iso_remesh.off&quot;</span>, False)<br>        <span class="hljs-keyword">return</span> F, V<br>    P = <span class="hljs-built_in">Polyhedron_3</span>(filename + <span class="hljs-string">&quot;.off&quot;</span>)<br>    flist = []<br>    <span class="hljs-keyword">for</span> fh in P.<span class="hljs-built_in">facets</span>():<br>        flist.<span class="hljs-built_in">append</span>(fh)<br>    CGAL_Polygon_mesh_processing.<span class="hljs-built_in">isotropic_remeshing</span>(flist, targetedgelength, P, remeshIter)<br>    P.<span class="hljs-built_in">write_to_file</span>(filename + <span class="hljs-string">&quot;_iso_remesh.off&quot;</span>)<br>    V, F, _ = igl.<span class="hljs-built_in">read_off</span>(filename + <span class="hljs-string">&quot;_iso_remesh.off&quot;</span>, False)<br>    <span class="hljs-keyword">return</span> F, V<br><br><br>def <span class="hljs-built_in">isotropic_remeshing_bindings</span>(V, F, targetedgelength, remeshIter):<br>    <span class="hljs-keyword">import</span> numpy_cgal<br>    V, F = numpy_cgal.<span class="hljs-built_in">isotropic_remeshing</span>(V, F, targetedgelength, remeshIter)<br>    <span class="hljs-keyword">return</span> F, V<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    v, f = igl.<span class="hljs-built_in">read_triangle_mesh</span>(<span class="hljs-string">&quot;test_mesh.off&quot;</span>, dtypef = np.float64)<br>    f_remeshed, v_remeshed = <span class="hljs-built_in">isotropic_remeshing_bindings</span>(v, f, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>其中，第一个<code>isotropic_remeshing_off</code>函数是通过文章<a href="https://blog.csdn.net/qq_39784672/article/details/128001123">【CGAL+Python】安装CGAL的Python绑定</a>中提到的绑定加上读写off文件实现的CGAL重新网格化算法调用。第二个<code>isotropic_remeshing_bindings</code>函数是通过调用pybind11生成的Python拓展模块（即本文的方法，numpy_cgal.pyd为上一小节生成的pyd文件）实现的。</p><p>调试结果如下：</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221230143732408.png" alt="image-20221230143732408"></p><p>可以看到，函数输入为ndarray类型，输出仍然为ndarray类型，且成功重新网格化，测试完毕。</p><h1 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h1><p>本文主要介绍一种在Python代码中调用C++第三方库API的思路。主要目的是抛砖引玉，本文的方法不一定是最好的，仅供大家参考学习。</p><h1 id="参考和拓展"><a href="#参考和拓展" class="headerlink" title="参考和拓展"></a>参考和拓展</h1><p>[1] <a href="https://doc.cgal.org/latest/Surface_mesh/index.html">CGAL 5.5.1 - Surface Mesh: User Manual</a></p><p>[2] <a href="https://doc.cgal.org/latest/Polygon_mesh_processing/index.html">CGAL 5.5.1 - Polygon Mesh Processing: User Manual</a></p><p>[3] <a href="https://pybind11.readthedocs.io/en/stable/index.html">pybind11 documentation</a></p><p>[4] <a href="https://www.jianshu.com/p/be16847b0b74">pybind11—opencv图像处理(numpy数据交换) - 简书 (jianshu.com)</a></p><p>[5] <a href="https://gist.github.com/dmontagu/ea9f7e60e83fc8693245d9e1ddcc31aa">pybind11-wrapped CGAL (github.com)</a></p><p>[6] <a href="https://github.com/cmpute/cgal.py">cmpute/cgal.py: Pybind11 binding of cgal. Aimed at extending and easy use (github.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pybind11学习 使用CMake构建系统并生成pyd文件</title>
    <link href="/2022/12/28/pybind11%E5%AD%A6%E4%B9%A0%20%E4%BD%BF%E7%94%A8CMake%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F%E5%B9%B6%E7%94%9F%E6%88%90pyd%E6%96%87%E4%BB%B6/"/>
    <url>/2022/12/28/pybind11%E5%AD%A6%E4%B9%A0%20%E4%BD%BF%E7%94%A8CMake%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F%E5%B9%B6%E7%94%9F%E6%88%90pyd%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一-通过Visual-Studio生成"><a href="#一-通过Visual-Studio生成" class="headerlink" title="一 通过Visual Studio生成"></a>一 通过Visual Studio生成</h1><p>在我之前的一篇文章<a href="https://blog.csdn.net/qq_39784672/article/details/128390124">pybind11学习 | VS2022下安装配置</a>中，描述了如何通过配置VS2022实现pybind11项目构建和编译成Python拓展模块。</p><h1 id="二-通过CMake生成"><a href="#二-通过CMake生成" class="headerlink" title="二 通过CMake生成"></a>二 通过CMake生成</h1><p>项目结构如下：</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221228134751509.png" alt="image-20221228134751509"></p><p>其中pybind11文件夹为从github上克隆的pybind11源码。</p><p><code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.4</span>)<br><span class="hljs-keyword">project</span>(example)<br><br><span class="hljs-keyword">add_subdirectory</span>(pybind11)<br>pybind11_add_module(example example.cpp)<br></code></pre></td></tr></table></figure><p><code>pybind11_add_module</code>是pybind11提供的一个CMake函数，用于简化pybind11项目的生成Python拓展模块的流程。<code>pybind11_add_module</code>语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pybind11_add_module(&lt;name&gt; [MODULE | SHARED] [EXCLUDE_FROM_ALL]<br>                    [NO_EXTRAS] [THIN_LTO] [OPT_SIZE] source1 [source2 ...])<br></code></pre></td></tr></table></figure><p>在项目源文件目录下，打开windows终端，执行下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir build<br><span class="hljs-built_in">cd</span> build<br>cmake ..<br></code></pre></td></tr></table></figure><p>在cmake构建系统命令打印的结果中有下面一段：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-- Found PythonInterp: D:/anaconda3/envs/Mx_yolov3/python.exe (found suitable version <span class="hljs-string">&quot;3.7.10&quot;</span>, minimum required is <span class="hljs-string">&quot;3.6&quot;</span>)<br>-- Found PythonLibs: D:/anaconda3/envs/Mx_yolov3/libs/python37.lib<br></code></pre></td></tr></table></figure><p>其中<code>PythonInterp</code>和<code>PythonLibs</code>是pybind11自动寻找的，前提是已经在<strong>系统环境变量</strong>中添加了Python路径。生成的<code>build</code>文件夹目录如下：</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221228141009028.png" alt="image-20221228141009028"></p><p>其中将<code>example.sln</code>通过VS打开，在VS中<strong>生成解决方案</strong>即可生成<code>pyd</code>文件。</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221228141329036.png" alt="image-20221228141329036"></p><p>当然，我们也可以直接通过在终端中输入如下命令，直接生成pyd文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir build<br><span class="hljs-built_in">cd</span> build<br>cmake ..<br>cmake --build .<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMAKE学习笔记</title>
    <link href="/2022/12/27/CMAKE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/12/27/CMAKE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="1-CMakeLists-txt基础模板"><a href="#1-CMakeLists-txt基础模板" class="headerlink" title="1 CMakeLists.txt基础模板"></a>1 CMakeLists.txt基础模板</h2><h3 id="1-1-最小项目"><a href="#1-1-最小项目" class="headerlink" title="1.1 最小项目"></a>1.1 最小项目</h3><p><code>CMakeLists.txt</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 指定使用 CMake 的最低版本号</span><br><span class="hljs-keyword">cmake_minimum_required</span> (VERSION <span class="hljs-number">2.6</span>)<br><span class="hljs-comment"># 指定项目名称</span><br><span class="hljs-keyword">project</span> (Tutorial)<br><span class="hljs-comment"># 添加可执行文件</span><br><span class="hljs-keyword">add_executable</span>(Tutorial tutorial.cxx)<br></code></pre></td></tr></table></figure><p><code>tutorial.cxx</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; number&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// convert input to double</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> inputValue = <span class="hljs-built_in">atof</span>(argv[<span class="hljs-number">1</span>]);<br><br>    <span class="hljs-comment">// calculate square root</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> outputValue = <span class="hljs-built_in">sqrt</span>(inputValue);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The square root of &quot;</span> &lt;&lt; inputValue<br>              &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; outputValue<br>              &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-构建、编译和运行"><a href="#1-2-构建、编译和运行" class="headerlink" title="1.2 构建、编译和运行"></a>1.2 构建、编译和运行</h3><p>安装CMake、MinGW64并配置环境变量。终端进入到<code>CMakeLists.txt</code>目录，输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br># 构建<br>cmake -G&quot;MinGW Makefiles&quot; ..<br># 编译链接<br>cmake --build .<br># 运行<br>.\Tutorial.exe <span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>cmake -G&lt;编译器名称&gt; &lt;CMakeLists.txt路径&gt;</li><li>cmake –build &lt;编译生成文件存放路径&gt;</li></ul></blockquote><h2 id="2-CMakeLists-txt优化"><a href="#2-CMakeLists-txt优化" class="headerlink" title="2 CMakeLists.txt优化"></a>2 CMakeLists.txt优化</h2><h3 id="2-1-set-与-PROJECT-NAME"><a href="#2-1-set-与-PROJECT-NAME" class="headerlink" title="2.1 set 与 PROJECT_NAME"></a>2.1 set 与 PROJECT_NAME</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">2.6</span>)<br><span class="hljs-keyword">project</span>(Tutorial)<br><br><span class="hljs-comment">## SET(&lt;变量名&gt; &lt;变量值&gt;)</span><br><span class="hljs-keyword">SET</span>(SRC_LIST tutorial.cxx)<br><br><span class="hljs-comment"># $&#123;变量名&#125;: 获取变量的值</span><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-2-添加版本号和配置头文件"><a href="#2-2-添加版本号和配置头文件" class="headerlink" title="2.2 添加版本号和配置头文件"></a>2.2 添加版本号和配置头文件</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span> (VERSION <span class="hljs-number">2.6</span>)<br><span class="hljs-comment"># 指定项目名及其版本号</span><br><span class="hljs-keyword">project</span>(Tutorial VERSION <span class="hljs-number">1.0</span>)<br><span class="hljs-comment"># 版本号也可以通过下面方式指定</span><br><span class="hljs-comment">## project(Tutorial)</span><br><span class="hljs-comment">## set (Tutorial_VERSION_MAJOR 1)</span><br><span class="hljs-comment">## set (Tutorial_VERSION_MINOR 0)</span><br><span class="hljs-keyword">SET</span>(SRC_LIST tutorial.cxx)<br><br><span class="hljs-comment"># 配置一个头文件，通过它向源代码中传递一些CMake设置。TutorialConfig.h.in需要我们编写，TutorialConfig.h自动生成</span><br><span class="hljs-keyword">configure_file</span> (<br>  <span class="hljs-string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/TutorialConfig.h.in&quot;</span><span class="hljs-comment"># TutorialConfig.h.in在源文件目录下</span><br>  <span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h&quot;</span><span class="hljs-comment"># TutorialConfig.h在生成的二进制文件树目录下</span><br>  )<br><span class="hljs-comment"># 将二进制文件树添加到包含文件的搜索路径中，这样我们可以找到TutorialConfig.h</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-string">&quot;$&#123;PROJECT_BINARY_DIR&#125;&quot;</span>)<br><span class="hljs-comment"># 添加可执行文件</span><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure><p><code>TutorialConfig.h.in</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// the configured options and settings for Tutorial</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</span><br></code></pre></td></tr></table></figure><p>自动生成的<code>TutorialConfig.h</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// the configured options and settings for Tutorial</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Tutorial_VERSION_MAJOR 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> Tutorial_VERSION_MINOR 0</span><br></code></pre></td></tr></table></figure><p>修改<code>tutorial.cxx</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;TutorialConfig.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-comment">// report version</span><br>      std::cout &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; Version &quot;</span> &lt;&lt; Tutorial_VERSION_MAJOR &lt;&lt; <span class="hljs-string">&quot;.&quot;</span> &lt;&lt; Tutorial_VERSION_MINOR &lt;&lt; std::endl;<br>      std::cout &lt;&lt; <span class="hljs-string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&quot; number&quot;</span> &lt;&lt; std::endl;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>  <span class="hljs-keyword">double</span> inputValue = <span class="hljs-built_in">atof</span>(argv[<span class="hljs-number">1</span>]);<br>  <span class="hljs-keyword">double</span> outputValue = <span class="hljs-built_in">sqrt</span>(inputValue);<br>  <span class="hljs-built_in">fprintf</span>(stdout,<span class="hljs-string">&quot;The square root of %g is %g\n&quot;</span>, inputValue, outputValue);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">PS D:\CMAKE_Learn\build&gt; .\Tutorial.exe<br><span class="hljs-function">D:\<span class="hljs-title">CMAKE_Learn</span>\<span class="hljs-title">build</span>\<span class="hljs-title">Tutorial.exe</span> <span class="hljs-title">Version</span> 1.0</span><br><span class="hljs-function"><span class="hljs-title">Usage</span>: <span class="hljs-title">D</span>:\<span class="hljs-title">CMAKE_Learn</span>\<span class="hljs-title">build</span>\<span class="hljs-title">Tutorial.exe</span> <span class="hljs-title">number</span></span><br><span class="hljs-function"><span class="hljs-title">PS</span> <span class="hljs-title">D</span>:\<span class="hljs-title">CMAKE_Learn</span>\<span class="hljs-title">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-3-指定-C-标准"><a href="#2-3-指定-C-标准" class="headerlink" title="2.3 指定 C++ 标准"></a>2.3 指定 C++ 标准</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 指定C++标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">True</span>)<br></code></pre></td></tr></table></figure><h2 id="3-添加库"><a href="#3-添加库" class="headerlink" title="3 添加库"></a>3 添加库</h2><p>一般我们将库的源码放在项目源文件目录下的MathFunctions子目录中，并在该<strong>子目录</strong>（该目录下包含头文件<code>MathFunctions.h</code>和相关源文件<code>mysqrt.cxx</code>）下新建一个<code>CMakeLists.txt</code>，添加如下内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 添加一个叫 MathFunctions 的库文件</span><br><span class="hljs-keyword">add_library</span>(MathFunctions mysqrt.cxx)<br></code></pre></td></tr></table></figure><p>此时项目文件结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">CMAKE_Learn/<br>    build/<br>    MathFunctions/<br>        CMakeLists.txt<br>        MathFunctions.h<br>        mysqrt.cxx<br>    CMakeLists.txt<br>    tutorial.cxx<br>    TutorialConfig.h.in<br></code></pre></td></tr></table></figure><p>再在顶层目录下的CMakeLists.txt文件中添加如下内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 向当前工程添加存放源文件的子目录，指定库所在的子目录</span><br><span class="hljs-keyword">add_subdirectory</span>(MathFunctions)<br><span class="hljs-comment">#生成可执行文件</span><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> tutorial.cpp)<br><span class="hljs-comment"># 指定将MathFunctions库链接到项目Tutorial的可执行文件</span><br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC MathFunctions)<br><span class="hljs-comment"># add the binary tree to the search path for include files</span><br><span class="hljs-comment"># so that we will find TutorialConfig.h</span><br><span class="hljs-keyword">target_include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC<br>                           <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span><span class="hljs-comment"># CMake生成的TutorialConfig.h存放目录</span><br>                           <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/MathFunctions<span class="hljs-comment"># 库的头文件存放目录</span><br>                           )<br></code></pre></td></tr></table></figure><blockquote><p>CMake中<code>target_xxx</code>关键字<strong>指定编译给定目标时相关内容</strong>，在上面命令中即指定Tutorial这个项目编译过程中包含的头文件目录和库文件目录。</p></blockquote><h2 id="4-将库设置为可选项"><a href="#4-将库设置为可选项" class="headerlink" title="4 将库设置为可选项"></a>4 将库设置为可选项</h2><p>第一步是向顶级 CMakeLists.txt 文件添加一个选项。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">option</span>(USE_MYMATH <span class="hljs-string">&quot;Use tutorial provided math implementation&quot;</span> <span class="hljs-keyword">ON</span>)<br></code></pre></td></tr></table></figure><p><code>option</code> 表示提供用户可以选择的选项。命令格式为：<code>option(&lt;variable&gt; &quot;description [initial value])</code>。<code>USE_MYMATH</code> 选项的缺省值为 <code>ON</code>。</p><p>下一步创建if语句，</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">if</span>(USE_MYMATH)<br>  <span class="hljs-keyword">add_subdirectory</span>(MathFunctions)<br>  <span class="hljs-keyword">list</span>(APPEND EXTRA_LIBS MathFunctions)<br>  <span class="hljs-keyword">list</span>(APPEND EXTRA_INCLUDES <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/MathFunctions)<br><span class="hljs-keyword">endif</span>()<br><br><span class="hljs-keyword">add_executable</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> tutorial.cpp)<br><span class="hljs-keyword">target_link_libraries</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC <span class="hljs-variable">$&#123;EXTRA_LIBS&#125;</span>)<br><span class="hljs-keyword">target_include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC<br>                           <span class="hljs-variable">$&#123;PROJECT_BINARY_DIR&#125;</span><br>                           <span class="hljs-variable">$&#123;EXTRA_INCLUDES&#125;</span><br>                           )<br></code></pre></td></tr></table></figure><p><code>APPEND</code>表示将元素<code>MathFunctions</code>追加到列表<code>EXTRA_LIBS</code>中，将元素 <code>$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions</code> 追加到列表<code>EXTRA_INCLUDES</code>中。<code>EXTRA_LIBS</code> 存储 MathFunctions 库，<code>EXTRA_INCLUDES</code> 存储 MathFunctions 头文件。因此在<code>target_link_libraries</code>和<code>target_include_directories</code>中用<code>$&#123;EXTRA_LIBS&#125;</code>和<code>$&#123;EXTRA_INCLUDES&#125;</code>分别获取库文件和头文件目录。</p><p>当然也可以通过TutorialConfig.h.in配置文件实现上述效果，修改<code>tutorial.cxx</code>如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;TutorialConfig.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> USE_MYMATH</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;MathFunctions.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stdout,<span class="hljs-string">&quot;%s Version %d.%d\n&quot;</span>, argv[<span class="hljs-number">0</span>],<br>            Tutorial_VERSION_MAJOR,<br>            Tutorial_VERSION_MINOR);<br>        <span class="hljs-built_in">fprintf</span>(stdout,<span class="hljs-string">&quot;Usage: %s number\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">double</span> inputValue = <span class="hljs-built_in">atof</span>(argv[<span class="hljs-number">1</span>]);<br>    <br><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> USE_MYMATH</span><br>    <span class="hljs-keyword">double</span> outputValue = <span class="hljs-built_in">mysqrt</span>(inputValue);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><br>    <span class="hljs-keyword">double</span> outputValue = <span class="hljs-built_in">sqrt</span>(inputValue);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br><br>    <span class="hljs-built_in">fprintf</span>(stdout,<span class="hljs-string">&quot;The square root of %g is %g\n&quot;</span>, inputValue, outputValue);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>TutorialConfig.h.in</code>中添加一行，添加宏<code>USE_MYMATH</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#cmakedefine USE_MYMATH</span><br></code></pre></td></tr></table></figure><p>在构建项目时可以选择性地使用库：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 在构建项目时不使用库<br>cmake -DUSE_MYMATH=OFF ..<br></code></pre></td></tr></table></figure><h2 id="5-添加库的使用要求"><a href="#5-添加库的使用要求" class="headerlink" title="5 添加库的使用要求"></a>5 添加库的使用要求</h2><p>库的使用要求有三个：</p><ul><li><strong>INTERFACE</strong>：表示用户需要，开发者不需要；</li><li><strong>PRIVATE</strong>：表示用户不需要，开发者需要；</li><li><strong>PUBLIC</strong>：表示用户和开发者都需要。</li></ul><h2 id="6-动态库和静态库构建"><a href="#6-动态库和静态库构建" class="headerlink" title="6 动态库和静态库构建"></a>6 动态库和静态库构建</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">add_library</span>(&lt;name&gt; [STATIC | SHARED | MODULE]<br>              [EXCLUDE_FROM_ALL]<br>              source1 source2 ... sourceN)<br></code></pre></td></tr></table></figure><p>添加一个名为<code>&lt;name&gt;</code>的库文件，该库文件将会根据调用的命令里列出的源文件来创建。<code>STATIC</code>为静态库，<code>SHARED</code>为动态库。</p><p><strong>静态库和动态库的区别</strong></p><ul><li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”；</li><li>静态库在编译<strong>链接阶段</strong>会直接整合到目标程序中，编译链接成功的可执行文件可独立运行；</li><li>动态库在编译时不会放到链接的目标程序中，而是在<strong>运行阶段</strong>加载，即可执行文件无法单独运行。</li></ul><h2 id="7-包含第三方库"><a href="#7-包含第三方库" class="headerlink" title="7 包含第三方库"></a>7 包含第三方库</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">find_package</span>(&lt;package&gt; [version] [EXACT] [QUIET]<br>              [[REQUIRED|COMPONENTS] [components...]]<br>              [NO_POLICY_SCOPE])<br></code></pre></td></tr></table></figure><p>查找并加载第三方库。该命令会设置<code>&lt;package&gt;_FOUND</code>变量，用来指示要找的包是否被找到了。<code>REQUIRED</code>选项表示如果报没有找到的话，cmake的过程会终止，并输出警告信息。<code>[version]</code>参数为第三方库的最低版本。<code>COMPONENTS</code>选项后面可以列出要查找的库列表(components list)。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/500002865">https://zhuanlan.zhihu.com/p/500002865</a></p><p>[2] <a href="https://cmake.org/cmake/help/latest/guide/tutorial/index.html">CMake Tutorial — CMake 3.25.1 Documentation</a></p><p>[3] <a href="https://blog.csdn.net/qq_44074143/article/details/123244847">https://blog.csdn.net/qq_44074143/article/details/123244847</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pybind11学习 异常转换和类型转换</title>
    <link href="/2022/12/25/pybind11%E5%AD%A6%E4%B9%A0%20%E5%BC%82%E5%B8%B8%E8%BD%AC%E6%8D%A2%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2022/12/25/pybind11%E5%AD%A6%E4%B9%A0%20%E5%BC%82%E5%B8%B8%E8%BD%AC%E6%8D%A2%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要记录官方文档中 <strong>EXCEPTIONS</strong> 和 <strong>TYPE CONVERSIONS</strong> 一章的学习笔记。</p></blockquote><p>[TOC]</p><h1 id="一-异常转换"><a href="#一-异常转换" class="headerlink" title="一 异常转换"></a>一 异常转换</h1><h2 id="1-1-C-内置异常到Python异常的转换"><a href="#1-1-C-内置异常到Python异常的转换" class="headerlink" title="1.1 C++内置异常到Python异常的转换"></a>1.1 C++内置异常到Python异常的转换</h2><p>当Python通过pybind11调用C++代码时，pybind11将捕获C++异常，并将其翻译为对应的Python异常后抛出，这样Python代码就能够处理它们。</p><table><thead><tr><th>C++抛出的异常</th><th>转换到Python的异常类型</th></tr></thead><tbody><tr><td><code>std::exception</code></td><td><code>RuntimeError</code></td></tr><tr><td><code>std::bad_alloc</code></td><td><code>MemoryError</code></td></tr><tr><td><code>std::domain_error</code></td><td><code>ValueError</code></td></tr><tr><td><code>std::invalid_argument</code></td><td><code>ValueError</code></td></tr><tr><td><code>std::length_error</code></td><td><code>ValueError</code></td></tr><tr><td><code>std::out_of_range</code></td><td><code>IndexError</code></td></tr><tr><td><code>std::range_error</code></td><td><code>ValueError</code></td></tr><tr><td><code>std::overflow_error</code></td><td><code>OverflowError</code></td></tr><tr><td><code>pybind11::stop_iteration</code></td><td><code>StopIteration</code></td></tr><tr><td><code>pybind11::index_error</code></td><td><code>IndexError</code></td></tr><tr><td><code>pybind11::key_error</code></td><td><code>KeyError</code></td></tr><tr><td><code>pybind11::value_error</code></td><td><code>ValueError</code></td></tr><tr><td><code>pybind11::type_error</code></td><td><code>TypeError</code></td></tr><tr><td><code>pybind11::buffer_error</code></td><td><code>BufferError</code></td></tr><tr><td><code>pybind11::import_error</code></td><td><code>ImportError</code></td></tr><tr><td><code>pybind11::attribute_error</code></td><td><code>AttributeError</code></td></tr><tr><td>其他异常</td><td><code>RuntimeError</code></td></tr></tbody></table><blockquote><p>当入参不能转化为Python对象时，<code>handle::call()</code>将抛出<code>pybind11::cast_error</code>异常。</p></blockquote><h2 id="1-2-注册自定义异常转换"><a href="#1-2-注册自定义异常转换" class="headerlink" title="1.2 注册自定义异常转换"></a>1.2 注册自定义异常转换</h2><p>当上述的异常转换不能满足我们需求时，我们可以注册一个自定义的C++到Python的异常转换。使用下面的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">py::register_exception&lt;CppExp&gt;(<span class="hljs-keyword">module</span>, <span class="hljs-string">&quot;PyExp&quot;</span>);<span class="hljs-comment">// 全局</span><br>py::register_local_exception&lt;CppExp&gt;(<span class="hljs-keyword">module</span>, <span class="hljs-string">&quot;PyExp&quot;</span>);<span class="hljs-comment">// 模块内</span><br>py::register_exception&lt;CppExp&gt;(<span class="hljs-keyword">module</span>, <span class="hljs-string">&quot;PyExp&quot;</span>, PyExc_RuntimeError);<span class="hljs-comment">// 第三个参数可以指定异常基类，实现PyExp异常可以捕获PyExp和RuntimeError</span><br></code></pre></td></tr></table></figure><p>这个调用在指定模块创建了一个名称为PyExp的Python异常，并自动将CppExp相关的异常转换为PyExp异常。</p><h2 id="1-3-在C-中处理Python异常"><a href="#1-3-在C-中处理Python异常" class="headerlink" title="1.3 在C++中处理Python异常"></a>1.3 在C++中处理Python异常</h2><p>[1.1节](##1.1 C++内置异常到Python异常的转换)是C++异常到Python异常的转换，这一节为Python异常到C++异常的转换。</p><table><thead><tr><th>在Python中抛出的异常</th><th>作为C++异常类型抛出</th></tr></thead><tbody><tr><td>Any Python <code>Exception</code></td><td><code>pybind11::error_already_set</code></td></tr></tbody></table><p>下面例子演示了如何在C++侧处理捕获到的Python异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// open(&quot;missing.txt&quot;, &quot;r&quot;)</span><br>    <span class="hljs-keyword">auto</span> file = py::module_::<span class="hljs-built_in"><span class="hljs-keyword">import</span></span>(<span class="hljs-string">&quot;io&quot;</span>).<span class="hljs-built_in">attr</span>(<span class="hljs-string">&quot;open&quot;</span>)(<span class="hljs-string">&quot;missing.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">auto</span> text = file.<span class="hljs-built_in">attr</span>(<span class="hljs-string">&quot;read&quot;</span>)();<br>    file.<span class="hljs-built_in">attr</span>(<span class="hljs-string">&quot;close&quot;</span>)();<br>&#125; <span class="hljs-built_in"><span class="hljs-keyword">catch</span></span> (py::error_already_set &amp;e) &#123;<br>    <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">matches</span>(PyExc_FileNotFoundError)) &#123;<br>        py::<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;missing.txt not found&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">matches</span>(PyExc_PermissionError)) &#123;<br>        py::<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;missing.txt found but not accessible&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二-类型转换"><a href="#二-类型转换" class="headerlink" title="二 类型转换"></a>二 类型转换</h1><h2 id="2-1-包装和类型转换"><a href="#2-1-包装和类型转换" class="headerlink" title="2.1 包装和类型转换"></a>2.1 包装和类型转换</h2><p>在C++中使用原生的Python类型（如list或tuple等），我们有两种方式。第一，通过包装，将原生Python类型通过<code>py::object</code>派生包装器包装，在C++中撕掉包装后再使用，其核心仍然是一个Python对象。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> py = pybind11;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_list</span><span class="hljs-params">(py::list my_list)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : my_list)<br>        std::cout &lt;&lt; item &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>print_list([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><blockquote><p>其中<code>py::list</code>便是Python原生类型<code>list</code>在C++中的包装类型。</p></blockquote><p>第二种方式是通过类型转换，将原生Python类型转换成原生C++类型后再在C++侧使用，即两侧都使用各自的原生类型。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_vector</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : v)<br>        std::cout &lt;&lt; item &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>print_vector([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>上面这个例子中，Python原生类型<code>list</code>到C++原生类型<code>vector</code>的转换时通过pybind11自动完成的。更多开箱即用（pybind11内置转换，不需要我们自定义类型转换）的类型转换见下表。</p><table><thead><tr><th>数据类型</th><th>描述</th><th>头文件</th></tr></thead><tbody><tr><td><code>int8_t</code>, <code>uint8_t</code></td><td>8-bit integers</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>int16_t</code>, <code>uint16_t</code></td><td>16-bit integers</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>int32_t</code>, <code>uint32_t</code></td><td>32-bit integers</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>int64_t</code>, <code>uint64_t</code></td><td>64-bit integers</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>ssize_t</code>, <code>size_t</code></td><td>Platform-dependent size</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>float</code>, <code>double</code></td><td>Floating point types</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>bool</code></td><td>Two-state Boolean type</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>char</code></td><td>Character literal</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>char16_t</code></td><td>UTF-16 character literal</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>char32_t</code></td><td>UTF-32 character literal</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>wchar_t</code></td><td>Wide character literal</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>const char *</code></td><td>UTF-8 string literal</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>const char16_t *</code></td><td>UTF-16 string literal</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>const char32_t *</code></td><td>UTF-32 string literal</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>const wchar_t *</code></td><td>Wide string literal</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>std::string</code></td><td>STL dynamic UTF-8 string</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>std::u16string</code></td><td>STL dynamic UTF-16 string</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>std::u32string</code></td><td>STL dynamic UTF-32 string</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>std::wstring</code></td><td>STL dynamic wide string</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>std::string_view</code>, <code>std::u16string_view</code>, etc.</td><td>STL C++17 string views</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>std::pair&lt;T1, T2&gt;</code></td><td>Pair of two custom types</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>std::tuple&lt;...&gt;</code></td><td>Arbitrary tuple of types</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>std::reference_wrapper&lt;...&gt;</code></td><td>Reference type wrapper</td><td><code>pybind11/pybind11.h</code></td></tr><tr><td><code>std::complex&lt;T&gt;</code></td><td>Complex numbers</td><td><code>pybind11/complex.h</code></td></tr><tr><td><code>std::array&lt;T, Size&gt;</code></td><td>STL static array</td><td><code>pybind11/stl.h</code></td></tr><tr><td><code>std::vector&lt;T&gt;</code></td><td>STL dynamic array</td><td><code>pybind11/stl.h</code></td></tr><tr><td><code>std::deque&lt;T&gt;</code></td><td>STL double-ended queue</td><td><code>pybind11/stl.h</code></td></tr><tr><td><code>std::valarray&lt;T&gt;</code></td><td>STL value array</td><td><code>pybind11/stl.h</code></td></tr><tr><td><code>std::list&lt;T&gt;</code></td><td>STL linked list</td><td><code>pybind11/stl.h</code></td></tr><tr><td><code>std::map&lt;T1, T2&gt;</code></td><td>STL ordered map</td><td><code>pybind11/stl.h</code></td></tr><tr><td><code>std::unordered_map&lt;T1, T2&gt;</code></td><td>STL unordered map</td><td><code>pybind11/stl.h</code></td></tr><tr><td><code>std::set&lt;T&gt;</code></td><td>STL ordered set</td><td><code>pybind11/stl.h</code></td></tr><tr><td><code>std::unordered_set&lt;T&gt;</code></td><td>STL unordered set</td><td><code>pybind11/stl.h</code></td></tr><tr><td><code>std::optional&lt;T&gt;</code></td><td>STL optional type (C++17)</td><td><code>pybind11/stl.h</code></td></tr><tr><td><code>std::experimental::optional&lt;T&gt;</code></td><td>STL optional type (exp.)</td><td><code>pybind11/stl.h</code></td></tr><tr><td><code>std::variant&lt;...&gt;</code></td><td>Type-safe union (C++17)</td><td><code>pybind11/stl.h</code></td></tr><tr><td><code>std::filesystem::path&lt;T&gt;</code></td><td>STL path (C++17) <a href="https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html#id2">1</a></td><td><code>pybind11/stl.h</code></td></tr><tr><td><code>std::function&lt;...&gt;</code></td><td>STL polymorphic function</td><td><code>pybind11/functional.h</code></td></tr><tr><td><code>std::chrono::duration&lt;...&gt;</code></td><td>STL time duration</td><td><code>pybind11/chrono.h</code></td></tr><tr><td><code>std::chrono::time_point&lt;...&gt;</code></td><td>STL date/time</td><td><code>pybind11/chrono.h</code></td></tr><tr><td><code>Eigen::Matrix&lt;...&gt;</code></td><td>Eigen: dense matrix</td><td><code>pybind11/eigen.h</code></td></tr><tr><td><code>Eigen::Map&lt;...&gt;</code></td><td>Eigen: mapped memory</td><td><code>pybind11/eigen.h</code></td></tr><tr><td><code>Eigen::SparseMatrix&lt;...&gt;</code></td><td>Eigen: sparse matrix</td><td><code>pybind11/eigen.h</code></td></tr></tbody></table><p><font color=green>注意：上述的内置转换都是基于<strong>数据拷贝</strong>的。这对小型的不变的类型相当友好，对于大型数据结构则相当昂贵。这可以通过自定义包装类型重载自动转换来解决。</font></p><h2 id="2-2-STL容器"><a href="#2-2-STL容器" class="headerlink" title="2.2 STL容器"></a>2.2 STL容器</h2><p>包含头文件<code>pybind11/stl.h</code>，将支持如下内置转换：</p><table><thead><tr><th>C++</th><th>Python</th></tr></thead><tbody><tr><td><code>std::vector&lt;&gt;</code>/<code>std::deque&lt;&gt;</code>/<code>std::list&lt;&gt;</code>/<code>std::array&lt;&gt;</code>/<code>std::valarray&lt;&gt;</code></td><td>list</td></tr><tr><td><code>std::set&lt;&gt;</code>/<code>std::unordered_set&lt;&gt;</code></td><td>set</td></tr><tr><td><code>std::map&lt;&gt;</code>/<code>std::unordered_map&lt;&gt;</code></td><td>dict</td></tr></tbody></table><blockquote><p>这些类型任意嵌套都是可以自动转换的。</p></blockquote><h3 id="2-2-1-绑定STL容器"><a href="#2-2-1-绑定STL容器" class="headerlink" title="2.2.1 绑定STL容器"></a>2.2.1 绑定STL容器</h3><p>有时，我们需要创建STL容器的Python绑定，使在Python中将STL容器作为对象进行使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 必须包含的头文件</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pybind11/stl_bind.h&gt;</span></span><br><br><span class="hljs-built_in">PYBIND11_MAKE_OPAQUE</span>(std::vector&lt;<span class="hljs-keyword">int</span>&gt;);<br><span class="hljs-built_in">PYBIND11_MAKE_OPAQUE</span>(std::map&lt;std::string, <span class="hljs-keyword">double</span>&gt;);<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-comment">// 绑定代码</span><br>py::bind_vector&lt;std::vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;(m, <span class="hljs-string">&quot;VectorInt&quot;</span>);<br>py::bind_map&lt;std::map&lt;std::string, <span class="hljs-keyword">double</span>&gt;&gt;(m, <span class="hljs-string">&quot;MapStringDouble&quot;</span>);<br></code></pre></td></tr></table></figure><p>pybind11提供了<code>PYBIND11_MAKE_OPAQUE(T)</code>来禁用基于模板的类型转换机制，从而使他们变得不透明（<em>opaque</em>）。opaque对象的内容永远不会被检查或提取，因此它们可以通过<strong>引用传递</strong>。这样一来避免对大型列表进行<strong>拷贝操作</strong>带来的耗时。</p><h2 id="2-3-函数对象"><a href="#2-3-函数对象" class="headerlink" title="2.3 函数对象"></a>2.3 函数对象</h2><p>如果一个将函数对象作为函数的参数，那么设计Python中函数和C++函数对象之间的转换。有一如下示例函数，接收一函数对象，返回一函数对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pybind11/functional.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func_arg</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>)&gt; &amp;f)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(<span class="hljs-number">10</span>);<br>&#125;<br><br><span class="hljs-function">std::function&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span>&gt; <span class="hljs-title">func_ret</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::function&lt;<span class="hljs-keyword">int</span>(<span class="hljs-keyword">int</span>)&gt; &amp;f)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> [f](<span class="hljs-keyword">int</span> i) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(i) + <span class="hljs-number">1</span>;<br>    &#125;;<br>&#125;<br><br><span class="hljs-function">py::cpp_function <span class="hljs-title">func_cpp</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> py::<span class="hljs-built_in">cpp_function</span>([](<span class="hljs-keyword">int</span> i) &#123; <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>; &#125;,<br>       py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;number&quot;</span>));<br>&#125;<br><br><span class="hljs-built_in">PYBIND11_MODULE</span>(example, m) &#123;<br>    m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;func_arg&quot;</span>, &amp;func_arg);<br>    m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;func_ret&quot;</span>, &amp;func_ret);<br>    m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;func_cpp&quot;</span>, &amp;func_cpp);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pybind11学习 类的绑定</title>
    <link href="/2022/12/24/pybind11%E5%AD%A6%E4%B9%A0%20%E7%B1%BB%E7%9A%84%E7%BB%91%E5%AE%9A/"/>
    <url>/2022/12/24/pybind11%E5%AD%A6%E4%B9%A0%20%E7%B1%BB%E7%9A%84%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要记录官方文档中 <strong>CLASSES</strong> 一章的学习笔记。</p><p>对于C++ 类的Python绑定，在前面的学习中已经有所涉及了，详见：<a href="https://blog.csdn.net/qq_39784672/article/details/128411992">pybind11学习 | 面向对象编程</a>。本文主要是记录一些更加深入的知识。在本文中只涉及了一些我感兴趣的部分，其他部分详见官方文档<strong>CLASSES</strong> 一章。</p></blockquote><p>[TOC]</p><h2 id="1-在Python中重载虚函数"><a href="#1-在Python中重载虚函数" class="headerlink" title="1 在Python中重载虚函数"></a>1 在Python中重载虚函数</h2><p>一个含有虚函数的C++类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">go</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n_times)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> :</span> <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">go</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n_times)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::string result;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n_times; ++i)<br>            result += <span class="hljs-string">&quot;woof! &quot;</span>;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">std::string <span class="hljs-title">call_go</span><span class="hljs-params">(Animal *animal)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> animal-&gt;<span class="hljs-built_in">go</span>(<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在Python中自定义一个继承自<code>Animal</code>的新类，并想要重载基类中的虚函数。此时，直接<code>class_::def</code>对<code>Animal</code>类的虚函数进行绑定是不行的，需要在C++中再定义一个新的PyAnimal类（继承自Animal类）作为<strong>辅助跳板</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PyAnimal</span> :</span> <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/* Inherit the constructors */</span><br>    <span class="hljs-keyword">using</span> Animal::Animal;<br><br>    <span class="hljs-comment">/* Trampoline (need one for each virtual function) */</span><br>    <span class="hljs-function">std::string <span class="hljs-title">go</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n_times)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-built_in">PYBIND11_OVERRIDE_PURE</span>(<br>            std::string, <span class="hljs-comment">/* Return type */</span><br>            Animal,      <span class="hljs-comment">/* Parent class */</span><br>            go,          <span class="hljs-comment">/* Name of function in C++ (must match Python name) */</span><br>            n_times      <span class="hljs-comment">/* Argument(s) */</span><br>        );<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码中，定义纯虚函数时需要使用<code>PYBIND11_OVERRIDE_PURE</code>宏，而有默认实现的虚函数则使用<code>PYBIND11_OVERRIDE</code>。<code>PYBIND11_OVERRIDE_PURE_NAME</code> 和<code>PYBIND11_OVERRIDE_NAME</code> 宏的功能类似，主要用于C函数名和Python函数名不一致的时候。pybind11绑定代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">PYBIND11_MODULE</span>(example, m) &#123;<br>    py::class_&lt;Animal, PyAnimal <span class="hljs-comment">/* &lt;--- 跳板类*/</span>&gt;(m, <span class="hljs-string">&quot;Animal&quot;</span>)<br>        .<span class="hljs-built_in">def</span>(py::init&lt;&gt;())<br>        .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;go&quot;</span>, &amp;Animal::go); <span class="hljs-comment">// 绑定的是真实类的方法，而不是跳板类的方法</span><br><br>    py::class_&lt;Dog, Animal&gt;(m, <span class="hljs-string">&quot;Dog&quot;</span>)<br>        .<span class="hljs-built_in">def</span>(py::init&lt;&gt;());<br><br>    m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;call_go&quot;</span>, &amp;call_go);<br>&#125;<br></code></pre></td></tr></table></figure><p>pybind11通过向<code>class_</code>指定额外的模板参数PyAnimal，让我们可以在Python中继承Animal类（即重载C++类中的为虚函数的构造函数）。Python中测试如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> example <span class="hljs-keyword">import</span> *<br>d = Dog()<br>call_go(d)     <span class="hljs-comment"># &#x27;woof! woof! woof! &#x27;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">Animal</span>):</span><span class="hljs-comment"># 继承</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go</span>(<span class="hljs-params">self, n_times</span>):</span><span class="hljs-comment"># 重载虚函数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;meow! &quot;</span> * n_times<br><br>c = Cat()<br>call_go(c)   <span class="hljs-comment"># &#x27;meow! meow! meow! &#x27;</span><br></code></pre></td></tr></table></figure><h2 id="2-自定义构造函数"><a href="#2-自定义构造函数" class="headerlink" title="2 自定义构造函数"></a>2 自定义构造函数</h2><p>若C++类中没有构造函数，我们可以显式地将自定义函数作为类的构造函数绑定到Python类的<code>__init__</code>方法上。pybind11通过调用<code>.def(py::init(...))</code>，将对应的函数（函数需要返回一个新实例）作为参数传入<code>py::init()</code>实现。<code>py::init()</code>也可以传入返回新实例原始指针或持有者的匿名函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Example</span>(<span class="hljs-keyword">int</span>); <span class="hljs-comment">// private constructor</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Factory function - returned by value:</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> Example <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Example</span>(a); &#125;<br><br>    <span class="hljs-comment">// These constructors are publicly callable:</span><br>    <span class="hljs-built_in">Example</span>(<span class="hljs-keyword">double</span>);<br>    <span class="hljs-built_in">Example</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>);<br>    <span class="hljs-built_in">Example</span>(std::string);<br>&#125;;<br><br>py::class_&lt;Example&gt;(m, <span class="hljs-string">&quot;Example&quot;</span>)<br>    <span class="hljs-comment">// 绑定一个工厂函数作为构造函数</span><br>    .<span class="hljs-built_in">def</span>(py::<span class="hljs-built_in">init</span>(&amp;Example::create))<br>    <span class="hljs-comment">// 绑定匿名函数返回实例的原始指针的持有者</span><br>    .<span class="hljs-built_in">def</span>(py::<span class="hljs-built_in">init</span>([](std::string arg) &#123;<br>        <span class="hljs-keyword">return</span> std::unique_ptr&lt;Example&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Example</span>(arg));<br>    &#125;))<br>    <span class="hljs-comment">// 匿名函数返回原始指针</span><br>    .<span class="hljs-built_in">def</span>(py::<span class="hljs-built_in">init</span>([](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Example</span>(a, b); &#125;))<br>    <span class="hljs-comment">// 对构造函数进行常规绑定</span><br>    .<span class="hljs-built_in">def</span>(py::init&lt;<span class="hljs-keyword">double</span>&gt;())<br>    ;<br></code></pre></td></tr></table></figure><p><code>pybind11</code>使用C++11的大括号初始化来隐式调用目标类的构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Aggregate</span> &#123;</span><br>    <span class="hljs-keyword">int</span> a;<br>    std::string b;<br>&#125;;<br><br>py::class_&lt;Aggregate&gt;(m, <span class="hljs-string">&quot;Aggregate&quot;</span>)<br>    .<span class="hljs-built_in">def</span>(py::init&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">const</span> std::string &amp;&gt;());<br></code></pre></td></tr></table></figure><h2 id="3-隐式转换"><a href="#3-隐式转换" class="headerlink" title="3 隐式转换"></a>3 隐式转换</h2><p>假设有A和B两个类，A可以直接转换为B。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">py::class_&lt;A&gt;(m, <span class="hljs-string">&quot;A&quot;</span>)<br>    <span class="hljs-comment">/// ... members ...</span><br><br>py::class_&lt;B&gt;(m, <span class="hljs-string">&quot;B&quot;</span>)<br>    .<span class="hljs-built_in">def</span>(py::init&lt;A&gt;())<br>    <span class="hljs-comment">/// ... members ...</span><br><br>m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;func&quot;</span>,<br>    [](<span class="hljs-keyword">const</span> B &amp;) &#123; <span class="hljs-comment">/* .... */</span> &#125;<br>);<br></code></pre></td></tr></table></figure><p>如果想func函数传入A类型的参数a，Pyhton侧需要这样写<code>func(B(a))</code>，而C++侧则可以直接使用<code>func(a)</code>，自动将A类型转换为B类型。</p><p>这种情形下（B有一个接受A类型参数的构造函数），我们可以使用如下声明来让Python侧也支持类似的隐式转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">py::implicitly_convertible&lt;A, B&gt;();<br></code></pre></td></tr></table></figure><h2 id="4-重载操作符"><a href="#4-重载操作符" class="headerlink" title="4 重载操作符"></a>4 重载操作符</h2><p>假设有这样一个类<code>Vector2</code>，它通过重载操作符实现了向量加法和标量乘法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vector2</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Vector2</span>(<span class="hljs-keyword">float</span> x, <span class="hljs-keyword">float</span> y) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123; &#125;<br><br>    Vector2 <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vector2 &amp;v) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector2</span>(x + v.x, y + v.y); &#125;<br>    Vector2 <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">float</span> value) <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector2</span>(x * value, y * value); &#125;<br>    Vector2&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">const</span> Vector2 &amp;v) &#123; x += v.x; y += v.y; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br>    Vector2&amp; <span class="hljs-keyword">operator</span>*=(<span class="hljs-keyword">float</span> v) &#123; x *= v; y *= v; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br><br>    <span class="hljs-keyword">friend</span> Vector2 <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">float</span> f, <span class="hljs-keyword">const</span> Vector2 &amp;v) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector2</span>(f * v.x, f * v.y);<br>    &#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">toString</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[&quot;</span> + std::<span class="hljs-built_in">to_string</span>(x) + <span class="hljs-string">&quot;, &quot;</span> + std::<span class="hljs-built_in">to_string</span>(y) + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">float</span> x, y;<br>&#125;;<br></code></pre></td></tr></table></figure><p>操作符绑定代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pybind11/operators.h&gt;</span></span><br><br><span class="hljs-built_in">PYBIND11_MODULE</span>(example, m) &#123;<br>    py::class_&lt;Vector2&gt;(m, <span class="hljs-string">&quot;Vector2&quot;</span>)<br>        .<span class="hljs-built_in">def</span>(py::init&lt;<span class="hljs-keyword">float</span>, <span class="hljs-keyword">float</span>&gt;())<br>        .<span class="hljs-built_in">def</span>(py::self + py::self)<br>        .<span class="hljs-built_in">def</span>(py::self += py::self)<br>        .<span class="hljs-built_in">def</span>(py::self *= <span class="hljs-built_in"><span class="hljs-keyword">float</span></span>())<br>        .<span class="hljs-built_in">def</span>(<span class="hljs-built_in"><span class="hljs-keyword">float</span></span>() * py::self)<br>        .<span class="hljs-built_in">def</span>(py::self * <span class="hljs-built_in"><span class="hljs-keyword">float</span></span>())<br>        <span class="hljs-comment">// 上面一行等同于：</span><br>        <span class="hljs-comment">/*.def(&quot;__mul__&quot;, [](const Vector2 &amp;a, float b) &#123;</span><br><span class="hljs-comment">    return a * b;</span><br><span class="hljs-comment">&#125;, py::is_operator())*/</span><br>        .<span class="hljs-built_in">def</span>(-py::self)<br>        .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;__repr__&quot;</span>, &amp;Vector2::toString);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>官方文档：<a href="https://pybind11.readthedocs.io/en/stable/index.html">pybind11 documentation</a></p><p>官方文档中文翻译：<a href="https://github.com/charlotteLive/pybind11-Chinese-docs">pybind11-Chinese-docs: pybind11中文文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pybind11学习 函数的绑定</title>
    <link href="/2022/12/23/pybind11%E5%AD%A6%E4%B9%A0%20%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/"/>
    <url>/2022/12/23/pybind11%E5%AD%A6%E4%B9%A0%20%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要记录官方文档中 <strong>FUNCTIONS</strong> 一章的学习笔记。</p><p>对于C++ 函数的Python绑定，在前面的学习中已经有所涉及了，详见：<a href="https://blog.csdn.net/qq_39784672/article/details/128399398">pybind11学习 | 迈出第一步</a>。本文主要是记录一些更加深入的知识。</p></blockquote><p>[TOC] </p><h2 id="1-返回值策略"><a href="#1-返回值策略" class="headerlink" title="1 返回值策略"></a>1 返回值策略</h2><p>Python和C++在内存管理和对象生命周期管理上存在本质的区别。为此，pybind11提供了一些返回值策略来<strong>确定由哪方管理资源</strong>。pybind11在绑定C++函数时，一个有7个返回值策略，都在<code>py::return_value_policy</code>（py为pybind11的别名）枚举类型中。这些策略通过<code>model_::def()</code>（模块函数）和<code>class_::def()</code>（类成员方法）来指定，默认策略为<code>return_value_policy::automatic</code>。</p><table><thead><tr><th>返回值策略</th><th>描述</th></tr></thead><tbody><tr><td><code>return_value_policy::take_ownership</code></td><td>引用现有对象（不创建一个新对象），并获取所有权。在引用计数为0时，Pyhton将调用析构函数和delete操作销毁对象。</td></tr><tr><td><code>return_value_policy::copy</code></td><td>拷贝返回值，这样Python将拥有拷贝的对象。该策略相对来说比较安全，因为两个实例的生命周期是分离的。</td></tr><tr><td><code>return_value_policy::move</code></td><td>使用<code>std::move</code>来移动返回值的内容到新实例，新实例的所有权在Python。该策略相对来说比较安全，因为两个实例的生命周期是分离的。</td></tr><tr><td><code>return_value_policy::reference</code></td><td>引用现有对象，但不拥有所有权。C++侧负责该对象的生命周期管理，并在对象不再被使用时负责析构它。注意：当Python侧还在使用引用的对象时，C++侧删除对象将导致未定义行为。</td></tr><tr><td><code>return_value_policy::reference_internal</code></td><td>返回值的生命周期与父对象的生命周期相绑定，即被调用函数或属性的<code>this</code>或<code>self</code>对象。这种策略与reference策略类似，但附加了<code>keep_alive&lt;0, 1&gt;</code>调用策略保证返回值还被Python引用时，其父对象就不会被垃圾回收掉。这是由<code>def_property</code>、<code>def_readwrite</code>创建的属性getter方法的默认返回值策略。</td></tr><tr><td><code>return_value_policy::automatic</code></td><td>当返回值是指针时，该策略使用<code>return_value_policy::take_ownership</code>。反之对左值和右值引用使用<code>return_value_policy::copy</code>。</td></tr><tr><td><code>return_value_policy::automatic_reference</code></td><td>和上面一样，但是当返回值是指针时，使用<code>return_value_policy::reference</code>策略。这是在C++代码手动调用Python函数和使用<code>pybind11/stl.h</code>中的casters时的默认转换策略。你可能不需要显式地使用该策略。</td></tr></tbody></table><blockquote><ul><li><font color=red>代码使用无效的返回值策略将导致未初始化内存或多次释放数据结构，这将导致难以调试的、不确定的问题和段错误。</font></li><li>如果函数返回值为智能指针，可以不必指定返回值策略。</li></ul></blockquote><h2 id="2-调用策略"><a href="#2-调用策略" class="headerlink" title="2 调用策略"></a>2 调用策略</h2><p>通过指定调用策略可以<strong>表明参数间的依赖关系</strong>，确保<strong>函数调用的稳定性</strong>。</p><h3 id="2-1-keep-alive"><a href="#2-1-keep-alive" class="headerlink" title="2.1 keep alive"></a>2.1 keep alive</h3><p><strong>当一个C++容器对象包含另一个C++对象</strong>时，我们需要使用该策略。<code>keep_alive&lt;Nurse, Patient&gt;</code>表明在索引<code>Nurse</code>被回收前，索引<code>Patient</code>应该被keep alive。0表示返回值，1及以上表示参数索引。1表示隐含的参数<code>this</code>指针，而常规参数索引从2开始。当<code>Nurse</code>的值在运行前被检测到为<code>None</code>时，调用策略将什么都不做。</p><p>通过该策略，我们可以实现将被包含对象的声明周期绑定到包含对象上，示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">py::class_&lt;List&gt;(m, <span class="hljs-string">&quot;List&quot;</span>).<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;append&quot;</span>, &amp;List::append, py::keep_alive&lt;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&gt;());<br><br>py::class_&lt;Nurse&gt;(m, <span class="hljs-string">&quot;Nurse&quot;</span>).<span class="hljs-built_in">def</span>(py::init&lt;Patient &amp;&gt;(), py::keep_alive&lt;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&gt;());<br></code></pre></td></tr></table></figure><h3 id="2-2-call-guard"><a href="#2-2-call-guard" class="headerlink" title="2.2 call guard"></a>2.2 call guard</h3><p><code>call_guard&lt;T&gt;</code>策略允许任意<code>T</code>类型的scope guard应用于整个函数调用。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;foo&quot;</span>, foo, py::call_guard&lt;T&gt;());<br></code></pre></td></tr></table></figure><p><code>call_guard</code>类模板源码声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** \rst</span><br><span class="hljs-comment">    A call policy which places one or more guard variables (``Ts...``) around the function call. </span><br><span class="hljs-comment"> \endrst */</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">call_guard</span>;</span><br><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">call_guard</span>&lt;</span>&gt; &#123;<br>    <span class="hljs-keyword">using</span> type = detail::void_type;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">call_guard</span>&lt;</span>T&gt; &#123;<br>    <span class="hljs-built_in"><span class="hljs-keyword">static_assert</span></span>(std::is_default_constructible&lt;T&gt;::value,<br>                  <span class="hljs-string">&quot;The guard type must be default constructible&quot;</span>);<br><br>    <span class="hljs-keyword">using</span> type = T;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Ts&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">call_guard</span>&lt;</span>T, Ts...&gt; &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type</span> &#123;</span><br>        T guard&#123;&#125;; <span class="hljs-comment">// Compose multiple guard types with left-to-right default-constructor order</span><br>        <span class="hljs-keyword">typename</span> call_guard&lt;Ts...&gt;::type next&#123;&#125;;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-默认参数"><a href="#3-默认参数" class="headerlink" title="3 默认参数"></a>3 默认参数</h2><p><strong>默认参数在声明时就已经被转换为Python对象了</strong>。如果默认参数为自定义类型，需要保证在<code>class_::def</code>中声明默认参数前，先将该自定义类型进行绑定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">py::class_&lt;SomeType&gt;(<span class="hljs-string">&quot;SomeType&quot;</span>)<br>    <span class="hljs-comment">//...</span><br><br>py::class_&lt;MyClass&gt;(<span class="hljs-string">&quot;MyClass&quot;</span>).<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;myFunction&quot;</span>, py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;arg&quot;</span>) = <span class="hljs-built_in">SomeType</span>(<span class="hljs-number">123</span>));<br></code></pre></td></tr></table></figure><p>使用<code>py::arg_v</code>给默认参数手动添加方便阅读的注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">py::class_&lt;MyClass&gt;(<span class="hljs-string">&quot;MyClass&quot;</span>)<br>    .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;myFunction&quot;</span>, py::<span class="hljs-built_in">arg_v</span>(<span class="hljs-string">&quot;arg&quot;</span>, <span class="hljs-built_in">SomeType</span>(<span class="hljs-number">123</span>), <span class="hljs-string">&quot;SomeType(123)&quot;</span>));<br></code></pre></td></tr></table></figure><p>使用空指针作为默认参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">py::class_&lt;MyClass&gt;(<span class="hljs-string">&quot;MyClass&quot;</span>)<br>    .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;myFunction&quot;</span>, py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;arg&quot;</span>) = <span class="hljs-keyword">static_cast</span>&lt;SomeType *&gt;(<span class="hljs-literal">nullptr</span>));<br></code></pre></td></tr></table></figure><h2 id="4-Keyword-only参数"><a href="#4-Keyword-only参数" class="headerlink" title="4 Keyword-only参数"></a>4 Keyword-only参数</h2><p>Python3引入Keyword-only参数语法。用法参见<a href="https://blog.csdn.net/qq_39784672/article/details/128289169">《Fluent Python》笔记 | 函数对象和装饰器</a>中<strong>仅限关键字参数</strong>部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, *, b</span>):</span>  <span class="hljs-comment"># a can be positional or via keyword; b must be via keyword</span><br>    <span class="hljs-keyword">pass</span><br><br>f(a=<span class="hljs-number">1</span>, b=<span class="hljs-number">2</span>)  <span class="hljs-comment"># good</span><br>f(b=<span class="hljs-number">2</span>, a=<span class="hljs-number">1</span>)  <span class="hljs-comment"># good</span><br>f(<span class="hljs-number">1</span>, b=<span class="hljs-number">2</span>)  <span class="hljs-comment"># good</span><br>f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># TypeError: f() takes 1 positional argument but 2 were given</span><br></code></pre></td></tr></table></figure><p>pybind11提供了<code>py::kw_only</code>对象来实现相同的功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;f&quot;</span>, [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) &#123; <span class="hljs-comment">/* ... */</span> &#125;,<br>      py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;a&quot;</span>), py::<span class="hljs-built_in">kw_only</span>(), py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;b&quot;</span>));<br></code></pre></td></tr></table></figure><blockquote><p>注，该特性不能与<code>py::args</code>一起使用。</p></blockquote><h2 id="5-Positional-only参数"><a href="#5-Positional-only参数" class="headerlink" title="5 Positional-only参数"></a>5 Positional-only参数</h2><p>python3.8引入了Positional-only参数语法。即只能按位置赋值，不能通过关键字赋值。</p><p>pybind11通过<code>py::pos_only()</code>来提供相同的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;f&quot;</span>, [](<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) &#123; <span class="hljs-comment">/* ... */</span> &#125;,<br>       py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;a&quot;</span>), py::<span class="hljs-built_in">pos_only</span>(), py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;b&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="6-Non-converting参数"><a href="#6-Non-converting参数" class="headerlink" title="6 Non-converting参数"></a>6 Non-converting参数</h2><p>当对Non-converting参数进行转换（包含隐式转换）时，代码会抛出错误。</p><p>Non-converting参数通过<code>py::arg</code>来调用<code>.noconvert()</code>方法指定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;floats_only&quot;</span>, [](<span class="hljs-keyword">double</span> f) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span> * f; &#125;, py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;f&quot;</span>).<span class="hljs-built_in">noconvert</span>());<br></code></pre></td></tr></table></figure><h2 id="7-允许-禁止None参数"><a href="#7-允许-禁止None参数" class="headerlink" title="7 允许/禁止None参数"></a>7 允许/禁止None参数</h2><p>使用<code>py::arg</code>对象的<code>.none(bool)</code>方法来显式地允许或禁止在Python中传入的该参数为<code>None</code>。在不显式指定的情况下，默认支持传递<code>None</code>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pybind11学习 面向对象编程</title>
    <link href="/2022/12/22/pybind11%E5%AD%A6%E4%B9%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/12/22/pybind11%E5%AD%A6%E4%B9%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><font color=gray>本文主要记录官方文档中 **OBJECT-ORIENTED CODE  **一章的学习笔记。</font></p><p>[TOC]</p><h2 id="1-自定义类的绑定"><a href="#1-自定义类的绑定" class="headerlink" title="1 自定义类的绑定"></a>1 自定义类的绑定</h2><p>在C++中自定义一个数据结构Pet，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pet</span> &#123;</span><br>    <span class="hljs-built_in">Pet</span>(<span class="hljs-keyword">const</span> std::string &amp;name) : <span class="hljs-built_in">name</span>(name) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;name_)</span> </span>&#123; name = name_; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> std::string &amp;<span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> name; &#125;<br><br>    std::string name;<br>&#125;;<br></code></pre></td></tr></table></figure><p>绑定代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pybind11/pybind11.h&gt;</span></span><br><span class="hljs-keyword">namespace</span> py = pybind11;<br><br><span class="hljs-built_in">PYBIND11_MODULE</span>(example, m) &#123;<br>    py::class_&lt;Pet&gt;(m, <span class="hljs-string">&quot;Pet&quot;</span>)<br>        .<span class="hljs-built_in">def</span>(py::init&lt;<span class="hljs-keyword">const</span> std::string &amp;&gt;())<br>        .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;setName&quot;</span>, &amp;Pet::setName)<br>        .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;getName&quot;</span>, &amp;Pet::getName);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>py::class_</code>用于创建C++ <strong>class</strong>或 <strong>struct</strong>的绑定（对应到Python中就是<strong>class</strong>）。<code>py::class_&lt;Pet&gt;(m, &quot;Pet&quot;)</code>实例化模板，尖括号中是需绑定的class或struct，第一个参数是模块变量，用于指定Python class所在的模块；第二个参数是Python class的名称。<code>py::class_::def</code>用于绑定类的成员函数。<code>py::init()</code>方法使用类构造函数的参数类型作为模板参数，并包装相应的构造函数。静态成员函数需要使用<code>py::class_::def_static</code>来绑定。</p><p>Python使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> example        <br><span class="hljs-meta">&gt;&gt;&gt; </span>example.Pet<br>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">example</span>.<span class="hljs-title">Pet</span>&#x27;&gt;</span><br><span class="hljs-class">&gt;&gt;&gt; <span class="hljs-title">cat</span>=<span class="hljs-title">example</span>.<span class="hljs-title">Pet</span>(<span class="hljs-params"><span class="hljs-string">&quot;eric&quot;</span></span>) </span><br><span class="hljs-class">&gt;&gt;&gt; <span class="hljs-title">cat</span></span><br><span class="hljs-class">&lt;<span class="hljs-title">example</span>.<span class="hljs-title">Pet</span> <span class="hljs-title">object</span> <span class="hljs-title">at</span> 0<span class="hljs-title">x0000023DB7E705F0</span>&gt;</span><br><span class="hljs-class">&gt;&gt;&gt; <span class="hljs-title">cat</span>.<span class="hljs-title">getName</span>() </span><br><span class="hljs-class">&#x27;<span class="hljs-title">eric</span>&#x27;</span><br><span class="hljs-class">&gt;&gt;&gt; <span class="hljs-title">cat</span>.<span class="hljs-title">setName</span>(<span class="hljs-params"><span class="hljs-string">&quot;bob&quot;</span></span>)</span><br><span class="hljs-class">&gt;&gt;&gt; <span class="hljs-title">cat</span>.<span class="hljs-title">getName</span>()</span><br><span class="hljs-class">&#x27;<span class="hljs-title">bob</span>&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="2-绑定匿名函数"><a href="#2-绑定匿名函数" class="headerlink" title="2 绑定匿名函数"></a>2 绑定匿名函数</h2><p>为了返回具有可读性的对象信息，我们绑定一个函数到<code>__repr__</code>方法，为了方便我们可以使用匿名函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">py::class_&lt;Pet&gt;(m, <span class="hljs-string">&quot;Pet&quot;</span>)<br>    .<span class="hljs-keyword">def</span>(py::init&lt;const std::string &amp;&gt;())<br>    .<span class="hljs-keyword">def</span>(<span class="hljs-string">&quot;setName&quot;</span>, &amp;Pet::setName)<br>    .<span class="hljs-keyword">def</span>(<span class="hljs-string">&quot;getName&quot;</span>, &amp;Pet::getName)<br>    .<span class="hljs-keyword">def</span>(<span class="hljs-string">&quot;__repr__&quot;</span>,<br>        [](const Pet &amp;a) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;example.Pet named &#x27;&quot;</span> + a.name + <span class="hljs-string">&quot;&#x27;&gt;&quot;</span>;<br>        &#125;);<br></code></pre></td></tr></table></figure><p>修改前：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(cat)<br>&lt;example.Pet <span class="hljs-built_in">object</span> at <span class="hljs-number">0x0000023DB7E705F0</span>&gt;<br></code></pre></td></tr></table></figure><p>修改后：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(cat)<br>&lt;example.Pet named <span class="hljs-string">&#x27;eric&#x27;</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="3-成员变量"><a href="#3-成员变量" class="headerlink" title="3 成员变量"></a>3 成员变量</h2><p>使用<code>class_::def_readwrite</code>方法可以导出公有成员变量，使用<code>class_::def_readonly</code>方法则可以导出只读成员变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">py::class_&lt;Pet&gt;(m, <span class="hljs-string">&quot;Pet&quot;</span>)<br>    .<span class="hljs-built_in">def</span>(py::init&lt;<span class="hljs-keyword">const</span> std::string &amp;&gt;())<br>    .<span class="hljs-built_in">def_readwrite</span>(<span class="hljs-string">&quot;name&quot;</span>, &amp;Pet::name)<br>    <span class="hljs-comment">// ... remainder ...</span><br></code></pre></td></tr></table></figure><p>Python中使用示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> example<br><span class="hljs-meta">&gt;&gt;&gt; </span>cat = example.Pet(<span class="hljs-string">&quot;eric&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>cat.name<br><span class="hljs-string">&#x27;eric&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>cat.name = <span class="hljs-string">&#x27;bob&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>cat.name<br><span class="hljs-string">&#x27;bob&#x27;</span><br></code></pre></td></tr></table></figure><p>假设<code>Pet::name</code>是一个私有成员变量，向外提供<code>setters</code>（修改变量值）和<code>getters</code>（获取变量值）方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Pet</span>(<span class="hljs-keyword">const</span> std::string &amp;name) : <span class="hljs-built_in">name</span>(name) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;name_)</span> </span>&#123; name = name_; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">const</span> std::string &amp;<span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> name; &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string name;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以使用<code>class_::def_property()</code>(只读成员使用<code>class_::def_property_readonly()</code>)来导出私有成员，并生成相应的<code>setter</code>和<code>getter</code>方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">py::class_&lt;Pet&gt;(m, <span class="hljs-string">&quot;Pet&quot;</span>)<br>    .<span class="hljs-built_in">def</span>(py::init&lt;<span class="hljs-keyword">const</span> std::string &amp;&gt;())<br>    .<span class="hljs-built_in">def_property</span>(<span class="hljs-string">&quot;name&quot;</span>, &amp;Pet::getName, &amp;Pet::setName)<br>    <span class="hljs-comment">// ... remainder ...</span><br></code></pre></td></tr></table></figure><p>Python测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> example<br><span class="hljs-meta">&gt;&gt;&gt; </span>example.Pet.name<br>&lt;<span class="hljs-built_in">property</span> <span class="hljs-built_in">object</span> at <span class="hljs-number">0x000001F7F7B097C0</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>cat = example.Pet(<span class="hljs-string">&quot;eric&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>cat.getName()<br><span class="hljs-string">&#x27;eric&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>cat.name<br><span class="hljs-string">&#x27;eric&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>cat.name = <span class="hljs-string">&#x27;bob&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>cat.name<br><span class="hljs-string">&#x27;bob&#x27;</span><br></code></pre></td></tr></table></figure><p>只写属性通过将read函数定义为nullptr来实现。</p><blockquote><p><code>class_::def_readwrite_static()</code>, <code>class_::def_readonly_static()</code> <code>class_::def_property_static()</code>, <code>class_::def_property_readonly_static()</code>用于绑定静态变量和属性。</p></blockquote><h2 id="4-动态属性"><a href="#4-动态属性" class="headerlink" title="4 动态属性"></a>4 动态属性</h2><p>我们知道，Python原生类可以动态获得新属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pet</span>:</span><br><span class="hljs-meta">... </span>   name = <span class="hljs-string">&quot;Molly&quot;</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>p = Pet()<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.name = <span class="hljs-string">&quot;Charly&quot;</span>  <span class="hljs-comment"># overwrite existing</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p.age = <span class="hljs-number">2</span>  <span class="hljs-comment"># dynamically add a new attribute</span><br></code></pre></td></tr></table></figure><p>默认情况下，从C++导出的类不支持动态属性，其可写属性必须是通过<code>class_::def_readwrite</code>或<code>class_::def_property</code>定义的。试图设置其他属性将产生错误。为了让C++导出的类也支持动态属性，我们需要在<code>py::class_</code>的构造函数中添加<code>py::dynamic_attr</code>标识：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">py::class_&lt;Pet&gt;(m, <span class="hljs-string">&quot;Pet&quot;</span>, py::<span class="hljs-built_in">dynamic_attr</span>())<br>    .<span class="hljs-built_in">def</span>(py::init&lt;<span class="hljs-keyword">const</span> std::string &amp;&gt;())<br>    .<span class="hljs-built_in">def_readwrite</span>(<span class="hljs-string">&quot;name&quot;</span>, &amp;Pet::name);<br><span class="hljs-comment">// ... remainder ...</span><br></code></pre></td></tr></table></figure><p>这样就可以在为导出的类添加动态属性了，Python中测试如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> example<br><span class="hljs-meta">&gt;&gt;&gt; </span>cat = example.Pet(<span class="hljs-string">&quot;eric&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>cat.name                  <br><span class="hljs-string">&#x27;eric&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>cat.age = <span class="hljs-number">12</span>              <br><span class="hljs-meta">&gt;&gt;&gt; </span>cat.age<br><span class="hljs-number">12</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>cat.__dict__<br>&#123;<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">12</span>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-继承与向下转型"><a href="#5-继承与向下转型" class="headerlink" title="5 继承与向下转型"></a>5 继承与向下转型</h2><p>现在有两个具有继承关系的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pet</span> &#123;</span><br>    <span class="hljs-built_in">Pet</span>(<span class="hljs-keyword">const</span> std::string &amp;name) : <span class="hljs-built_in">name</span>(name) &#123; &#125;<br>    std::string name;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dog</span> :</span> Pet &#123;<br>    <span class="hljs-built_in">Dog</span>(<span class="hljs-keyword">const</span> std::string &amp;name) : <span class="hljs-built_in">Pet</span>(name) &#123; &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">bark</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;woof!&quot;</span>; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>pybind11提供了两种方法来指明继承关系：1）将C++基类作为派生类<code>class_</code>的模板参数；2）将基类名作为<code>class_</code>的参数绑定到派生类。两种方法是等效的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">py::class_&lt;Pet&gt;(m, <span class="hljs-string">&quot;Pet&quot;</span>)<br>   .<span class="hljs-built_in">def</span>(py::init&lt;<span class="hljs-keyword">const</span> std::string &amp;&gt;())<br>   .<span class="hljs-built_in">def_readwrite</span>(<span class="hljs-string">&quot;name&quot;</span>, &amp;Pet::name);<br><br><span class="hljs-comment">// Method 1: template parameter:</span><br>py::class_&lt;Dog, Pet <span class="hljs-comment">/* &lt;- specify C++ parent type */</span>&gt;(m, <span class="hljs-string">&quot;Dog&quot;</span>)<br>    .<span class="hljs-built_in">def</span>(py::init&lt;<span class="hljs-keyword">const</span> std::string &amp;&gt;())<br>    .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;bark&quot;</span>, &amp;Dog::bark);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">py::class_&lt;Pet&gt; <span class="hljs-title">pet</span><span class="hljs-params">(m, <span class="hljs-string">&quot;Pet&quot;</span>)</span></span>;<br>pet.<span class="hljs-built_in">def</span>(py::init&lt;<span class="hljs-keyword">const</span> std::string &amp;&gt;())<br>   .<span class="hljs-built_in">def_readwrite</span>(<span class="hljs-string">&quot;name&quot;</span>, &amp;Pet::name);<br><br><span class="hljs-comment">// Method 2: pass parent class_ object:</span><br>py::class_&lt;Dog&gt;(m, <span class="hljs-string">&quot;Dog&quot;</span>, pet <span class="hljs-comment">/* &lt;- specify Python parent type */</span>)<br>    .<span class="hljs-built_in">def</span>(py::init&lt;<span class="hljs-keyword">const</span> std::string &amp;&gt;())<br>    .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;bark&quot;</span>, &amp;Dog::bark);<br></code></pre></td></tr></table></figure><p>指明继承关系后，派生类实例将获得两者的属性和方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = example.Dog(<span class="hljs-string">&quot;Molly&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.name<br><span class="hljs-string">&#x27;Molly&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p.bark()<br><span class="hljs-string">&#x27;woof!&#x27;</span><br></code></pre></td></tr></table></figure><p>上面的例子是一个常规非多态的继承关系，表现在Python就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回一个指向派生类的基类指针</span><br>m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;pet_store&quot;</span>, []() &#123; <span class="hljs-keyword">return</span> std::unique_ptr&lt;Pet&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>(<span class="hljs-string">&quot;Molly&quot;</span>)); &#125;);<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = example.pet_store()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(p)  <span class="hljs-comment"># `Dog` instance behind `Pet` pointer</span><br>Pet          <span class="hljs-comment"># no pointer downcasting for regular non-polymorphic types</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p.bark()<br>AttributeError: <span class="hljs-string">&#x27;Pet&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;bark&#x27;</span><br></code></pre></td></tr></table></figure><p><code>pet_store</code>函数返回了一个Dog实例，但由于基类并非多态类型，Python只识别到了Pet。在C++中，一个类至少有一个<strong>虚函数</strong>才会被视为<strong>多态类型</strong>。<strong>pybind11会自动识别这种多态机制</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PolymorphicPet</span> &#123;</span><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">PolymorphicPet</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PolymorphicDog</span> :</span> PolymorphicPet &#123;<br>    <span class="hljs-function">std::string <span class="hljs-title">bark</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;woof!&quot;</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// Same binding code</span><br>py::class_&lt;PolymorphicPet&gt;(m, <span class="hljs-string">&quot;PolymorphicPet&quot;</span>);<br>py::class_&lt;PolymorphicDog, PolymorphicPet&gt;(m, <span class="hljs-string">&quot;PolymorphicDog&quot;</span>)<br>    .<span class="hljs-built_in">def</span>(py::init&lt;&gt;())<br>    .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;bark&quot;</span>, &amp;PolymorphicDog::bark);<br><br><span class="hljs-comment">// Again, return a base pointer to a derived instance</span><br>m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;pet_store2&quot;</span>, []() &#123; <span class="hljs-keyword">return</span> std::unique_ptr&lt;PolymorphicPet&gt;(<span class="hljs-keyword">new</span> PolymorphicDog); &#125;);<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = example.pet_store2()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(p)<br>PolymorphicDog  <span class="hljs-comment"># automatically downcast</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>p.bark()<br><span class="hljs-string">u&#x27;woof!&#x27;</span><br></code></pre></td></tr></table></figure><p>pybind11会自动地将一个指向多态基类的指针，<strong>向下转型</strong>为实际的派生类类型。这和C++常见的情况不同，我们不仅可以访问基类的虚函数，还能访问派生类的方法和属性。</p><h2 id="6-重载方法"><a href="#6-重载方法" class="headerlink" title="6 重载方法"></a>6 重载方法</h2><p>重载方法即拥有相同的函数名，但传入参数不一样的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pet</span> &#123;</span><br>    <span class="hljs-built_in">Pet</span>(<span class="hljs-keyword">const</span> std::string &amp;name, <span class="hljs-keyword">int</span> age) : <span class="hljs-built_in">name</span>(name), <span class="hljs-built_in">age</span>(age) &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age_)</span> </span>&#123; age = age_; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">const</span> std::string &amp;name_)</span> </span>&#123; name = name_; &#125;<br><br>    std::string name;<br>    <span class="hljs-keyword">int</span> age;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们在绑定<code>Pet::set</code>时会报错，因为编译器并不知道用户想选择哪个重载方法。我们需要<strong>添加具体的函数指针</strong>来消除歧义。绑定多个函数到同一个Python名称，将会自动创建函数重载链。Python将会依次匹配，找到最合适的重载函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">py::class_&lt;Pet&gt;(m, <span class="hljs-string">&quot;Pet&quot;</span>)<br>   .<span class="hljs-built_in">def</span>(py::init&lt;<span class="hljs-keyword">const</span> std::string &amp;, <span class="hljs-keyword">int</span>&gt;())<br>   .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;set&quot;</span>, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (Pet::*)(<span class="hljs-keyword">int</span>)&gt;(&amp;Pet::set), <span class="hljs-string">&quot;Set the pet&#x27;s age&quot;</span>)<br>   .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;set&quot;</span>, <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in"><span class="hljs-keyword">void</span></span> (Pet::*)(<span class="hljs-keyword">const</span> std::string &amp;)&gt;(&amp;Pet::set), <span class="hljs-string">&quot;Set the pet&#x27;s name&quot;</span>);<br></code></pre></td></tr></table></figure><p>如果编译器支持C++14，也可以使用下面的语法来转换重载函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">py::class_&lt;Pet&gt;(m, <span class="hljs-string">&quot;Pet&quot;</span>)<br>    .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;set&quot;</span>, py::overload_cast&lt;<span class="hljs-keyword">int</span>&gt;(&amp;Pet::set), <span class="hljs-string">&quot;Set the pet&#x27;s age&quot;</span>)<br>    .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;set&quot;</span>, py::overload_cast&lt;<span class="hljs-keyword">const</span> std::string &amp;&gt;(&amp;Pet::set), <span class="hljs-string">&quot;Set the pet&#x27;s name&quot;</span>);<br></code></pre></td></tr></table></figure><p>这里，<code>py::overload_cast</code>仅需指定函数类型，不用给出返回值类型，以避免原语法带来的不必要的干扰(<code>void (Pet::*)</code>)。如果是基于const的重载，需要使用<code>py::const_</code>标识。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Widget</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">float</span> y)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">float</span> y)</span> <span class="hljs-keyword">const</span></span>;<br>&#125;;<br><br>py::class_&lt;Widget&gt;(m, <span class="hljs-string">&quot;Widget&quot;</span>)<br>   .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;foo_mutable&quot;</span>, py::overload_cast&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>&gt;(&amp;Widget::foo))<br>   .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;foo_const&quot;</span>,   py::overload_cast&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>&gt;(&amp;Widget::foo, py::const_));<br></code></pre></td></tr></table></figure><p>如果想在仅支持C++11的编译器上使用<code>py::overload_cast</code>语法，可以使用<code>py::detail::overload_cast_impl</code>来代替：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-keyword">using</span> overload_cast_ = pybind11::detail::overload_cast_impl&lt;Args...&gt;;<br><br>py::class_&lt;Pet&gt;(m, <span class="hljs-string">&quot;Pet&quot;</span>)<br>    .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;set&quot;</span>, overload_cast_&lt;<span class="hljs-keyword">int</span>&gt;()(&amp;Pet::set), <span class="hljs-string">&quot;Set the pet&#x27;s age&quot;</span>)<br>    .<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;set&quot;</span>, overload_cast_&lt;<span class="hljs-keyword">const</span> std::string &amp;&gt;()(&amp;Pet::set), <span class="hljs-string">&quot;Set the pet&#x27;s name&quot;</span>);<br></code></pre></td></tr></table></figure><blockquote><p>Note: 如果想定义多个重载的构造函数，使用<code>.def(py::init&lt;...&gt;())</code>语法依次定义就好，指定关键字和默认参数的机制也还是生效的。</p></blockquote><h2 id="7-枚举类型"><a href="#7-枚举类型" class="headerlink" title="7 枚举类型"></a>7 枚举类型</h2><p>现在有一个含有枚举和内部类型的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pet</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Kind</span> &#123;</span><br>        Dog = <span class="hljs-number">0</span>,<br>        Cat<br>    &#125;;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Attributes</span> &#123;</span><br>        <span class="hljs-keyword">float</span> age = <span class="hljs-number">0</span>;<br>    &#125;;<br><br>    <span class="hljs-built_in">Pet</span>(<span class="hljs-keyword">const</span> std::string &amp;name, Kind type) : <span class="hljs-built_in">name</span>(name), <span class="hljs-built_in">type</span>(type) &#123; &#125;<br><br>    std::string name;<br>    Kind type;<br>    Attributes attr;<br>&#125;;<br></code></pre></td></tr></table></figure><p>绑定代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">py::class_&lt;Pet&gt; <span class="hljs-title">pet</span><span class="hljs-params">(m, <span class="hljs-string">&quot;Pet&quot;</span>)</span></span>;<br><br>pet.<span class="hljs-built_in">def</span>(py::init&lt;<span class="hljs-keyword">const</span> std::string &amp;, Pet::Kind&gt;())<br>    .<span class="hljs-built_in">def_readwrite</span>(<span class="hljs-string">&quot;name&quot;</span>, &amp;Pet::name)<br>    .<span class="hljs-built_in">def_readwrite</span>(<span class="hljs-string">&quot;type&quot;</span>, &amp;Pet::type)<br>    .<span class="hljs-built_in">def_readwrite</span>(<span class="hljs-string">&quot;attr&quot;</span>, &amp;Pet::attr);<br><br>py::enum_&lt;Pet::Kind&gt;(pet, <span class="hljs-string">&quot;Kind&quot;</span>)<br>    .<span class="hljs-built_in">value</span>(<span class="hljs-string">&quot;Dog&quot;</span>, Pet::Kind::Dog)<br>    .<span class="hljs-built_in">value</span>(<span class="hljs-string">&quot;Cat&quot;</span>, Pet::Kind::Cat)<br>    .<span class="hljs-built_in">export_values</span>();<br><br>py::class_&lt;Pet::Attributes&gt;(pet, <span class="hljs-string">&quot;Attributes&quot;</span>)<br>    .<span class="hljs-built_in">def</span>(py::init&lt;&gt;())<br>    .<span class="hljs-built_in">def_readwrite</span>(<span class="hljs-string">&quot;age&quot;</span>, &amp;Pet::Attributes::age);<br></code></pre></td></tr></table></figure><p>为确保嵌套类型<code>Kind</code>和<code>Attributes</code>在<code>Pet</code>的作用域中创建，我们必须向<code>enum_</code>和<code>class_</code>的构造函数提供<code>class_</code>实例<code>pet</code> 。<code>enum_::export_values()</code>用来导出枚举项到父作用域，C++11的强枚举类型需要跳过这点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = Pet(<span class="hljs-string">&quot;Lucy&quot;</span>, Pet.Cat)<br><span class="hljs-meta">&gt;&gt;&gt; </span>p.<span class="hljs-built_in">type</span><br>Kind.Cat<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">int</span>(p.<span class="hljs-built_in">type</span>)<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>枚举类型的枚举项会被导出到类的<code>__members__</code>属性中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>Pet.Kind.__members__<br>&#123;<span class="hljs-string">&#x27;Dog&#x27;</span>: Kind.Dog, <span class="hljs-string">&#x27;Cat&#x27;</span>: Kind.Cat&#125;<br></code></pre></td></tr></table></figure><p><code>name</code>属性可以返回枚举值的名称的unicode字符串，<code>str(enum)</code>也可以做到，但两者的实现目标不同。下面的例子展示了两者的差异：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = Pet(<span class="hljs-string">&quot;Lucy&quot;</span>, Pet.Cat)<br><span class="hljs-meta">&gt;&gt;&gt; </span>pet_type = p.<span class="hljs-built_in">type</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pet_type<br>Pet.Cat<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">str</span>(pet_type)<br><span class="hljs-string">&#x27;Pet.Cat&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pet_type.name<br><span class="hljs-string">&#x27;Cat&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>Note: 当我们给<code>enum_</code>的构造函数增加<code>py::arithmetic()</code>标识时，pybind11将创建一个支持基本算术运算和位运算（如比较、或、异或、取反等）的枚举类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">py::enum_&lt;Pet::Kind&gt;(pet, <span class="hljs-string">&quot;Kind&quot;</span>, py::<span class="hljs-built_in">arithmetic</span>())<br>...<br></code></pre></td></tr></table></figure><p>默认情况下，省略这些可以节省内存空间。</p></blockquote><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h2><ul><li>默认情况下，pybind11导出的类比原生Python类效率更高。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 官方文档：<a href="https://pybind11.readthedocs.io/en/stable/index.html">pybind11 documentation</a></p><p>[2] 官方文档中文翻译：<a href="https://github.com/charlotteLive/pybind11-Chinese-docs">pybind11-Chinese-docs: pybind11中文文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pybind11学习 迈出第一步</title>
    <link href="/2022/12/21/pybind11%E5%AD%A6%E4%B9%A0%20%E8%BF%88%E5%87%BA%E7%AC%AC%E4%B8%80%E6%AD%A5/"/>
    <url>/2022/12/21/pybind11%E5%AD%A6%E4%B9%A0%20%E8%BF%88%E5%87%BA%E7%AC%AC%E4%B8%80%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p><font color=gray>本文主要记录官方文档中<strong>FIRST STEPS</strong>一章的学习笔记。</font></p><p>[TOC]</p><h2 id="1-简单函数的绑定"><a href="#1-简单函数的绑定" class="headerlink" title="1 简单函数的绑定"></a>1 简单函数的绑定</h2><p>先从一个简单的示例开始：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pybind11/pybind11.h&gt;</span></span><br><span class="hljs-keyword">namespace</span> py = pybind11;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> i + j;<br>&#125;<br><br><span class="hljs-built_in">PYBIND11_MODULE</span>(example, m) &#123;<br>    m.<span class="hljs-built_in">doc</span>() = <span class="hljs-string">&quot;pybind11 example plugin&quot;</span>; <span class="hljs-comment">// optional module docstring</span><br>    m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;add&quot;</span>, &amp;add, <span class="hljs-string">&quot;A function which adds two numbers&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段C++代码中，我们定义了一个简单的加法函数<code>add</code>，并创建其的Python绑定。下面我们详细讲解一下创建绑定部分的代码。</p><p><code>PYBIND11_MODULE</code>可以看作一个函数，作用是创建一个Python<strong>模块</strong>（可以在Python中<code>import</code>）。<code>PYBIND11_MODULE</code>有两个参数，第一个是<strong>模块名称</strong>（example）；第二个是类型为<code>py::module_</code>的变量（m），它是创建绑定的主要接口。<code>module_::doc()</code>方法（可选），用于生成模块的<strong>描述文档</strong>。<code>module_::def()</code>方法，用于生成C++函数的Python绑定。<code>module_::def()</code>方法源码定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/** \rst</span><br><span class="hljs-comment">     Create Python binding for a new function within the module scope. ``Func``</span><br><span class="hljs-comment">     can be a plain C++ function, a function pointer, or a lambda function. For</span><br><span class="hljs-comment">     details on the ``Extra&amp;&amp; ... extra`` argument, see section :ref:`extras`.</span><br><span class="hljs-comment"> \endrst */</span><br> <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Func, <span class="hljs-keyword">typename</span>... Extra&gt;<br> <span class="hljs-function">module_ &amp;<span class="hljs-title">def</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name_, Func &amp;&amp;f, <span class="hljs-keyword">const</span> Extra &amp;...extra)</span> </span>&#123;<br>     <span class="hljs-function">cpp_function <span class="hljs-title">func</span><span class="hljs-params">(std::forward&lt;Func&gt;(f),</span></span><br><span class="hljs-params"><span class="hljs-function">                       name(name_),</span></span><br><span class="hljs-params"><span class="hljs-function">                       scope(*<span class="hljs-keyword">this</span>),</span></span><br><span class="hljs-params"><span class="hljs-function">                       sibling(getattr(*<span class="hljs-keyword">this</span>, name_, none())),</span></span><br><span class="hljs-params"><span class="hljs-function">                       extra...)</span></span>;<br>     <span class="hljs-comment">// NB: allow overwriting here because cpp_function sets up a chain with the intention of</span><br>     <span class="hljs-comment">// overwriting (and has already checked internally that it isn&#x27;t overwriting</span><br>     <span class="hljs-comment">// non-functions).</span><br>     <span class="hljs-built_in">add_object</span>(name_, func, <span class="hljs-literal">true</span> <span class="hljs-comment">/* overwrite */</span>);<br>     <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>参数如下：</p><ul><li>**name_**：绑定后函数在模块中的名称。</li><li><strong>f</strong>：被绑定的C++函数。</li><li><strong>extra</strong>：可变参类型，额外参数。（示例中是字符串，用于生成绑定函数的<strong>描述文档</strong>。）</li></ul><p>为了验证上面的解释，我们将在VS中编译生成的pyd文件import到Python，执行如下控制台交互操作：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmd">Python <span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">11</span> (default, Aug  <span class="hljs-number">6</span> <span class="hljs-number">2021</span>, <span class="hljs-number">09</span>:<span class="hljs-number">57</span>:<span class="hljs-number">55</span>) [MSC v.<span class="hljs-number">1916</span> <span class="hljs-number">64</span> bit (AMD64)] on win32<br>import example<br>example.__doc__<br>Out[<span class="hljs-number">3</span>]: &#x27;pybind11 example plugin&#x27;<br>example.add.__doc__<br>Out[<span class="hljs-number">4</span>]: &#x27;add(arg0: int, arg1: int) -&gt; int\n\nA function which adds two numbers\n&#x27;<br>example.add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>Out[<span class="hljs-number">5</span>]: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="2-关键字参数"><a href="#2-关键字参数" class="headerlink" title="2 关键字参数"></a>2 关键字参数</h2><p>在上面示例的基础上进行如下修改，我们就可以实现指定关键字参数（即参数的名称）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;add&quot;</span>, &amp;add, <span class="hljs-string">&quot;A function which adds two numbers&quot;</span>,<br>      py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;i&quot;</span>), py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;j&quot;</span>));<br></code></pre></td></tr></table></figure><p>是可用于将元数据传递到<code>module_::def()</code>的几个特殊标记类之一。使用上面修改后的代码，我们可以在调用函数时使用关键字参数，以增加代码可读性，特别是对那些带有多个参数的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> example<br>example.add(i=<span class="hljs-number">1</span>, j=<span class="hljs-number">2</span>)  <span class="hljs-comment">#3</span><br></code></pre></td></tr></table></figure><p>修改前，我们在Python解释器中<code>help(example.add)</code>，函数签名如下：</p><p><code>add(arg0: int, arg1: int) -&gt; int</code></p><p>修改后，函数签名如下：</p><p><code>add(i: int, j: int) -&gt; int</code></p><p>还可以使用更加简洁的方式给参数命名：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// regular notation</span><br>m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;add1&quot;</span>, &amp;add, py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;i&quot;</span>), py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;j&quot;</span>));<br><span class="hljs-comment">// shorthand</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> pybind11::literals;<br>m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;add2&quot;</span>, &amp;add, <span class="hljs-string">&quot;i&quot;</span>_a, <span class="hljs-string">&quot;j&quot;</span>_a);<br></code></pre></td></tr></table></figure><p>后缀<code>_a</code>会生成一个等价于<code>py::arg</code>类的字面量。</p><h2 id="3-默认参数"><a href="#3-默认参数" class="headerlink" title="3 默认参数"></a>3 默认参数</h2><p>若需要绑定如下带有默认参数的C++函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, <span class="hljs-keyword">int</span> j = <span class="hljs-number">2</span>)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> i + j;<br>&#125;<br></code></pre></td></tr></table></figure><p>pybind11不能自动地提取默认参数，因为它不属于函数类型信息的一部分。我们需要借助<code>py::arg</code>来实现这一功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;add&quot;</span>, &amp;add, <span class="hljs-string">&quot;A function which adds two numbers&quot;</span>,<br>      py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;i&quot;</span>) = <span class="hljs-number">1</span>, py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;j&quot;</span>) = <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>查看函数签名：<code>add(i: int = 1, j: int = 2) -&gt; int</code>。</p><p>简化写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// regular notation</span><br>m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;add1&quot;</span>, &amp;add, py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;i&quot;</span>) = <span class="hljs-number">1</span>, py::<span class="hljs-built_in">arg</span>(<span class="hljs-string">&quot;j&quot;</span>) = <span class="hljs-number">2</span>);<br><span class="hljs-comment">// shorthand</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> pybind11::literals;<br>m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;add2&quot;</span>, &amp;add, <span class="hljs-string">&quot;i&quot;</span>_a=<span class="hljs-number">1</span>, <span class="hljs-string">&quot;j&quot;</span>_a=<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h2 id="4-变量的绑定"><a href="#4-变量的绑定" class="headerlink" title="4 变量的绑定"></a>4 变量的绑定</h2><p>我们可以使用<code>module_::attr()</code>方法来注册需要导出到Python模块中的C++变量。<strong>内建类型</strong>和<strong>常规对象</strong>（在<strong>类型转换</strong>一章会讲到）会在指定<code>attriutes</code>时自动转换，也可以使用<code>py::cast</code>来显式转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">PYBIND11_MODULE</span>(example, m) &#123;<br>    m.<span class="hljs-built_in">attr</span>(<span class="hljs-string">&quot;the_answer&quot;</span>) = <span class="hljs-number">42</span>;<span class="hljs-comment">// 注册一个名为the_answer值为42的变量，自动转换为int</span><br>    py::object world = py::<span class="hljs-built_in">cast</span>(<span class="hljs-string">&quot;World&quot;</span>);<span class="hljs-comment">//显示转换成Python对象str</span><br>    m.<span class="hljs-built_in">attr</span>(<span class="hljs-string">&quot;what&quot;</span>) = world;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Python中使用变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> example<br>example.the_answer<br>Out[<span class="hljs-number">3</span>]: <span class="hljs-number">42</span><br><span class="hljs-built_in">type</span>(example.the_answer)<br>Out[<span class="hljs-number">4</span>]: <span class="hljs-built_in">int</span><br>example.what<br>Out[<span class="hljs-number">5</span>]: <span class="hljs-string">&#x27;World&#x27;</span><br><span class="hljs-built_in">type</span>(example.what)<br>Out[<span class="hljs-number">6</span>]: <span class="hljs-built_in">str</span><br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><ul><li><p>pybind11的局限性</p><p>我们在编译链接用pybind11创建Python绑定的C++源码时，会指定链接器中python解释器的动态库（如python38.lib）。这样生成的二进制文件（如.pyd模块文件）只能导入到解释器同样为python3.8的代码中，否则会报错<code>ImportError: Module use of python38.dll conflicts with this version of Python.</code>。</p></li><li><p>数据类型转换</p><p>在上面示例中，我们绑定的函数中参数类型都比较常规（比如int），这种参数类型在Python和C++中能够很好的识别和传递，都会自动转换。函数参数值是通常是直接返回或经过<code>py::cast</code>显式转换后再返回。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>官方文档：<a href="https://pybind11.readthedocs.io/en/stable/index.html">pybind11 documentation</a></p><p>官方文档中文翻译：<a href="https://github.com/charlotteLive/pybind11-Chinese-docs">pybind11-Chinese-docs: pybind11中文文档</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pybind11 VS2022下安装配置</title>
    <link href="/2022/12/20/pybind11%20VS2022%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/12/20/pybind11%20VS2022%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><font color=gray>pybind11是一个只有头文件（header-only）的轻量级库，其主要目的是建立C++的Python代码绑定，实现C++和Python无缝连接。我学习这个工具的目的，是为了能够在Python中调用C++代码实现一些计算密集型任务，同时培养自己的混合编程的能力。</font></p><h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1 环境"></a>1 环境</h2><ul><li>Windows11</li><li>VS2022</li><li>pybind11</li><li>Anaconda3 , with python 3.8</li></ul><h2 id="2-源码下载"><a href="#2-源码下载" class="headerlink" title="2 源码下载"></a>2 源码下载</h2><p>首先去GitHub上将项目源码（<a href="https://github.com/pybind/pybind11%EF%BC%89%E5%85%8B%E9%9A%86%E4%B8%8B%E6%9D%A5%E3%80%82">https://github.com/pybind/pybind11）克隆下来。</a></p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221220184245875.png" alt="image-20221220184245875"></p><p>Git命令行：<code>git clone https://github.com/pybind/pybind11.git</code></p><p><strong>pybind11 是 header-only 的，不需要编译动态链接库，直接使用即可。</strong></p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221220185034352.png" alt="image-20221220185034352"></p><h2 id="3-VS配置"><a href="#3-VS配置" class="headerlink" title="3 VS配置"></a>3 VS配置</h2><ul><li><p>在VS2022中新建一个C++工程。</p></li><li><p>设置<strong>编译输出类型</strong></p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221220194013324.png" alt="image-20221220194013324"></p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221220194154088.png" alt="image-20221220194154088"></p></li><li><p>设置<strong>include包含路径</strong></p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221220195947640.png" alt="image-20221220195947640"></p></li><li><p>设置<strong>lib路径</strong></p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221220200645313.png" alt="image-20221220200645313"></p></li><li><p>设置<strong>链接器</strong></p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221220201504915.png" alt="image-20221220201504915"></p><blockquote><p>这里的lib文件名取决于Anaconda3中的python版本。</p></blockquote></li></ul><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h2><p>在VS中新建源文件<code>pybind11_test.cpp</code>，编译下面的测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;pybind11/pybind11.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> py = pybind11;<br><br><span class="hljs-built_in">PYBIND11_MODULE</span>(example, m) &#123;<br><br>    m.<span class="hljs-built_in">doc</span>() = <span class="hljs-string">&quot;pybind11 example module&quot;</span>;<br><br>    <span class="hljs-comment">// Add bindings here</span><br>    m.<span class="hljs-built_in">def</span>(<span class="hljs-string">&quot;foo&quot;</span>, []() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>    &#125;);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>生成解决方案，得到**.lib<strong>文件和</strong>.pyd**文件。</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221220202048291.png" alt="image-20221220202048291"></p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221220202320170.png" alt="image-20221220202320170"></p><p>有了上面两个文件，我们就能实现在Python中调用C++代码的目的了。</p><p>我们将这两个文件重命名为example后复制到python工程的根目录，然后新建一个.py文件执行下面代码进行测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> example<br><span class="hljs-built_in">print</span>(example.foo())<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221220203709301.png" alt="image-20221220203709301"></p><p>至此，pybind11的安装和配置完成，测试成功！</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p><font color=gray>后面开展对pybind11官方文档的学习，希望自己坚持一学一记！</font></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>官方文档：<a href="https://pybind11.readthedocs.io/en/stable/index.html">pybind11 documentation</a></p><p>官方文档中文翻译：<a href="https://github.com/charlotteLive/pybind11-Chinese-docs">pybind11-Chinese-docs: pybind11中文文档</a></p><p><a href="https://www.jianshu.com/p/9619f8f02891">pybind11使用 - 简书 (jianshu.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【pyclipper+增材CAM】轮廓偏置</title>
    <link href="/2022/12/19/%E3%80%90pyclipper+%E5%A2%9E%E6%9D%90CAM%E3%80%91%E8%BD%AE%E5%BB%93%E5%81%8F%E7%BD%AE/"/>
    <url>/2022/12/19/%E3%80%90pyclipper+%E5%A2%9E%E6%9D%90CAM%E3%80%91%E8%BD%AE%E5%BB%93%E5%81%8F%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><font color=gray>在增材打印CAM中，我们需要在切片得到的每层轮廓中规划生成打印路径。传统的三轴3D打印的常见填充方式有：<strong>轮廓平行填充</strong>和<strong>方向平行填充</strong>。其中轮廓平行填充主要是通过<strong>轮廓偏置</strong>实现的。</font></p><h2 id="pyclipper安装使用"><a href="#pyclipper安装使用" class="headerlink" title="pyclipper安装使用"></a>pyclipper安装使用</h2><p>Python下安装pyclipper库，命令行输入pip指令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install pyclipper<br></code></pre></td></tr></table></figure><blockquote><p>通过 <code>import pyclipper</code> 导入使用。</p></blockquote><h2 id="pyclipper基础"><a href="#pyclipper基础" class="headerlink" title="pyclipper基础"></a>pyclipper基础</h2><p>pyclipper是Python环境下的Clipper库，主要用于平面闭合多边形或非闭合多线段的<strong>裁剪</strong>（clipping）和<strong>偏置</strong>（offsetting）。</p><p><font color=gray size=4><b>重要术语：</b></font></p><ul><li><p><strong>裁剪(Clipping):</strong> 指二维平面图形之间的四个布尔操作：交集(intersection)、并(union)、差(difference )和异或(exclusive-or))中的任何一个。 </p></li><li><p><strong>路径(Path):</strong>  是一个有序的顶点集合，它定义一个单一的几何轮廓(contour)，要么是一条线(一个开放的路径)，要么是一个多边形(一个闭合的轮廓)。 </p></li><li><p><strong>直线(Line):</strong> 或者多线段(polyline)  是一个包含两个或多个顶点的开放路径。 </p></li><li><p><strong>多边形(Polygon):</strong> 通常是指一个二维的区域，其边界是一个外部不相交的闭合轮廓。</p></li><li><p><strong>轮廓(Contour):</strong> 同路径(path)。</p></li><li><p><strong>孔(Hole):</strong> 是一个多边形中不属于多边形的封闭区域。一个“孔多边形”是一个封闭的路径。</p></li><li><p><strong>多边形填充规则(Polygon Filling Rule):</strong>  填充规则，定义了平面封闭区域中的内部区域(即需要填充的区域)和外部的区域(即“孔”，不需要填充的区域)。</p></li></ul><p>需要掌握的Clipper基础：</p><ul><li><a href="https://blog.csdn.net/qq_39784672/article/details/128353064">Clipper库 | 坐标圆整和精度控制</a></li><li><a href="https://blog.csdn.net/qq_39784672/article/details/128360554">Clipper库 | 类型和填充规则</a></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> vtk<br><span class="hljs-keyword">from</span> pyclipper <span class="hljs-keyword">import</span> *<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numeric_scaling</span>(<span class="hljs-params">digits: <span class="hljs-string">&#x27;int &gt; 0&#x27;</span> = <span class="hljs-number">7</span>, *, pos: <span class="hljs-built_in">list</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span>(<span class="hljs-params">func</span>):</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scaled</span>(<span class="hljs-params">*_args</span>):</span><br>            __args = <span class="hljs-built_in">list</span>(_args)<br>            f = math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, digits)  <span class="hljs-comment"># 数值精度,默认为7位小数</span><br>            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pos:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(_args[p], <span class="hljs-built_in">int</span>) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(_args[p], <span class="hljs-built_in">float</span>):<br>                    __args[p] *= f<br>                <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(_args[p], <span class="hljs-built_in">list</span>):<br>                    __args[p] = [[<span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x * f, pt)) <span class="hljs-keyword">for</span> pt <span class="hljs-keyword">in</span> path] <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> _args[p]]<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">pass</span><br>            _result = func(*<span class="hljs-built_in">tuple</span>(__args))  <span class="hljs-comment"># _result is list of paths</span><br>            _result = [[<span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x / f, pt)) <span class="hljs-keyword">for</span> pt <span class="hljs-keyword">in</span> path] <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> _result]<br>            <span class="hljs-keyword">return</span> _result<br><br>        <span class="hljs-keyword">return</span> scaled<br><br>    <span class="hljs-keyword">return</span> decorate<br><br><br><span class="hljs-meta">@numeric_scaling(<span class="hljs-params">digits = <span class="hljs-number">7</span>, pos = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">offset</span>(<span class="hljs-params">polys, delta, jt = JT_SQUARE</span>):</span>  <span class="hljs-comment"># 偏置函数,输人多边形：[[[pt1_x,pt2_y],...,[ptN_x,ptN_y]],[...],...]</span><br>    pco = PyclipperOffset()<br>    pco.AddPaths(polys, jt, ET_CLOSEDPOLYGON)<br>    sln = pco.Execute(delta)  <span class="hljs-comment"># 偏置距离delta</span><br>    <span class="hljs-keyword">return</span> sln  <span class="hljs-comment"># 返回偏置曲线</span><br><br><span class="hljs-comment"># 轮廓平行路径填充</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genCpPath_clipper</span>(<span class="hljs-params">boundaries, interval, shellThk</span>):</span>  <span class="hljs-comment"># 输人:轮廓、偏置距离、填充带宽</span><br>    offsetPolyses = []  <span class="hljs-comment"># 偏置曲线列表</span><br>    delta = interval / <span class="hljs-number">2</span>  <span class="hljs-comment"># 首次偏置距离</span><br>    polys = offset(boundaries, -delta, JT_SQUARE)<br>    offsetPolyses.append(polys)  <span class="hljs-comment"># 偏置曲线存放在offsetPolys中</span><br>    <span class="hljs-keyword">while</span> math.fabs(delta) &lt; shellThk:  <span class="hljs-comment"># 循环直至偏置距离大于填充带宽</span><br>        delta += interval<br>        polys = offset(boundaries, -delta, JT_SQUARE)<br>        <span class="hljs-keyword">if</span> polys <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(polys) == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 已到偏置区域中心,则退出</span><br>        offsetPolyses.append(polys)<br>    <span class="hljs-keyword">return</span> offsetPolyses<br></code></pre></td></tr></table></figure><blockquote><p>按理来讲装饰器定义和调用应该分开来，这里为了方便所以写在一个文件中。</p></blockquote><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>偏置轮廓填充结果如下图所示，其中黑色为切片得到的轮廓，红色为偏置填充的路径。</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221219150924658.png" alt="image-20221219150924658"></p><p>第24层偏置填充结果：</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221219151007271.png" alt="image-20221219151007271"></p><p>第27层偏置填充结果：</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221219151126533.png" alt="image-20221219151126533"></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clipper库 基础类型和填充规则</title>
    <link href="/2022/12/18/Clipper%E5%BA%93%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A1%AB%E5%85%85%E8%A7%84%E5%88%99/"/>
    <url>/2022/12/18/Clipper%E5%BA%93%20%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A1%AB%E5%85%85%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="裁剪类型-ClipType"><a href="#裁剪类型-ClipType" class="headerlink" title="裁剪类型(ClipType)"></a>裁剪类型(ClipType)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">CT_INTERSECTION = <span class="hljs-number">0</span><br>CT_UNION = <span class="hljs-number">1</span><br>CT_DIFFERENCE = <span class="hljs-number">2</span><br>CT_XOR = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><ul><li>交集，AND (intersection) ：主体和裁剪多边形相交的区域。  </li><li>并集，OR (union) - 主体和裁剪多边形两者合并的区域。   </li><li>非/差，NOT (difference) - 裁剪多边形以外主体的区域。</li><li>异或，XOR (exclusive or) - 主体和裁剪多边形两者相交以外的区域。</li></ul><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221218092444226.png" alt="image-20221218092444226"></p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221218093353310.png" alt="image-20221218093353310"></p><p><b><code>ClipType</code> 的用法：</b></p><p>在使用 <code>Clipper</code> 对象对多边形进行裁剪时，可以通过在执行方法 <code>Execute</code> 中传入 <code>ClipType</code> 参数指定裁剪（布尔运算）类型。</p><p><code>Clipper.Execute </code> 方法描述如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Execute</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Performs the clipping operation and returns a list of paths.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Keyword arguments:</span><br><span class="hljs-string">        clip_type      -- type of the clipping operation</span><br><span class="hljs-string">        subj_fill_type -- fill rule of subject paths</span><br><span class="hljs-string">        clip_fill_type -- fill rule of clip paths</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Returns:</span><br><span class="hljs-string">        list of resulting paths</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Raises:</span><br><span class="hljs-string">        ClipperException -- operation did not succeed</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="闭合类型-EndType"><a href="#闭合类型-EndType" class="headerlink" title="闭合类型(EndType)"></a>闭合类型(EndType)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ET_CLOSEDPOLYGON = <span class="hljs-number">0</span><br>ET_CLOSEDLINE = <span class="hljs-number">1</span><br>ET_OPENBUTT = <span class="hljs-number">2</span><br>ET_OPENSQUARE = <span class="hljs-number">3</span><br>ET_OPENROUND = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><ul><li><strong>etClosedPolygon:</strong>  末端根据<code>JoinType</code>的值连接，填充路径使用多边形。  </li><li><strong>etClosedLine:</strong>  末端根据<code>JoinType</code>的值连接，填充路径使用多线段。</li><li><strong>etOpenButt:</strong> 末端为直角，且没有延伸。 </li><li><strong>etOpenSquare:</strong> 末端为直角，并且向路径外延伸一部分。</li><li><strong>etOpenRound:</strong> 末端为圆角，并且向路径外延伸一部分。</li><li><del><strong>etOpenSingle:</strong>  在一个方向上偏移一个开放路径，计划在未来更新。（我在Python下用的6.2.1版本还没有。）</del></li></ul><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221218094605442.png" alt="image-20221218094605442"></p><blockquote><p><code>EndType</code> 参数只在 <code>ClipperOffset.AddPath</code> 和 <code>ClipperOffset.AddPaths</code> 中用到，用于规定偏置轮廓的闭合方式。</p></blockquote><h2 id="连接类型-JoinType"><a href="#连接类型-JoinType" class="headerlink" title="连接类型(JoinType)"></a>连接类型(JoinType)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">JT_MITER = <span class="hljs-number">2</span><br>JT_ROUND = <span class="hljs-number">1</span><br>JT_SQUARE = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221218095018604.png" alt="image-20221218095018604"></p><ul><li><p><strong>jtMiter</strong>：斜角衔接。对一些窄角度，向外偏置可能会产生非常长的“尖峰”。</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221218095529324.png" alt="image-20221218095529324"></p><p>因此我们需要设置 <code> ClippOffset.MiterLimit</code> 属性用来指定原始顶点将被偏移的最大距离(以 <code>delta</code> 的倍数)，即在距离原始顶点 <code>delta</code> 倍数的距离上，将斜边截断成倒方角（这样就变成和 <strong>jtSquare</strong> 一样的连接效果了）。</p></li><li><p><strong>jtRound</strong>: 圆弧衔接。将所有斜边角进行到圆角处理。我们知道圆角其实是由倒角近似形成的，所以Clipper库引入<code>ClipperOffset.ArcTolerance</code> 属性（圆弧精度）指定了近似处理弧线时可接受的最大不精确性(“公差”)。</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221218100844645.png" alt="image-20221218100844645"></p><p><code>ArcTolerance</code> 默认值为0.25，说明qd（倒角偏离真实圆弧的最大距离）不超过0.25。我们可以发现，qd越小，整个近似圆弧越光滑，代价就是我们需要插入更多的顶点。</p></li><li><p><strong>jtSquare</strong>: 矩形衔接。将所有斜边角进行倒角 <code>C1×delta</code> 。 </p></li></ul><blockquote><p>感觉和数控技术中刀具偏置路径连接差不多。</p></blockquote><p>其中提到的 <code>delta</code> 是在 <code>ClipperOffset.Execute</code> 方法中传入的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Execute</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span> <span class="hljs-comment"># real signature unknown</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Performs the offset operation and returns a list of offset paths.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Keyword arguments:</span><br><span class="hljs-string">            delta -- amount to which the supplied paths will be offset - negative delta shrinks polygons,</span><br><span class="hljs-string">            positive delta expands them.</span><br><span class="hljs-string"></span><br><span class="hljs-string">            Returns:</span><br><span class="hljs-string">            list of offset paths</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="裁剪填充类型-PolyFillType-填充规则"><a href="#裁剪填充类型-PolyFillType-填充规则" class="headerlink" title="裁剪填充类型(PolyFillType) - 填充规则"></a>裁剪填充类型(PolyFillType) - 填充规则</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">PFT_EVENODD = <span class="hljs-number">0</span><br>PFT_NEGATIVE = <span class="hljs-number">3</span><br>PFT_NONZERO = <span class="hljs-number">1</span><br>PFT_POSITIVE = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>填充规则（fill rule）</strong>用于判断在封闭图形中，哪些区域是内部，哪些区域是外部（如’孔‘）。Clipper库支持4个填充规则：</p><ul><li>Even-Odd(奇偶)</li><li>Non-Zero(非零)</li><li>Positive(正)</li><li>Negative(负)</li></ul><p>我认为下面这张图比官方描述更加易于理解。我们赋予每个多边形子区域一个<strong>绕数</strong>。根据多边形的方向和一条外部到内部的射线来计算区域的绕数。</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221218103400376.png" alt="image-20221218103400376"></p><blockquote><p>图源自：《计算机辅助制造实践——Python实现三维打印路径规划》P163。</p></blockquote><p>填充规则描述如下：</p><ul><li><p>奇偶填充 : 奇数子区域填充，偶数子区域不填充。</p><blockquote><p>奇偶填充最简单，不需要借助绕数。奇偶填充规定：和射线相交的第奇数个轮廓内部区域是填充区域，第偶数个轮廓内部区域是非填充区域。适用于多边形本身和多边形之间不存在自相交的情况。</p></blockquote></li><li><p>非零填充：所有<code>绕数非零</code>的区域都填充。</p></li><li><p>正填充：所有<code>绕数 &gt;0</code>的区域都填充。</p></li><li><p>负填充：所有<code>绕数 &lt; 0</code>的区域都填充。</p></li></ul><blockquote><p>目前使用最广泛的填充规则是奇偶和非零填充。</p></blockquote><p><b><code>PolyFillType</code> 的用法：</b></p><p>在使用 <code>Clipper</code> 对象对多边形进行裁剪时，可以通过在执行方法 <code>Execute</code> 中传入 <code>PolyFillType</code> 指定 <code>subj_fill_type</code> （主体多边形的填充规则）和 <code>clip_fill_type</code> （裁剪多边形的填充规则）参数。</p><h2 id="裁剪属性-PolyType"><a href="#裁剪属性-PolyType" class="headerlink" title="裁剪属性(PolyType)"></a>裁剪属性(PolyType)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">PT_CLIP = <span class="hljs-number">1</span><br>PT_SUBJECT = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>裁剪属性有2个：</p><ul><li>主体多边形(<strong>ptSubject</strong> )：被裁剪多边形，也就是主体多边形。  </li><li>裁剪多边形(<strong>ptClip</strong> )：裁剪多边形，使用此多边形裁剪主体多边形。</li></ul><p><b><code>PolyType</code> 的用法：</b></p><p>在使用 <code>Clipper</code> 对象对多边形进行裁剪时，可以通过在执行方法 <code>AddPaths</code> 中传入 <code>PolyType</code> 指定传入的多边形（<code>paths</code>）的裁剪属性 <code>poly_type</code>（即是裁剪对象还是被裁剪对象）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">AddPaths</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span> <span class="hljs-comment"># real signature unknown</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Add a list of paths.</span><br><span class="hljs-string">    </span><br><span class="hljs-string">            Keyword arguments:</span><br><span class="hljs-string">            paths     -- paths to be added</span><br><span class="hljs-string">            poly_type -- type of added paths - subject or clip</span><br><span class="hljs-string">            closed    -- True if added paths are closed, False if open</span><br><span class="hljs-string">    </span><br><span class="hljs-string">            Returns:</span><br><span class="hljs-string">            True -- all or some paths are valid for clipping and were added</span><br><span class="hljs-string">    </span><br><span class="hljs-string">            Raises:</span><br><span class="hljs-string">            ClipperException -- all paths are invalid for clipping</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Clipper库  坐标圆整和精度控制</title>
    <link href="/2022/12/17/Clipper%E5%BA%93%20%20%E5%9D%90%E6%A0%87%E5%9C%86%E6%95%B4%E5%92%8C%E7%B2%BE%E5%BA%A6%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/12/17/Clipper%E5%BA%93%20%20%E5%9D%90%E6%A0%87%E5%9C%86%E6%95%B4%E5%92%8C%E7%B2%BE%E5%BA%A6%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="坐标圆整造成的问题"><a href="#坐标圆整造成的问题" class="headerlink" title="坐标圆整造成的问题"></a>坐标圆整造成的问题</h2><p>在Clipper库中顶点（<code>IntPoint</code>）的坐标使用的是<strong>整数</strong>类型， 目的是为了保持数字的鲁棒性，所以用整数类型来存储坐标，而不是我们常见的浮点数类型（浮点存在不精确性）。然而坐标圆整会带来如下两个问题：</p><ul><li><p>参与计算的顶点位置和真实的顶点位置存在一定偏差。对于一些数值极小的或相差极小的顶点难以处理。</p></li><li><p>造成微小的自交。</p></li></ul><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221217110430264.png" alt="image-20221217110430264"></p><blockquote><p>上图中，三个黑点是黄色和紫色多边形区域的实际交点，三个红点是三个黑点经坐标圆整之后的位置，黑点与红点之间的虚线表示对应关系。经过圆整后，造成了一个微小的自交区域。</p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>对于第一个问题，官方给出的解决方案为<strong>适当的缩放</strong>。同时指出Clipper库能接受范围为<code>±0x3fffffffffffffffff (4.6e+18)</code>的整数坐标值，支持扩展到非常高的精度 。这说明我们可以放心得对极小数值或极小数值差进行一个较大倍数的缩放，不会造成算法上的问题。</p><p>我们可以简单写一个装饰器，装饰我们用于多边形处理的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numeric_scaling</span>(<span class="hljs-params">digits: <span class="hljs-string">&#x27;int &gt; 0&#x27;</span> = <span class="hljs-number">7</span>, *, pos: <span class="hljs-built_in">list</span></span>):</span><span class="hljs-comment"># 必需参数pos：指定缩放参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span>(<span class="hljs-params">func</span>):</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scaled</span>(<span class="hljs-params">*_args</span>):</span><br>            __args = <span class="hljs-built_in">list</span>(_args)<br>            f = math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, digits)  <span class="hljs-comment"># 数值精度,默认为7位小数</span><br>            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> pos:<br>                <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(_args[p], <span class="hljs-built_in">int</span>) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(_args[p], <span class="hljs-built_in">float</span>):<br>                    __args[p] *= f<br>                <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(_args[p], <span class="hljs-built_in">list</span>):<br>                    __args[p] = [[<span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x * f, pt)) <span class="hljs-keyword">for</span> pt <span class="hljs-keyword">in</span> path] <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> _args[p]]<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">pass</span><br>            _result = func(*<span class="hljs-built_in">tuple</span>(__args))  <span class="hljs-comment"># _result is list of paths</span><br>            _result = [[<span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x / f, pt)) <span class="hljs-keyword">for</span> pt <span class="hljs-keyword">in</span> path] <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> _result]<br>            <span class="hljs-keyword">return</span> _result<br><br>        <span class="hljs-keyword">return</span> scaled<br><br>    <span class="hljs-keyword">return</span> decorate<br></code></pre></td></tr></table></figure><p>用例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyclipper <span class="hljs-keyword">import</span> *<br><br><span class="hljs-meta">@numeric_scaling(<span class="hljs-params">digits = <span class="hljs-number">7</span>, pos = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">offset</span>(<span class="hljs-params">polys, delta, jt = JT_SQUARE</span>):</span>  <span class="hljs-comment"># 偏置函数,输人多边形：[[[pt1_x,pt2_y],...,[ptN_x,ptN_y]],[...],...]</span><br>    pco = PyclipperOffset()<br>    pco.AddPaths(polys, jt, ET_CLOSEDPOLYGON)<br>    sln = pco.Execute(delta)  <span class="hljs-comment"># 偏置距离delta</span><br>    <span class="hljs-keyword">return</span> sln  <span class="hljs-comment"># 返回Polyline列表</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    polys = [[(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">100</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">100</span>, <span class="hljs-number">100</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)]]<br>    <span class="hljs-built_in">print</span>(offset(polys, -<span class="hljs-number">7.5</span>))  <span class="hljs-comment"># 向内偏置7.5</span><br></code></pre></td></tr></table></figure><blockquote><p>上面代码中 <code>digits</code> 为数值精度，其大小同样为输出结果中点坐标的小数位数。</p></blockquote><p>对于第二个问题，官方给出两种解决方案：</p><ul><li>使用 <code>CleanPolygons </code>函数去除。</li><li>将 <code>Clipper</code> 的 <code>StrictlySimple</code> 属性设置为<code>true</code>。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Fluent Python》笔记 协程</title>
    <link href="/2022/12/14/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20%E5%8D%8F%E7%A8%8B/"/>
    <url>/2022/12/14/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="生成器作为协程"><a href="#生成器作为协程" class="headerlink" title="生成器作为协程"></a>生成器作为协程</h2><p>协程是指一个过程， 这个过程与调用方协作， 产出由调用方提供的值。</p><p>协程使用的简单演示（用作协程的生成器）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">simple_coroutine</span>():</span> <span class="hljs-comment"># 生成器函数</span><br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt; coroutine started&#x27;</span>)<br><span class="hljs-meta">... </span>x = <span class="hljs-keyword">yield</span> <span class="hljs-comment"># yield表达式右边为协程产出的值，没有默认为None</span><br><span class="hljs-meta">... </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt; coroutine received:&#x27;</span>, x)<br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_coro = simple_coroutine() <span class="hljs-comment"># 得到生成器对象</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>my_coro <br>&lt;generator <span class="hljs-built_in">object</span> simple_coroutine at <span class="hljs-number">0x100c2be10</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(my_coro) <span class="hljs-comment"># 启动生成器，到第一个yield处暂停</span><br>-&gt; coroutine started<br><span class="hljs-meta">&gt;&gt;&gt; </span>my_coro.send(<span class="hljs-number">42</span>) <span class="hljs-comment"># 向协程中发送数据，协程定义体中yield表达式会计算出42</span><br>-&gt; coroutine received: <span class="hljs-number">42</span><br>Traceback (most recent call last): <span class="hljs-comment"># </span><br>...<br>StopIteration<br></code></pre></td></tr></table></figure><p>协程有四个状态，协程当前的状态可以使用<code>inspect.getgeneratorstate()</code> 函数确定， 该函数会返回下述字符串中的一个。<br>**’GEN_CREATED’**：等待开始执行。<br>**’GEN_RUNNING’**：解释器正在执行。<br>**’GEN_SUSPENDED’**：在 <code>yield</code> 表达式处暂停。<br>**’GEN_CLOSED’**：执行结束。  </p><p>因为 <code>send</code> 方法的参数会成为暂停的 <code>yield</code> 表达式的值， 所以， 仅当协程处于暂停状态（’GEN_SUSPENDED’）时才能调用 <code>send</code> 方法，否则会报错。</p><p>生成器实例化后得到的协程<code>my_coro</code>处于’GEN_CREATED’状态，通过<code>next(my_coro)</code> （也可以调用<code>my_coro.send(None)</code>，效果相同）激活协程变为’GEN_RUNNING’状态（第一次次激活叫做<strong>预激</strong>）。运行到<code>yield</code>表达式变为’GEN_SUSPENDED’状态，协程定义体执行结束变为’GEN_CLOSED’状态。</p><h2 id="通过装饰器预激协程"><a href="#通过装饰器预激协程" class="headerlink" title="通过装饰器预激协程"></a>通过装饰器预激协程</h2><p>因为<strong>预激</strong>是使用协程的关键步骤，为了简化协程的用法，有时会使用一个预激装饰器，这样可以避免忘记预激操作。预激装饰器示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coroutine</span>(<span class="hljs-params">func</span>):</span><br><span class="hljs-string">&quot;&quot;&quot;装饰器：向前执行到第一个`yield`表达式， 预激`func`&quot;&quot;&quot;</span><br><span class="hljs-meta">@wraps(<span class="hljs-params">func</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">primer</span>(<span class="hljs-params">*args,**kwargs</span>):</span><span class="hljs-comment"># 将被装饰的生成器函数替换成函数primer，返回预激后的生成器</span><br>        gen = func(*args,**kwargs)<span class="hljs-comment"># 获取生成器对象</span><br>        <span class="hljs-built_in">next</span>(gen)<span class="hljs-comment"># 预激</span><br>        <span class="hljs-keyword">return</span> gen<span class="hljs-comment"># 返回预激后的生成器</span><br>    <span class="hljs-keyword">return</span> primer<br></code></pre></td></tr></table></figure><h2 id="终止协程和异常处理"><a href="#终止协程和异常处理" class="headerlink" title="终止协程和异常处理"></a>终止协程和异常处理</h2><p>未处理的异常会导致协程终止。</p><p>示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoException</span>(<span class="hljs-params">Exception</span>):</span><br><span class="hljs-string">&quot;&quot;&quot;为这次演示定义的异常类型。 &quot;&quot;&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo_exc_handling</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt; coroutine started&#x27;</span>)<br>    <span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">try</span>:<br>                x = <span class="hljs-keyword">yield</span><br>            <span class="hljs-keyword">except</span> DemoException:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;*** DemoException handled. Continuing...&#x27;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&gt; coroutine received: &#123;!r&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(x))<br>    <span class="hljs-keyword">finally</span>:<br><span class="hljs-keyword">pass</span> <span class="hljs-comment"># 在协程终止时执行的操作</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>exc_coro = demo_exc_handling() <span class="hljs-comment"># 获取作为协程的生成器对象</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(exc_coro)<span class="hljs-comment"># 预激协程</span><br>-&gt; coroutine started<br><span class="hljs-meta">&gt;&gt;&gt; </span>exc_coro.send(<span class="hljs-number">11</span>)<span class="hljs-comment"># 发送数据给协程，通过send函数发送给协程的值会被yield表达式接收</span><br>-&gt; coroutine received: <span class="hljs-number">11</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>exc_coro.send(<span class="hljs-number">22</span>)<br>-&gt; coroutine received: <span class="hljs-number">22</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> inspect <span class="hljs-keyword">import</span> getgeneratorstate<br><span class="hljs-meta">&gt;&gt;&gt; </span>exc_coro.throw(DemoException)<br>*** DemoException handled. Continuing...<br><span class="hljs-meta">&gt;&gt;&gt; </span>getgeneratorstate(exc_coro)<br><span class="hljs-string">&#x27;GEN_SUSPENDED&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>exc_coro.close()<br><span class="hljs-meta">&gt;&gt;&gt; </span>getgeneratorstate(exc_coro)<br><span class="hljs-string">&#x27;GEN_CLOSED</span><br></code></pre></td></tr></table></figure><p><font color=gray><b>重要方法：</b></font></p><ul><li><p><code>generator.send(...)</code>  </p><p>如果发送给协程的值（通常可以使用内置的 <code>None</code> 和 <code>Ellipsis</code>）在协程定义体中参与运算抛出异常，且这个抛出的异常未处理，那么就会导致协程终止。</p></li><li><p><code>generator.throw(exc_type[, exc_value[, traceback]])</code> </p><p>使协程在暂停的 <code>yield</code> 表达式处抛出指定的异常（<code>exc_type</code>）。 如果协程处理了抛出的异常， 代码会向前执行到下一个 <code>yield</code> 表达式， 而产出的值会成为调用 <code>generator.throw</code>方法得到的返回值。 如果协程没有处理抛出的异常， 异常会向上冒泡， 传到调用方的上下文中。并且协程也会终止。</p></li><li><p><code>generator.close()</code>  </p><p>致使协程在暂停的 <code>yield</code> 表达式处抛出 <code>GeneratorExit</code> 异常。如果协程没有处理这个异常， 或者抛出了 <code>StopIteration</code> 异常（通常是指运行到结尾），调用方不会报错（此时协程终止退出）。 如果收到 <code>GeneratorExit</code> 异常， 协程一定不能产出值， 否则解释器会抛出 <code>RuntimeError</code> 异常。协程抛出的其他异常会向上冒泡， 传给调用方。并且协程也会终止。  </p></li></ul><blockquote><p><strong>虽然上面所说的协程其实本质上是生成器对象，此时生成器对象的行为体现了协程。</strong></p></blockquote><h2 id="yield-from在协程中的运用"><a href="#yield-from在协程中的运用" class="headerlink" title="yield from在协程中的运用"></a>yield from在协程中的运用</h2><p><code>yield from</code>的主要功能是打开双向通道， 把最外层的调用方与最内层的子生成器连接起来， 这样<strong>二者可以直接发送和产出值， 还可以直接传入异常，而不用在位于中间的协程中添加大量处理异常的样板代码</strong>。 有了这个结构， 协程可以通过以前不可能的方式委托职责。  </p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221214165543797.png" alt="image-20221214165543797"></p><ul><li><p><strong>委派生成器</strong><br>包含 <code>yield from &lt;iterable&gt;</code> 表达式的生成器函数。  </p></li><li><p>子生成器<br>从 <code>yield from</code> 表达式中 <code>&lt;iterable&gt;</code> 部分获取的生成器。</p></li></ul><p>该结构运行流程如下：</p><p>委派生成器在 <code>yield from</code> 表达式处暂停时， 调用方可以直接把数据发给子生成器， 子生成器再把产出的值发给调用方。 子生成器返回之后， 解释器会抛出 <code>StopIteration</code> 异常， 并把返回值附加到异常对象上， 此时委派生成器会恢复。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><br>Result = namedtuple(<span class="hljs-string">&#x27;Result&#x27;</span>, <span class="hljs-string">&#x27;count average&#x27;</span>)<br><br><span class="hljs-comment"># 子生成器</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">averager</span>():</span><br>    total = <span class="hljs-number">0.0</span><br>    count = <span class="hljs-number">0</span><br>    average = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        term = <span class="hljs-keyword">yield</span><br>        <span class="hljs-keyword">if</span> term <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">break</span><br>        total += term<br>        count += <span class="hljs-number">1</span><br>        average = total/count<br>        <span class="hljs-keyword">return</span> Result(count, average)<span class="hljs-comment"># 生成器的返回值</span><br><br><span class="hljs-comment"># 委派生成器</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grouper</span>(<span class="hljs-params">results, key</span>):</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    results[key] = <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> averager()<br>    <br><span class="hljs-comment"># 客户端代码，即调用方</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">data</span>):</span><br>    results = &#123;&#125;<br>    <span class="hljs-keyword">for</span> key, values <span class="hljs-keyword">in</span> data.items():<br>    group = grouper(results, key)<br>    <span class="hljs-built_in">next</span>(group)<span class="hljs-comment"># 预激协程</span><br>    <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> values:<br>    group.send(value) <br>    group.send(<span class="hljs-literal">None</span>) <span class="hljs-comment"># 终止协程</span><br>    report(results)<br>    <br><span class="hljs-comment"># 输出报告</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">report</span>(<span class="hljs-params">results</span>):</span><br>    <span class="hljs-keyword">for</span> key, result <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(results.items()):<br>    group, unit = key.split(<span class="hljs-string">&#x27;;&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#123;:2&#125; &#123;:5&#125; averaging &#123;:.2f&#125;&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(result.count, group, result.average, unit))<br><br>data = &#123;<br><span class="hljs-string">&#x27;girls;kg&#x27;</span>:<br>[<span class="hljs-number">40.9</span>, <span class="hljs-number">38.5</span>, <span class="hljs-number">44.3</span>, <span class="hljs-number">42.2</span>, <span class="hljs-number">45.2</span>, <span class="hljs-number">41.7</span>, <span class="hljs-number">44.5</span>, <span class="hljs-number">38.0</span>, <span class="hljs-number">40.6</span>, <span class="hljs-number">44.5</span>],<br><span class="hljs-string">&#x27;girls;m&#x27;</span>:<br>        [<span class="hljs-number">1.6</span>, <span class="hljs-number">1.51</span>, <span class="hljs-number">1.4</span>, <span class="hljs-number">1.3</span>, <span class="hljs-number">1.41</span>, <span class="hljs-number">1.39</span>, <span class="hljs-number">1.33</span>, <span class="hljs-number">1.46</span>, <span class="hljs-number">1.45</span>, <span class="hljs-number">1.43</span>],<br>    <span class="hljs-string">&#x27;boys;kg&#x27;</span>:<br>        [<span class="hljs-number">39.0</span>, <span class="hljs-number">40.8</span>, <span class="hljs-number">43.2</span>, <span class="hljs-number">40.8</span>, <span class="hljs-number">43.1</span>, <span class="hljs-number">38.6</span>, <span class="hljs-number">41.4</span>, <span class="hljs-number">40.6</span>, <span class="hljs-number">36.3</span>],<br>    <span class="hljs-string">&#x27;boys;m&#x27;</span>:<br>        [<span class="hljs-number">1.38</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">1.32</span>, <span class="hljs-number">1.25</span>, <span class="hljs-number">1.37</span>, <span class="hljs-number">1.48</span>, <span class="hljs-number">1.25</span>, <span class="hljs-number">1.49</span>, <span class="hljs-number">1.46</span>],<br>&#125; <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>main(data)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">9</span> boys averaging <span class="hljs-number">40.42</span>kg<br><span class="hljs-number">9</span> boys averaging <span class="hljs-number">1.39</span>m<br><span class="hljs-number">10</span> girls averaging <span class="hljs-number">42.04</span>kg<br><span class="hljs-number">10</span> girls averaging <span class="hljs-number">1.43</span>m<br></code></pre></td></tr></table></figure><p><code>grouper</code> 发送的每个值都会经由 <code>yield from</code> 处理， 通过管道传给<code>averager</code> 实例。 <code>grouper</code> 会在 <code>yield from</code> 表达式处暂停， 等待<code>averager</code> 实例处理客户端发来的值。 <code>averager</code> 实例运行完毕后， 返回的值绑定到 <code>results[key]</code> 上。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Fluent Python》笔记 else子句和上下文管理器</title>
    <link href="/2022/12/14/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20else%E5%AD%90%E5%8F%A5%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <url>/2022/12/14/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20else%E5%AD%90%E5%8F%A5%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="else子句"><a href="#else子句" class="headerlink" title="else子句"></a>else子句</h2><p>else 子句不仅能在 if 语句中使用， 还能在 for、 while 和 try 语句中使用。在if语句中，else子句的作用是，如果不满足if的条件，那么执行else子句中的代码，这是Python学习中的基础知识。</p><p>在 for 语句后加 else 子句作用是，仅当 for 循环运行完毕时（即 for 循环没有被 break 语句中止）才运行 else 子句中的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> items:<br>i -= <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br><span class="hljs-comment"># do something</span><br></code></pre></td></tr></table></figure><p>在 while 语句后加 else 子句作用是，仅当 while 循环因为条件为假值而退出时（即 while 循环没有被 break 语句中止） 才运行 else 子句中的代码。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">3</span>:<br>i -= <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br><span class="hljs-comment"># do something</span><br></code></pre></td></tr></table></figure><p>在 try 语句后加 else 子句作用是， 仅当 try 代码块中没有异常抛出时才运行 else 子句中的代码。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>i = <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span>:<br><span class="hljs-comment"># do something</span><br></code></pre></td></tr></table></figure><p>在上述三种情况下， 如果异常或者 <code>return</code>、 <code>break</code> 或 <code>continue</code> 语句导致控制权跳到了复合语句的主块之外，那么 else 子句也会被跳过。</p><h2 id="上下文管理器和with块"><a href="#上下文管理器和with块" class="headerlink" title="上下文管理器和with块"></a>上下文管理器和with块</h2><p>上下文管理器协议包含 <code>__enter__</code> 和 <code>__exit__</code> 两个方法。 <code>with</code> 语句开始运行时， 会在上下文管理器对象上调用 <code>__enter__</code> 方法。 <code>with</code> 语句运行结束后， 会在上下文管理器对象上调用 <code>__exit__</code> 方法。</p><p>我在写代码时，总会在操作文件时使用<code>with</code>语句。通过<code>with...as...</code>语句把文件对象作为上下文管理器使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file.txt&quot;</span>) <span class="hljs-keyword">as</span> f: <span class="hljs-comment"># f绑定到打开的文件上， 因为文件的 __enter__ 方法返回 self</span><br>txt = f.readline()<br><span class="hljs-built_in">print</span>(txt)<br></code></pre></td></tr></table></figure><p>执行 <code>with</code> 后面的表达式得到的结果就是<strong>上下文管理器</strong>对象。因为<code>open</code>函数返回 <code>TextIOWrapper</code> 类的实例，所以此时把<code>TextIOWrapper</code>对象作为上下文管理器对象，<code>with</code>语句运行是，调用<code>TextIOWrapper</code>对象的 <code>__enter__</code> 方法，返回 <code>self</code> 赋值给<code>as</code>后的<code>f</code>，所以 <code>f</code> 仍然是<code>TextIOWrapper</code>对象，即可以正常进行文件读写等操作。当<code>with</code>语句块结束时，调用上下文管理器也就是<code>TextIOWrapper</code>对象（这里的<code>TextIOWrapper</code>对象不是 <code>__enter__</code> 方法返回 <code>self</code>）的 <code>__exit__</code> 方法，即自动完成了文件关闭的操作。</p><p>自定义上下文管理器类示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LookingGlass</span>:</span><br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">import</span> sys<br>        self.original_write = sys.stdout.write<br>        sys.stdout.write = self.reverse_write<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;JABBERWOCKY&#x27;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_write</span>(<span class="hljs-params">self, text</span>):</span><br>self.original_write(text[::-<span class="hljs-number">1</span>])<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span>(<span class="hljs-params">self, exc_type, exc_value, traceback</span>):</span><br>        <span class="hljs-keyword">import</span> sys<br>        sys.stdout.write = self.original_write<br>        <span class="hljs-keyword">if</span> exc_type <span class="hljs-keyword">is</span> ZeroDivisionError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Please DO NOT divide by zero!&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><span class="hljs-keyword">with</span> LookingGlass() <span class="hljs-keyword">as</span> what:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Alice, Kitty and Snowdrop&#x27;</span>)<br><span class="hljs-built_in">print</span>(what)<br></code></pre></td></tr></table></figure><p><code>__enter__</code>方法的参数只有隐式的<code>self</code>一个，不会传入任何参数。</p><p><code>__exit__</code>方法的参数如下：</p><ul><li><p><strong>exc_type</strong></p><p>异常类（例如 ZeroDivisionError）。</p></li><li><p><strong>exc_value</strong></p><p>异常实例。 有时会有参数传给异常构造方法， 例如错误消息， 这些参数可以使用 <code>exc_value.args</code> 获取。 </p></li><li><p><strong>traceback</strong></p><p><code>traceback</code> 对象。</p></li></ul><h2 id="contextmanager"><a href="#contextmanager" class="headerlink" title="@contextmanager"></a>@contextmanager</h2><p><code>@contextmanager</code>是<code>contextlib</code>模块中的装饰器。其作用是减少创建上下文管理器的样板代码量。使用它就可以不用像上面那样创建一个类仍然会分别定义 <code>__enter__</code> 和 <code>__exit__</code> 方法，只需实现有一个 <code>yield</code> 语句的生成器函数即可。</p><p>在使用 <code>@contextmanager</code> 装饰的生成器函数中，<code>yield</code>语句前面的所有代码在 <code>with</code> 块开始时（即解释器调用 <code>__enter__</code> 方法时） 执行， <code>yield</code>语句后面的代码在 <code>with</code> 块结束时（即调用 <code>__exit__</code> 方法时） 执行。<code>contextlib.contextmanager</code> 装饰器会把生成器函数包装成实现了 <code>__enter__</code> 和 <code>__exit__</code> 方法的类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> contextlib<br><br><span class="hljs-meta">@contextlib.contextmanager</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">looking_glass</span>():</span><br>    <span class="hljs-keyword">import</span> sys<br>    original_write = sys.stdout.write<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverse_write</span>(<span class="hljs-params">text</span>):</span><br>    original_write(text[::-<span class="hljs-number">1</span>])<span class="hljs-comment"># 闭包的知识，访问自由变量original_write</span><br>   <br>    sys.stdout.write = reverse_write<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;JABBERWOCKY&#x27;</span><br>    sys.stdout.write = original_write<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><span class="hljs-keyword">with</span> LookingGlass() <span class="hljs-keyword">as</span> what:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Alice, Kitty and Snowdrop&#x27;</span>)<br><span class="hljs-built_in">print</span>(what)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Fluent Python》笔记 迭代器和生成器</title>
    <link href="/2022/12/13/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2022/12/13/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 迭代器用于从集合中取出元素； 而生成器用于“凭空”生成元素。</p></blockquote><h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><p>解释器需要迭代对象 <code>x</code> 时， 会自动调用 <code>iter(x)</code>。<br>内置的 <code>iter</code> 函数有以下作用：<br>(1) 检查对象是否实现了 <code>__iter__</code> 方法， 如果实现了就调用它， 获取一个迭代器对象。<br>(2) 如果没有实现 <code>__iter__</code> 方法， 但是实现了 <code>__getitem__</code> 方法，Python 会创建一个迭代器， 尝试按顺序（从索引 0 开始） 获取元素。<br>(3) 如果尝试失败， Python 抛出 <code>TypeError</code> 异常， 通常会提示<code>“C object is not iterable”</code>（C 对象不可迭代）， 其中 C 是目标对象所属的类。 </p><p>正因为序列都实现了 <code>__getitem__</code> 方法，所以序列对象可迭代。如果实现了<code>__iter__</code>方法，能够给返回对象自身的迭代器，那么这个对象也是可迭代对象。</p><p>可迭代对象与迭代器的关系：<strong>Python从可迭代对象中获取迭代器</strong>。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>使用<code>iter()</code>函数从可迭代对象a中构建迭代器b：<code>b = iter(a)</code>。</p><p>使用<code>next()</code>函数使用迭代器b：<code>next(b)</code>。</p><p>迭代器对象中实现了<code>__next__</code>方法，返回可迭代对象中的下一个元素；如果没有元素了，那么抛出 <code>StopIteration</code> 异常。迭代器还实现了 <code>__iter__</code> 方法， 因此迭代器也可以迭代。  </p><p>下面示例展示了典型的迭代器模式实现一个可迭代对象（Sentence类对象）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> reprlib<br><br>RE_WORD = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;\w+&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sentence</span>:</span><br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, text</span>):</span><br>self.text = text<br>self.words = RE_WORD.findall(text)<br>        <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br><span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="hljs-built_in">repr</span>(self.text)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span> <span class="hljs-comment"># 返回一个迭代器</span><br><span class="hljs-keyword">return</span> SentenceIterator(self.words)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SentenceIterator</span>:</span><span class="hljs-comment"># 迭代器类</span><br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, words</span>):</span><br>self.words = words <br>self.index = <span class="hljs-number">0</span><br>        <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">try</span>:<br>        word = self.words[self.index]<br>        <span class="hljs-keyword">except</span> IndexError:<br>        <span class="hljs-keyword">raise</span> StopIteration()<br>        self.index += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> word<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span><br><span class="hljs-keyword">return</span> self<br></code></pre></td></tr></table></figure><p>可迭代的对象一定不能是自身的迭代器。即可迭代的对象必须实现 <code>__iter__</code> 方法， 但不能实现 <code>__next__</code> 方法。另一方面， 迭代器应该一直可以迭代。 迭代器的 <code>__iter__</code> 方法应该返回自身。</p><h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><p>使用生成器函数实现和上面迭代器示例一样的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> reprlib<br><br>RE_WORD = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">&#x27;\w+&#x27;</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sentence</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, text</span>):</span><br>        self.text = text<br>        self.words = RE_WORD.findall(text)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Sentence(%s)&#x27;</span> % reprlib.<span class="hljs-built_in">repr</span>(self.text)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> self.words:<span class="hljs-comment"># 迭代序列</span><br>        <span class="hljs-keyword">yield</span> word<span class="hljs-comment"># 产出元素</span><br>        <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>上面代码中<code>__iter__</code>方法的定义体中有<code>yield</code>关键字，即<code>__iter__</code>方法是一个生成器函数。调用生成器函数时，会返回一个生成器对象。</p><blockquote><p>只要 Python 函数中包含关键字 yield， 该函数就是生成器函数。</p></blockquote><p>生成器是迭代器（因为生成器完全实现了迭代器接口）， 会生成传给 <code>yield</code> 关键字的表达式的值。对于生成器函数创建的生成器对象， 我们可以理解为其包装了生成器函数的定义体。 把生成器传给 <code>next()</code> 函数时， 生成器函数会向前， 执行函数定义体中的下一个 <code>yield</code> 语句， 返回产出的值， 并在函数定义体的当前位置暂停。 最终， 函数的定义体返回时， 外层的生成器对象会抛出<code>StopIteration</code> 异常——这一点与迭代器协议一致。  </p><blockquote><p>当通过<code>for</code>循环进行迭代时， <code>for</code> 机制的作用与 <code>g = iter(gen_AB())</code> （其中<code>gen_AB</code>为生成器函数名）一样， 用于获取生成器对象， 然后每次迭代时调用 <code>next(g)</code>。</p></blockquote><h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>生成器表达式可以理解为列表推导的惰性版本：不会迫切地构建列表，而是返回一个生成器，按需惰性生成元素。因此，使用生成器表达式构建列表更加节省内存。</p><blockquote><p>在前面的序列类型提到，列表推导两边是方括号，而生成器表达式两边是圆括号。</p></blockquote><p>生成器表达式是构建一个生成器对象，和生成器函数返回的生成器对象一样。</p><h2 id="标准库中的生成器函数"><a href="#标准库中的生成器函数" class="headerlink" title="标准库中的生成器函数"></a>标准库中的生成器函数</h2><ul><li><p>用于过滤的生成器函数</p><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>itertools</td><td>compress(it, selector_it)</td><td>并行处理两个可迭代的对象； 如果 selector_it 中的元素是真值， 产出 it 中对应的元素。</td></tr><tr><td>itertools</td><td>dropwhile(predicate, it)</td><td>处理 it， 跳过 predicate 的计算结果为真值的元 素， 然后产出剩下的各个元素（不再进一步检 查）。</td></tr><tr><td>（ 内置）</td><td><code>filter(predicate, it)</code></td><td>把 it 中的各个元素传给 predicate， 如果 predicate(item)返回真值， 那么产出对应的元 素； 如果predicate是 None， 那么只产出真值元素。</td></tr><tr><td>itertools</td><td>filterfalse(predicate, it)</td><td>与 filter 函数的作用类似， 不过 predicate 的 逻辑是相反的： predicate 返回假值时产出对应 的元素。</td></tr><tr><td>itertools</td><td>islice(it, stop) 或 islice(it, start, stop, step=1)</td><td>产出 it 的切片， 作用类似于 s[:stop] 或 s[start:stop:step]， 不过 it 可以是任何可迭代 的对象， 而且这个函数实现的是惰性操作。</td></tr><tr><td>itertools</td><td>takewhile(predicate, it)</td><td>predicate 返回真值时产出对应的元素， 然后立 即停止， 不再继续检查。</td></tr></tbody></table></li><li><p>用于映射的生成器函数</p><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>itertools</td><td>accumulate(it, [func])</td><td>产出累积的总和；如果提供了func，那么把前两个元素传给它，然后把计算结果和下一个元素传给它， 以此类推，最后产出结果。</td></tr><tr><td>（内置）</td><td><code>enumerate(iterable, start=0)</code></td><td>产出由两个元素组成的元组，结构是 (index, item)， 其中 index 从 start 开始计数，item 则从 iterable 中获取。</td></tr><tr><td>（内置）</td><td><code>map(func, it1, [it2, ..., itN])</code></td><td>把 it 中的各个元素传给func，产出结果；如果传入 N 个可迭代的对象，那么 func 必须能接受 N 个参 数， 而且要并行处理各个可迭代的对象。</td></tr><tr><td>itertools</td><td>starmap(func, it)</td><td>把 it 中的各个元素传给 func，产出结果；输入的可迭代对象应该产出可迭代的元素 iit， 然后以 func(*iit) 这种形式调用 func。</td></tr></tbody></table></li><li><p>合并多个可迭代对象的生成器函数</p><table><thead><tr><th>模块</th><th>函数</th><th align="left">说明</th></tr></thead><tbody><tr><td>itertools</td><td>chain(it1, …, itN)</td><td align="left">先产出 it1 中的所有元素， 然后产出 it2 中的所有元素， 以此类推，无缝连接在一起。</td></tr><tr><td>itertools</td><td>chain.from_iterable(it)</td><td align="left">产出 it 生成的各个可迭代对象中的元素 一个接一个，无缝连接在一起； it 应该产出可迭代的元素，例如可迭代的对象列表。</td></tr><tr><td>itertools</td><td>product(it1, …, itN, repeat=1)</td><td align="left">计算笛卡儿积：从输入的各个可迭代对象中获取元素，合并成由 N 个元素组成的元组， 与嵌套的 for 循环效果一样； repeat 指明重复处理多少次输入的可迭代对象。</td></tr><tr><td>（内置）</td><td><code>zip(it1, ..., itN)</code></td><td align="left">并行从输入的各个可迭代对象中获取元素，产出由 N 个元素组成的元组，只要有一个可迭代的对象到头了，就默默地停止。</td></tr><tr><td>itertools</td><td>zip_longest(it1, …, itN, fillvalue=None)</td><td align="left">并行从输入的各个可迭代对象中获取元素， 产出由 N 个元素组成的元组，等到最长的可迭代对象到头后才停止， 空缺的值使用 fillvalue 填充。</td></tr></tbody></table></li><li><p>把输入的各个元素扩展成多个输出元素的生成器函数</p><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>itertools</td><td><code>combinations(it, out_len)</code></td><td>把 it 产出的 out_len 个元素<strong>组合</strong>在一起，然后产出。</td></tr><tr><td>itertools</td><td><code>combinations_with_replacement(it, out_len)</code></td><td>把 it 产出的 out_len 个元素<strong>组合</strong>在一起，然后产出，<strong>包含相同元素的组合</strong>。</td></tr><tr><td>itertools</td><td>count(start=0, step=1)</td><td>从 start 开始不断产出数字， 按 step 指定的步幅增加。</td></tr><tr><td>itertools</td><td>cycle(it)</td><td>从 it 中产出各个元素，存储各个元素的副本， 然后按顺序重复不断地产出各个元素。</td></tr><tr><td>itertools</td><td><code>permutations(it, out_len=None)</code></td><td>把 out_len 个 it 产出的元素<strong>排列</strong>在一起， 然后产出这些排列；out_len的默认值等于 len(list(it))。</td></tr><tr><td>itertools</td><td><code>repeat(item, [times])</code></td><td>重复不断地产出指定的元素， 除非提供 times， 指定次数。</td></tr></tbody></table></li><li><p>用于重新排列元素的生成器函数</p><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>itertools</td><td>groupby(it,key=None)</td><td>产出由两个元素组成的元素， 形式为 (key, group)，其中 key 是分组标准， group 是生成器，用于产出分组里的元素。</td></tr><tr><td>（内置）</td><td><code>reversed(seq)</code></td><td>从后向前，倒序产出 seq 中的元素； seq 必须是序列，或者是实现了 <strong>reversed</strong> 特殊方法的对象。</td></tr><tr><td>itertools</td><td>tee(it, n=2)</td><td>产出一个由 n 个生成器组成的元组， 每个生成器用于单独产出输入的可迭代对象中的元素。</td></tr></tbody></table></li></ul><blockquote><p>上述生成器函数，其参数是生成器对象，返回也是生成器对象，故可以组合使用。</p></blockquote><h2 id="可迭代的归约函数"><a href="#可迭代的归约函数" class="headerlink" title="可迭代的归约函数"></a>可迭代的归约函数</h2><p>如果一个函数接受一个可迭代的对象，然后返回单个结果，那么就可以叫这个函数为“归约”函数、 “合拢”函数或“累加”函数。</p><p>常见的归约函数如下：</p><table><thead><tr><th>模块</th><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>（内置）</td><td>all(it)</td><td>it 中的所有元素都为真值时返回 True，否则返回 False； all([]) 返回 True。</td></tr><tr><td>（内置）</td><td>any(it)</td><td>只要 it 中有元素为真值就返回 True， 否则返回 False； any([]) 返回 False。</td></tr><tr><td>（内置）</td><td>max(it, [key=,] [default=])</td><td>返回 it 中值最大的元素； *key 是排序函数，与 sorted 函 数中的一样；如果可迭代的对象为空，返回 default。</td></tr><tr><td>（内置）</td><td>min(it, [key=,] [default=])</td><td>返回 it 中值最小的元素； #key 是排序函数，与 sorted 函 数中的一样；如果可迭代的对象为空，返回 default。</td></tr><tr><td>functools</td><td>reduce(func, it, [initial])</td><td>把前两个元素传给 func，然后把计算结果和第三个元素传 给 func，以此类推，返回最后的结果；如果提供了 initial，把它当作第一个元素传入。</td></tr><tr><td>（内置）</td><td>sum(it, start=0)</td><td>it 中所有元素的总和， 如果提供可选的 start，会把它加 上（计算浮点数的加法时， 可以使用 math.fsum 函数提高 精度）。</td></tr></tbody></table><h2 id="iter函数的特殊用法"><a href="#iter函数的特殊用法" class="headerlink" title="iter函数的特殊用法"></a>iter函数的特殊用法</h2><p>Python 中迭代对象 <code>x</code> 时会调用 <code>iter(x)</code>得到一个迭代器对象。除此之外，<code>iter</code>函数还有一个用法，示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;mydata.txt&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-built_in">iter</span>(fp.readline, <span class="hljs-string">&#x27;\n&#x27;</span>):<br>process_line(line)<br></code></pre></td></tr></table></figure><p>这里<code>iter</code>函数传入两个参数， 使用常规的函数或任何可调用的对象创建迭代器。 第一个参数必须是可调用的对象（<code>fp.readline</code>）， 用于不断调用（没有参数）产出各个值； 第二个值是哨符（<code>&#39;\n&#39;</code>）， 这是个标记值，当可调用的对象返回的值等于哨符时（读取到空行或文件末尾），触发迭代器抛出 <code>StopIteration</code> 异常（迭代结束）， 而不产出这个值。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Fluent Python》笔记 函数对象和装饰器</title>
    <link href="/2022/12/12/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/2022/12/12/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>在Python中函数是<strong>对象</strong>，本质是<strong>function</strong>类的实例。同样函数对象也是“一等对象”，即满足以下条件：</p><ul><li>在运行时创建</li><li>能赋值给变量或数据结构中的元素</li><li>能作为参数传给函数</li><li>能作为函数的返回结果  </li></ul><p>函数对象的<code>__doc__</code>属性用于生成对象的帮助文本。</p><p>接受函数为参数， 或者把函数作为结果返回的函数是<strong>高阶函数</strong>（higherorder function），例如<code>map、filter、reduce</code>等函数。</p><p><code>lambda</code>关键字在 Python 表达式内创建<strong>匿名函数</strong>。</p><h2 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h2><p>可调用对象为可以应用<strong>调用运算符</strong><code>()</code>的对象。</p><p>Python文档中列出以下7种可调用对象。</p><ul><li><p><strong>用户定义的函数</strong></p><p>使用 def 语句或 lambda 表达式创建。</p></li><li><p><strong>内置函数</strong></p><p>使用 C 语言（CPython） 实现的函数， 如 len 或 time.strftime。</p></li><li><p><strong>内置方法</strong></p><p>使用 C 语言实现的方法， 如 dict.get。</p></li><li><p><strong>方法</strong><br>在类的定义体中定义的函数。</p></li><li><p><strong>类</strong><br>调用类时会运行类的 <code>__new__</code> 方法创建一个实例， 然后运行<code>__init__</code> 方法， 初始化实例， 最后把实例返回给调用方。</p></li><li><p><strong>类的实例</strong><br>如果类中定义了 <code>__call__</code>方法， 那么它的实例可以作为函数调用。</p></li><li><p><strong>生成器函数</strong><br>使用 <code>yield</code> 关键字的函数或方法。 调用生成器函数返回的是生成器对象。  </p></li></ul><blockquote><p>可以通过内置函数<code>callable()</code> 判断对象是否可调用。</p></blockquote><h2 id="函数属性"><a href="#函数属性" class="headerlink" title="函数属性"></a>函数属性</h2><p>既然我们说函数是一个对象，那么它也会像对象一样拥有属性。下表列出了一些只有用户定义的函数对象具有而常规对象没有的属性。</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><code>__annotations__</code></td><td>dict</td><td>参数和返回值的注解</td></tr><tr><td><code>__call__</code></td><td>method wrapper</td><td>实现 () 运算符； 即可调用对象协议</td></tr><tr><td><code>__closure__</code></td><td>tuple</td><td>函数闭包， 即自由变量的绑定（通常是 None）</td></tr><tr><td><code>__code__</code></td><td>code</td><td>编译成字节码的函数元数据和函数定义体</td></tr><tr><td><code>__defaults__</code></td><td>tuple</td><td>形式参数的默认值</td></tr><tr><td><code>__get__</code></td><td>method wrapper</td><td>实现只读描述符协议</td></tr><tr><td><code>__globals__</code></td><td>dict</td><td>函数所在模块中的全局变量</td></tr><tr><td><code>__kwdefaults__</code></td><td>dict</td><td>仅限关键字形式参数的默认值</td></tr><tr><td><code>__name__</code></td><td>str</td><td>函数名称</td></tr><tr><td><code>__qualname__</code></td><td>str</td><td>函数的限定名称， 如 Random.choice</td></tr></tbody></table><h2 id="仅限关键字参数"><a href="#仅限关键字参数" class="headerlink" title="仅限关键字参数"></a>仅限关键字参数</h2><p>仅限关键字参数（keyword-only argument）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tag</span>(<span class="hljs-params">name, *content, cls=<span class="hljs-literal">None</span>, **attrs</span>):</span> <span class="hljs-keyword">pass</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, *, b</span>):</span> <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p><code>tag</code>函数的输入参数中，第一个参数后面的任意个<strong>参数</strong>会被 <code>*content</code> 捕获， 存入一<strong>个元组</strong>（即content为元组）。在<code>tag</code>函数定义中没有明确指定名称的<strong>关键字参数</strong>会被 <code>**attrs</code> 捕获， 存入一个<strong>字典</strong>（即attrs为字典）。  在上面代码中，name参数和a参数为<strong>定位参数</strong>，cls参数和b参数为<strong>仅限关键字参数</strong>。如果仅限关键字参数没有默认值，那么强制传入对应实参。</p><h2 id="获取函数的信息"><a href="#获取函数的信息" class="headerlink" title="获取函数的信息"></a>获取函数的信息</h2><ul><li><p><strong>获取函数参数信息</strong></p><p>函数对象有个 <code>__defaults__</code> 属性， 它的值是一个元组， 里面保存着定位参数和关键字参数的默认值。 仅限关键字参数的默认值在<code>__kwdefaults__</code> 属性中。 参数的名称在 <code>__code__</code> 属性中， 它的值是一个 code 对象引用， 自身也有很多属性。</p></li><li><p><strong>获取函数注解</strong></p><p>带注解的函数声明示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clip</span>(<span class="hljs-params">text:<span class="hljs-built_in">str</span>, max_len:<span class="hljs-string">&#x27;int &gt; 0&#x27;</span>=<span class="hljs-number">80</span></span>) -&gt; <span class="hljs-built_in">str</span>:</span> <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><blockquote><p>各个参数在 <code>:</code> 之后添加注解表达式，若参数有默认值，则在参数名和<code>=</code>之间加入注解表达式。如果想注解返回值， 在 <code>)</code> 和函数声明末尾的 <code>:</code> 之间添加 <code>-&gt;</code> 和注解表达式。</p></blockquote><p>注解不会做任何处理， 只是存储在函数的 <code>__annotations__</code> 属性（一个字典） 中。</p><h2 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h2><p>函数装饰器用于在源码中“标记”函数， 以某种方式增强函数的行为。 装饰器是可<strong>调用的对象</strong>， 其参数是另一个函数（被装饰的函数） 。 装饰器可能会处理被装饰的函数， 然后把它返回， 或者将其替换成另一个函数或可调用对象。 </p><p>装饰器替换被装饰函数示例： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deco</span>(<span class="hljs-params">func</span>):</span><span class="hljs-comment"># deco是一个装饰器，其输入参数时另一个函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span>():</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;running inner()&#x27;</span>)<br><span class="hljs-keyword">return</span> inner<br><br><span class="hljs-meta">@deco</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">target</span>():</span><span class="hljs-comment"># 使用 deco 装饰 target</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;running target()&#x27;</span>)<br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span>target()<br>running inner()<br><span class="hljs-meta">&gt;&gt;&gt; </span>target<br>&lt;function deco.&lt;<span class="hljs-built_in">locals</span>&gt;.inner at <span class="hljs-number">0x10063b598</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><p>装饰器的第一大特性是， 能把被装饰的函数<strong>替换</strong>成其他函数。 第二个特性是， 装饰器<strong>在加载模块时立即执行</strong>。  </p><p>装饰器通常在一个模块中定义， 然后应用到其他模块中的函数上。</p><p>大多数装饰器会在内部定义一个函数， 然后将其返回，替换被装饰的函数。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221212151316771.png" alt="image-20221212151316771"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>avg = make_averager()<br><span class="hljs-meta">&gt;&gt;&gt; </span>avg(<span class="hljs-number">10</span>)<br><span class="hljs-number">10.0</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>avg(<span class="hljs-number">11</span>)<br><span class="hljs-number">10.5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>avg(<span class="hljs-number">12</span>)<br><span class="hljs-number">11.0</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，<code>series</code> 是 <code>make_averager</code> 函数的局部变量。 可是， 调用 <code>avg(10)</code><br>时， <code>make_averager</code> 函数已经返回了，而它的本地作用域也一去不复返了。但代码测试结果告诉我们， <code>series</code>变量以某种形式保存了下来，这就是闭包的特性。<code>series</code>是<strong>自由变量</strong>，即未在本地作用域中绑定的变量。  </p><p><strong>闭包</strong>是一种函数， 它会保留定义函数时存在的自由变量的绑定，这样调用函数时， 虽然定义作用域不可用了， 但是仍能使用那些绑定。</p><blockquote><p> 只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量，也就是说只有嵌套在其他函数中的函数才会涉及到闭包的知识。</p></blockquote><p><code>nonlocal</code>关键字能把变量标记为自由变量。示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_averager</span>():</span><br>count = <span class="hljs-number">0</span><br>total = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">averager</span>(<span class="hljs-params">new_value</span>):</span><br><span class="hljs-keyword">nonlocal</span> count, total<span class="hljs-comment"># count, total都为自由变量，都会在闭包中进行绑定和更新</span><br>count += <span class="hljs-number">1</span><br>total += new_value<br><span class="hljs-keyword">return</span> total / count<br><span class="hljs-keyword">return</span> averager<br></code></pre></td></tr></table></figure><p>实现一个简单的装饰器，用于计算被调用函数的运行时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clock</span>(<span class="hljs-params">func</span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clocked</span>(<span class="hljs-params">*args</span>):</span><br>t0 = time.perf_counter()<br>        result = func(*args)<br>        elapsed = time.perf_counter() - t0<br>        name = func.__name__<br>        arg_str = <span class="hljs-string">&#x27;, &#x27;</span>.join(<span class="hljs-built_in">repr</span>(arg) <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> args)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[%0.8fs] %s(%s) -&gt; %r&#x27;</span> % (elapsed, name, arg_str, result))<br>        <span class="hljs-keyword">return</span> result<br><span class="hljs-keyword">return</span> clocked<br></code></pre></td></tr></table></figure><p>上述代码反映了装饰器的典型行为： 把被装饰的函数替换成新函数， 二者接受相同的参数， 而且通常返回被装饰的函数本该返回的值， 同时还会做些额外操作。</p><h2 id="标准库中的装饰器"><a href="#标准库中的装饰器" class="headerlink" title="标准库中的装饰器"></a>标准库中的装饰器</h2><ul><li><p><code>functools.lru_cache</code></p><p><code>functools.lru_cache</code>是非常实用的装饰器， 实现了<strong>备忘</strong>功能。 这是一项优化技术， 它把耗时的函数的结果保存起来， 避免传入相同的参数时重复计算。 LRU 三个字母是“Least Recently Used”的缩写， 表明缓存不会无限制增长， 一段时间不用的缓存<br>条目会被清除。</p><p>该装饰器可以使用两个可选参数进行配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">functools.lru_cache(maxsize=<span class="hljs-number">128</span>, typed=<span class="hljs-literal">False</span>)  <br></code></pre></td></tr></table></figure><ul><li>maxsize：指定存储多少个调用的结果。   </li><li>typed：若为 True， 把不同参数类型得到的结果分开保存，即把通常认为相等的浮点数和整数参数（如 1 和 1.0） 区分开。</li></ul></li><li><p><code>functools.singledispatch</code></p><p><code>functools.singledispatch</code> 装饰器可以把整体方案拆分成多个模块， 甚至可以为无法修改的类提供专门的函数（使用<code>@&lt;base_function&gt;.register(&lt;type&gt;)</code> 装饰）。 使用<code>@singledispatch</code> 装饰的普通函数会变成<strong>泛函数</strong>（generic function） ：根据第一个参数的类型， 以不同方式执行相同操作的一组函数。  </p></li></ul><h2 id="叠放装饰器"><a href="#叠放装饰器" class="headerlink" title="叠放装饰器"></a>叠放装饰器</h2><p>因为装饰器是一个函数（可调用对象），所以可以组合使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@d1</span><br><span class="hljs-meta">@d2</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f&#x27;</span>)<br></code></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span>():</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;f&#x27;</span>)<br>f = d1(d2(f))  <br></code></pre></td></tr></table></figure><h2 id="参数化装饰器"><a href="#参数化装饰器" class="headerlink" title="参数化装饰器"></a>参数化装饰器</h2><p>为了实现参数化装饰器，我们引入装饰器工厂函数，装饰器函数嵌套在该函数中。调用装饰器工厂函数会返回真正的装饰器， 这才是应用到目标函数上的装饰器。参数化装饰器示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br>DEFAULT_FMT = <span class="hljs-string">&#x27;[&#123;elapsed:0.8f&#125;s] &#123;name&#125;(&#123;args&#125;) -&gt; &#123;result&#125;&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clock</span>(<span class="hljs-params">fmt=DEFAULT_FMT</span>):</span> <span class="hljs-comment"># clock是参数化装饰器工厂函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorate</span>(<span class="hljs-params">func</span>):</span> <span class="hljs-comment"># decorate 是真正的装饰器</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clocked</span>(<span class="hljs-params">*_args</span>):</span> <span class="hljs-comment"># clocked 包装被装饰的函数</span><br>            t0 = time.time()<br>            _result = func(*_args)<span class="hljs-comment"># _result 是被装饰的函数返回的真正结果 </span><br>            elapsed = time.time() - t0<br>            name = func.__name__<br>            args = <span class="hljs-string">&#x27;, &#x27;</span>.join(<span class="hljs-built_in">repr</span>(arg) <span class="hljs-keyword">for</span> arg <span class="hljs-keyword">in</span> _args) <br>            result = <span class="hljs-built_in">repr</span>(_result) <br>            <span class="hljs-built_in">print</span>(fmt.<span class="hljs-built_in">format</span>(**<span class="hljs-built_in">locals</span>())) <span class="hljs-comment"># **locals()是为了在fmt中引用clocked的局部变量</span><br>            <span class="hljs-keyword">return</span> _result <br><span class="hljs-keyword">return</span> clocked <br><span class="hljs-keyword">return</span> decorate <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><span class="hljs-meta">@clock(<span class="hljs-params">DEFAULT_FMT</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">snooze</span>(<span class="hljs-params">seconds</span>):</span><br>time.sleep(seconds)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>snooze(<span class="hljs-number">.123</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Fluent Python》笔记 字符和字节</title>
    <link href="/2022/12/12/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E8%8A%82/"/>
    <url>/2022/12/12/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<h2 id="编码和解码"><a href="#编码和解码" class="headerlink" title="编码和解码"></a>编码和解码</h2><p>文本是用字符串来表示的，一个字符串是一个<strong>字符（Unicode字符）序列</strong>。<strong>码位</strong>是字符的标识，是0<del>1114111的数字。例如“A”的码位为“U+0041”（在Unicode 标准中以 4</del>6 个十六进制数字表示， 而且加前缀“U+”）。字符的具体表述取决于所用的编码，不同的编码标准会将字符（严谨讲是码位）转换成相应的字节序列。解码即是编码的逆向过程，将字节序列转换为码位。</p><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><p>Python内置有两种二进制序列类型：<code>bytes</code>（字节序列）和<code>bytearray</code>（字节数组）。</p><blockquote><p>bytes和bytearray对象的各个元素是在0~255之间的整数。bytes和bytearray对象的切片仍然是bytes和bytearray对象。</p></blockquote><p>二进制序列的字面量中也会存在ASCII文本，如<code>b&#39;caf\xc3\xa9</code> ，其中<code>caf</code>是在可打印的ASCII范围内的字节，显示ASCII字符本身，而后面<code>\xc3\xa9</code>两个字节不可打，使用十六进制转义序列。</p><p><code>struct</code>模块提供了一些函数， 把打包的字节序列转换成不同类型字段组成的元组。</p><h2 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h2><p>Python自带了超100种编解码器，用于在文本和字节之间相互转换。</p><p>下图展示了不同编码器对相同字符编码的差异。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221212093521302.png" alt="image-20221212093521302"></p><blockquote><p>UTF系列编码能处理每一个Unicode 码位。</p></blockquote><p>一些典型编码：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>latin1</td><td>一种重要的编码， 是其他编码的基础。</td></tr><tr><td>cp1252</td><td>Microsoft 制定的 latin1 超集， 添加了有用的符号， 例如弯引号和€（欧元）</td></tr><tr><td>cp437</td><td>IBM PC 最初的字符集， 包含框图符号。</td></tr><tr><td>gb2312</td><td>用于编码简体中文的陈旧标准。</td></tr><tr><td>utf-8</td><td>Web 中最常见的 8 位编码。</td></tr><tr><td>utf-16le</td><td>UTF-16 的 16 位编码方案的一种形式。</td></tr></tbody></table><h2 id="编码异常"><a href="#编码异常" class="headerlink" title="编码异常"></a>编码异常</h2><ul><li><p><code>UnicodeEncodeError</code>  </p><p>把文本转换成字节序列时， 如果目标编码中没有定义某个字符， 那就会抛出<code>UnicodeEncodeError</code> 异常。解决方法是：把<code>errors</code> 参数传给编码方法或函数， 对错误进行特殊处理。</p></li><li><p><code>UnicodeDecodeError</code>  </p><p>把二进制序列转换成文本时， 遇到无法转换的字节序列时会抛出<code>UnicodeDecodeError</code> 。同样也可以通过设置<code>errors</code>解决报错问题。</p></li><li><p><code>SyntaxError</code></p><p>Python 3 默认使用 UTF-8 编码源码。如果加载的 .py 模块中包含 UTF-8 之外的数据， 而且没有声明编码，就会抛出<code>SyntaxError</code>。一种解决方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># coding: cp1252</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Olá, Mundo!&#x27;</span>)<br></code></pre></td></tr></table></figure><p>通过添加coding注释指定源码编码方式。</p></li></ul><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>UTF-16编码中，在编码结果开头可能会生成几个额外的字节，这几个额外的字节叫做BOM，即字节序标记（byte-order mark）。字节序分为小字节序和大字节序。区别在于，在小字节序CPU和大字节序CPU中，单个字符的编码顺序是相反的，比如<code>&#39;E&#39;</code>的编码在小字节序CPU中编码为<code>69 0</code>，而在大字节序CPU中编码为<code>0 69</code>。 </p><blockquote><p>UTF-16有两个变种：UTF-16LE（显示使用小字节序），UTF-16BE（显示使用大字节序）。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Fluent Python》笔记 字典和集合</title>
    <link href="/2022/12/11/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"/>
    <url>/2022/12/11/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="用setdefault处理找不到的键"><a href="#用setdefault处理找不到的键" class="headerlink" title="用setdefault处理找不到的键"></a>用setdefault处理找不到的键</h2><p>对于如下两段代码，所实现的功能都是一样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> key <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> my_dict:<br>my_dict[key] = []<br>my_dict[key].append(new_value)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dict.setdefault(key, []).append(new_value)<br></code></pre></td></tr></table></figure><p>相较而言，使用<code>setdefault</code>来处理字典中不存在的键时，更加优雅。</p><h2 id="用defaultdict处理找不到的键"><a href="#用defaultdict处理找不到的键" class="headerlink" title="用defaultdict处理找不到的键"></a>用defaultdict处理找不到的键</h2><p><code>defaultdict</code>是一个字典类型。对于上面代码中解决的键不存在问题，我们可以用<code>defaultdict</code>类型解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">my_dd = collections.defaultdict(<span class="hljs-built_in">list</span>)<br>my_dd[key].append(new_value)<br></code></pre></td></tr></table></figure><p>当表达式<code>my_dd[key]</code>中键<code>key</code>不存在时，会进行如下步骤：</p><p>(1) 调用<code>list()</code>来建立一个新列表。<br>(2) 把这个新列表作为值， <code>key</code>作为它的键， 放到<code>my_dd</code>中。<br>(3) 返回这个列表的引用。  </p><h2 id="特殊方法-missing"><a href="#特殊方法-missing" class="headerlink" title="特殊方法_missing_"></a>特殊方法_<em>missing</em>_</h2><p>所有的映射类型（如<code>dict</code>）在处理不存在的键时，都会调用到<code>__missing__</code>方法。</p><p>下面这个示例是定义了一个<code>StrKeyDict0</code>类，在查询过程中会将非字符串的键转换成字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># BEGIN STRKEYDICT0</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrKeyDict0</span>(<span class="hljs-params"><span class="hljs-built_in">dict</span></span>):</span>  <span class="hljs-comment"># 继承了dict</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__missing__</span>(<span class="hljs-params">self, key</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(key, <span class="hljs-built_in">str</span>):  <span class="hljs-comment"># 如果不存在的键是字符串，抛出异常</span><br>            <span class="hljs-keyword">raise</span> KeyError(key)<br>        <span class="hljs-keyword">return</span> self[<span class="hljs-built_in">str</span>(key)]  <span class="hljs-comment"># 如果不存在的键不是字符串，将其转换成字符串后再进行查询</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, key, default=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> self[key]<br>        <span class="hljs-keyword">except</span> KeyError:<br>            <span class="hljs-keyword">return</span> default<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__contains__</span>(<span class="hljs-params">self, key</span>):</span><br>        <span class="hljs-keyword">return</span> key <span class="hljs-keyword">in</span> self.keys() <span class="hljs-keyword">or</span> <span class="hljs-built_in">str</span>(key) <span class="hljs-keyword">in</span> self.keys() <br><br><span class="hljs-comment"># END STRKEYDICT0</span><br></code></pre></td></tr></table></figure><p>代码中<code>__missing__</code>方法只会被<code>__getitem__</code>方法调用，即当<code>d[k]</code>中<code>k</code>键不存在时会被调用。而<code>get</code> 或者<code>__contains__</code>（in 运算符会用调用这个方法） 这些方法遇到不在存在键时则不会被调用。  所以为了能满足程序需求，上述代码中重写了<code>get</code>和<code>__contains__</code>方法，使其能够应对键为非字符串的情况。</p><h2 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h2><ul><li><p><code>collections.defaultdict</code></p><p>在构造时可以提供一个可调用对象（如上述代码中的<code>list</code>），当<code>d[k]</code>中<code>k</code>不存在时会被调用并返回某种默认值（如 <code>k:[]</code>）。</p></li><li><p><code>collections.OrderedDict</code> </p><p>这个类型在添加键的时候会保持顺序， 因此键的迭代次序总是一致的。 <code>OrderedDict</code> 的 <code>popitem</code> 方法默认删除并返回的是字典里的最后一个元素， 但是如果像 <code>my_odict.popitem(last=False)</code> 这样调用它， 那么它删除并返回第一个被添加进去的元素。</p></li><li><p><code>collections.ChainMap</code></p><p>这个类型可以容纳数个不同的映射对象， 然后在进行键查找操作的时候，这些对象会被当作一个整体被逐个查找，直到键被找到为止。</p></li><li><p><code>collections.Counter</code>  </p><p>这个类型会给键准备一个整数计数器。 每次更新一个键的时候都会增加这个计数器。<code>most_common([n])</code> 会按照次序返回映射里最常见的 <code>n</code> 个键和它们的计数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>ct = collections.Counter(<span class="hljs-string">&#x27;abracadabra&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>ct<br>Counter(&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;r&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">1</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>ct.update(<span class="hljs-string">&#x27;aaaaazzz&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>ct<br>Counter(&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;z&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;r&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">1</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>ct.most_common(<span class="hljs-number">2</span>)<br>[(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">10</span>), (<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-number">3</span>)]<br></code></pre></td></tr></table></figure></li><li><p><code>colllections.UserDict</code>  </p><p>跟 <code>OrderedDict、 ChainMap 和 Counter</code> 这些开箱即用的类型不同， <code>UserDict</code> 是让用户继承写子类的。当我们需要创建自定义映射类型时，通过继承UserDict类比继承dict更方便。</p></li></ul><h2 id="不可变映射类型"><a href="#不可变映射类型" class="headerlink" title="不可变映射类型"></a>不可变映射类型</h2><p>标准库中的所有映射类型都是可变的，即可以修改某个映射。在<code>types</code>模块中引入了一个封装类名叫<code>MappingProxyType</code>，一个映射对象通过这个类后，会得到一个只读的映射视图（无法通过映射视图修改原映射，除非直接对原映射进行修改）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> MappingProxyType<br><span class="hljs-meta">&gt;&gt;&gt; </span>d = &#123;<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;A&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>d_proxy = MappingProxyType(d)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d_proxy<br>mappingproxy(&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;A&#x27;</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d_proxy[<span class="hljs-number">1</span>] <br><span class="hljs-string">&#x27;A&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d_proxy[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;x&#x27;</span> <br>Traceback (most recent call last):<br>File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>TypeError: <span class="hljs-string">&#x27;mappingproxy&#x27;</span> <span class="hljs-built_in">object</span> does <span class="hljs-keyword">not</span> support item assignment<br><span class="hljs-meta">&gt;&gt;&gt; </span>d[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;B&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>d_proxy <br>mappingproxy(&#123;<span class="hljs-number">1</span>: <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;B&#x27;</span>&#125;)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d_proxy[<span class="hljs-number">2</span>]<br><span class="hljs-string">&#x27;B&#x27;</span><br>&gt;&gt;&gt;<br></code></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合本质是许多唯一对象的聚集。因此集合可用于序列对象的去重。</p><p>集合中元素必须是可散列的。<code>set</code>类型本身是不可散列的，<code>frozenset</code>类型本身是可散列的。</p><p>给定两个集合<code>a</code> 和 <code>b</code>， <code>返回的是它们的合集，</code> 得到的是交集， 而 <code>a - b</code>得到的是差集。  </p><p>由于散列表的引入，集合的查找功能非常快。</p><p>集合的字面量形如<code>&#123;1,2,3&#125;</code>，空集必须写成<code>set()</code>而非<code>&#123;&#125;</code>（Python会认为<code>&#123;&#125;</code>是空字典）。</p><h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>a &amp; b</td><td>返回集合a和集合b的交集</td></tr><tr><td>a | b</td><td>返回集合a和集合b的并集</td></tr><tr><td>a - b</td><td>返回集合a和集合b的差集</td></tr><tr><td>a ^ b</td><td>返回集合a和集合b的对称差集</td></tr><tr><td>a.isdisjoint(b)</td><td>查看集合a和集合b是否不相交（没有共同元素）</td></tr><tr><td>c in a</td><td>元素c是否属于集合a</td></tr><tr><td>a &lt;= b / a &gt;= b</td><td>集合a是否为集合b的子集/父集</td></tr><tr><td>a &lt; b / a &gt; b</td><td>集合a是否为集合b的真子集/真父集</td></tr></tbody></table><p>其他方法：a.add(c)、a.clear()、a.copy()、a.discard(c)（如果 a 里有 c 这个元素的话， 把它移除）、a.pop()、a.remove(c)等</p><blockquote><p>a、b为集合，c为元素。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Fluent Python》笔记 序列类型</title>
    <link href="/2022/12/10/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/12/10/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="内置序列类型"><a href="#内置序列类型" class="headerlink" title="内置序列类型"></a>内置序列类型</h2><p>按照序列存放元素方式的不同，可以分为：</p><ul><li><p>容器序列：<code>list、 tuple 和 collections.deque</code>。</p></li><li><p>扁平序列：<code>str、 bytes、 bytearray、 memoryview 和 array.array</code>。</p><blockquote><p>容器序列中存放的是元素对象的引用，扁平序列存放的是值。所以前者能够存放不同类型的数据，而后者只能存放单一类型数据。</p></blockquote></li></ul><p>按照序列类型能否被修改，可以分为：</p><ul><li>可变序列：<code>list、 bytearray、 array.array、 collections.deque 和 memoryview</code>。  </li><li>不可变序列：<code>tuple、 str 和 bytes</code>。  </li></ul><h2 id="列表推导和生成器表达式"><a href="#列表推导和生成器表达式" class="headerlink" title="列表推导和生成器表达式"></a>列表推导和生成器表达式</h2><p><strong>列表推导</strong>仅限于<code>list</code>对象的快捷<strong>构建</strong>，<strong>生成器表达式</strong>可以用于创建任何类型的序列。</p><h3 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h3><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;ABC&#x27;</span>]<br>a = [i * j <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<span class="hljs-comment"># 计算笛卡尔积</span><br></code></pre></td></tr></table></figure><h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>生成器表达式和列表推导语法相似，不同之处在于前者为圆括号，后者为方括号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">symbols = <span class="hljs-string">&#x27;$¢£¥€¤&#x27;</span><br><span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">ord</span>(symbol) <span class="hljs-keyword">for</span> symbol <span class="hljs-keyword">in</span> symbols)<br></code></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组除了为不可变列表外，还具有如下理解。</p><ul><li><p><font color=gray><b>元组的记录功能</b></font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">lax_coordinates = (<span class="hljs-number">33.9425</span>, -<span class="hljs-number">118.408056</span>)<br>city, year, pop, chg, area = (<span class="hljs-string">&#x27;Tokyo&#x27;</span>, <span class="hljs-number">2003</span>, <span class="hljs-number">32450</span>, <span class="hljs-number">0.66</span>, <span class="hljs-number">8014</span>)<br>traveler_ids = [(<span class="hljs-string">&#x27;USA&#x27;</span>, <span class="hljs-string">&#x27;31195855&#x27;</span>), (<span class="hljs-string">&#x27;BRA&#x27;</span>, <span class="hljs-string">&#x27;CE342567&#x27;</span>), (<span class="hljs-string">&#x27;ESP&#x27;</span>, <span class="hljs-string">&#x27;XDA205856&#x27;</span>)]<br></code></pre></td></tr></table></figure><p>元组的记录功能体现在，元组可以将一个对象的所有信息<strong>打包</strong>起来，这样这些信息就和对象个体实现了<strong>绑定</strong>的操作，在多个对象间进行操作时，不会将个体所携带的信息丢失。</p></li><li><p><font color=gray><b>元组拆包</b></font></p><p>普通拆包操作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">lax_coordinates = (<span class="hljs-number">33.9425</span>, -<span class="hljs-number">118.408056</span>)<br>latitude, longitude = lax_coordinates <span class="hljs-comment"># 元组拆包  </span><br></code></pre></td></tr></table></figure><p><code>* </code>运算符，将可迭代对象拆开作为函数参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">t = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>func(*t)// 等同func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><code>*args </code>获取不确定数量参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a, b, *rest = <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a, b, rest<br>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>a, *body, c, d = <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>a, body, c, d<br>(<span class="hljs-number">0</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure></li><li><p><font color=gray><b>嵌套元组拆包</b></font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">i, j, (k, l) = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br></code></pre></td></tr></table></figure></li><li><p><font color=gray><b>具名元组</b></font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> namedtuple<br><span class="hljs-meta">&gt;&gt;&gt; </span>City = namedtuple(<span class="hljs-string">&#x27;City&#x27;</span>, <span class="hljs-string">&#x27;name country population coordinates&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>tokyo = City(<span class="hljs-string">&#x27;Tokyo&#x27;</span>, <span class="hljs-string">&#x27;JP&#x27;</span>, <span class="hljs-number">36.933</span>, (<span class="hljs-number">35.689722</span>, <span class="hljs-number">139.691667</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>tokyo<br>City(name=<span class="hljs-string">&#x27;Tokyo&#x27;</span>, country=<span class="hljs-string">&#x27;JP&#x27;</span>, population=<span class="hljs-number">36.933</span>, coordinates=(<span class="hljs-number">35.689722</span>,<br><span class="hljs-number">139.691667</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>tokyo.population<br><span class="hljs-number">36.933</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>tokyo.coordinates<br>(<span class="hljs-number">35.689722</span>, <span class="hljs-number">139.691667</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>tokyo[<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;JP</span><br></code></pre></td></tr></table></figure><p>具名元组可以理解为一个只有属性没有方法的类对象，创建时接收两个参数：一个是类名，一个是类的各个属性的名字。</p></li></ul><h2 id="高级切片"><a href="#高级切片" class="headerlink" title="高级切片"></a>高级切片</h2><ul><li><p><font color=gray><b>间隔取值</b></font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">&#x27;bicycle&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s[::<span class="hljs-number">3</span>]<br><span class="hljs-string">&#x27;bye&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s[::-<span class="hljs-number">1</span>]<br><span class="hljs-string">&#x27;elcycib&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s[::-<span class="hljs-number">2</span>]<br><span class="hljs-string">&#x27;eccb&#x27;</span><br></code></pre></td></tr></table></figure><p><code>s[a:b:c]</code> 的形式对 <code>s</code> 在 <code>a</code> 和 <code>b</code>之间以 <code>c</code> 为间隔取值。 <code>c</code> 的值为负表示反向取值。</p></li><li><p><font color=gray><b>多维切片和省略符</b></font></p><p><code>[a:b, c:d, e:f]</code>三维切片。</p><p><code>x[i, ...]</code>为<code>x[i, :, :, :]</code>的缩写。</p></li><li><p><font color=gray><b>切片赋值</b></font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>l = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>l<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>l[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>] = [<span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>l<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> l[<span class="hljs-number">5</span>:<span class="hljs-number">7</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>l<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>l[<span class="hljs-number">3</span>::<span class="hljs-number">2</span>] = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>l<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>, <span class="hljs-number">22</span>, <span class="hljs-number">9</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>l[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>] = [<span class="hljs-number">100</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>l<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">22</span>, <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>如果赋值对象是一个切片，<code>=</code>右边也必须是个可迭代对象。</p></li></ul><h2 id="list-sort方法和内置函数sorted"><a href="#list-sort方法和内置函数sorted" class="headerlink" title="list.sort方法和内置函数sorted"></a>list.sort方法和内置函数sorted</h2><p><code>list.sort</code>方法是对列表对象就地改动，即不会返回新列表，而是直接对原列表改变。内置函数<code>sorted</code>会新建一个列表返回。</p><h2 id="用bisect来管理已排序的序列"><a href="#用bisect来管理已排序的序列" class="headerlink" title="用bisect来管理已排序的序列"></a>用bisect来管理已排序的序列</h2><p><code>bisect.bisect(seq, item)</code>返回元素<code>item</code>插入到已排序序列<code>seq</code>中的位置索引。如果<code>item</code>在<code>seq</code>中已出现，那么插入到那个出现的值的右侧，<code>bisect_left</code>插入在左侧。</p><p><code>bisect.insort(seq, item)</code>返回<code>item</code>插入序列<code>seq</code>中，并保持整个序列升序。</p><h2 id="其他序列类型"><a href="#其他序列类型" class="headerlink" title="其他序列类型"></a>其他序列类型</h2><ul><li><p><strong>数组（array）</strong></p><p>对于只存放数字的序列，array比list更高效。</p></li><li><p><strong>内存视图（memoryview）</strong></p><p>用户可以在不复制内容的情况下操作同一个数组的不同切片。</p></li><li><p><strong>双向队列（collections.deque）</strong></p><p>双向队列，一个能够从两端添加或者删除元素的序列类型。对于大小固定的队列，满员后添加一个元素会在反向端删除一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq = deque(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>), maxlen=<span class="hljs-number">10</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq<br>deque([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], maxlen=<span class="hljs-number">10</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq.rotate(<span class="hljs-number">3</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq<br>deque([<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], maxlen=<span class="hljs-number">10</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq.rotate(-<span class="hljs-number">4</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq<br>deque([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>], maxlen=<span class="hljs-number">10</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq.appendleft(-<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq<br>deque([-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], maxlen=<span class="hljs-number">10</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq.extend([<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq<br>deque([<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>], maxlen=<span class="hljs-number">10</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq.extendleft([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>dq<br>deque([<span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>], maxlen=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure></li><li><p><strong>队列（queue）</strong></p><p>与双向列表不同，固定大小的队列满员后，其中元素将被锁住无法进行添加，知道某个线程移除某个元素腾出位置。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Fluent Python》笔记 数据模型</title>
    <link href="/2022/12/09/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/12/09/%E3%80%8AFluent%20Python%E3%80%8B%E7%AC%94%E8%AE%B0%20%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>本章主要围绕Python的<strong>特殊方法</strong>进行介绍，通过实现特殊方法利用Python数据模型。</p><p>首先看两个例子：</p><ul><li>一个表示一副扑克牌的类。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><br>Card = collections.namedtuple(<span class="hljs-string">&#x27;Card&#x27;</span>, [<span class="hljs-string">&#x27;rank&#x27;</span>, <span class="hljs-string">&#x27;suit&#x27;</span>])<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FrenchDeck</span>:</span><br>    ranks = [<span class="hljs-built_in">str</span>(n) <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">11</span>)] + <span class="hljs-built_in">list</span>(<span class="hljs-string">&#x27;JQKA&#x27;</span>)<br>    suits = <span class="hljs-string">&#x27;spades diamonds clubs hearts&#x27;</span>.split()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self._cards = [Card(rank, suit) <span class="hljs-keyword">for</span> suit <span class="hljs-keyword">in</span> self.suits<br>                       <span class="hljs-keyword">for</span> rank <span class="hljs-keyword">in</span> self.ranks]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self._cards)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, position</span>):</span><br>        <span class="hljs-keyword">return</span> self._cards[position]<br></code></pre></td></tr></table></figure><ul><li>一个表示二维向量的类。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> hypot<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vector</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span></span>):</span><br>        self.x = x<br>        self.y = y<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Vector(%r, %r)&#x27;</span> % (self.x, self.y)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__abs__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> hypot(self.x, self.y)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__bool__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">bool</span>(<span class="hljs-built_in">abs</span>(self))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__add__</span>(<span class="hljs-params">self, other</span>):</span><br>        x = self.x + other.x<br>        y = self.y + other.y<br>        <span class="hljs-keyword">return</span> Vector(x, y)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__mul__</span>(<span class="hljs-params">self, scalar</span>):</span><br>        <span class="hljs-keyword">return</span> Vector(self.x * scalar, self.y * scalar)<br></code></pre></td></tr></table></figure><p>上面两个类中，实现的形如<code>__xxx__</code>的方法都叫做<strong>特殊方法</strong>。在自定义的数据类型中实现这些特殊方法的用处在于，可以使其变得和Python中的内置类型（比如list）一样，能够具有内置类型的一些性质（如list的切片索引）和使用标准库中的一些算法（如random.choice()）。举个例子，如果在自定义类<code>A</code>中实现了<code>__len__</code>特殊方法，那么可以通过Python内置方法<code>len(A)</code>得到<code>A</code>对象的大小，而不是在<code>A</code>中写一个<code>size()</code>普通方法，然后通过<code>A.size()</code>进行调用，为此我们需要记住每个数据类中返回其元素总数的方法名称，没有前者实用和便捷。</p><p>我们要明确，<strong>特殊方法的存在是为了被Python解释器调用</strong>，在代码中我们一般并不需要对其进行形如<code>A.__getitem__()</code>的调用。很多情况下，特殊方法的调用时隐式的，如当我们使用内置函数（例如len、str等）时，解释器就会调用对应的特殊方法（例如<code>__len__、__str__</code>等）。</p><p>示例代码中的一些特殊方法作用如下：</p><ul><li><p><code>__repr__</code>：把一个对象用字符串形式进行表达，即返回一个对象的字符串表示形式。</p></li><li><p><code>__str__</code>：返回一个对象的字符串表示形式，相较于<code>__repr__</code>其返回的字符串更适合打印到终端。</p><blockquote><p>如果一个对象没有<code>__str__</code>函数，Python解释器会调用<code>__repr__</code>作为替代。</p></blockquote></li><li><p><code>__add__</code>：能够实现自定义数据类型的<code>+</code>运算。</p></li><li><p><code>__mul__</code>：能够实现自定义数据类型的<code>*</code>运算。</p></li><li><p><code>__bool__</code>：定义自定义数据类型什么时候为True或False。</p></li></ul><p>关于更多特殊方法的信息详见：<a href="https://docs.python.org/3/reference/datamodel.html">3. Data model — Python 3.11.1 documentation</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++泛型学习笔记】万能引用、完美转发和常用标准库模板</title>
    <link href="/2022/12/08/%E3%80%90C++%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E3%80%81%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E5%92%8C%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/12/08/%E3%80%90C++%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E3%80%81%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E5%92%8C%E5%B8%B8%E7%94%A8%E6%A0%87%E5%87%86%E5%BA%93%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学习参考书籍：王健伟《C++新经典：模板与泛型编程》</p></blockquote><h2 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h2><p><strong>万能引用</strong>是一种<strong>类型</strong>，同int一样。万能引用既可以接受左值，又可以接受右值。</p><blockquote><p>右值引用：    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span> &amp;b = a;  <span class="hljs-comment">// 左值引用类型变量b</span><br></code></pre></td></tr></table></figure><p>左值引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> &amp;&amp;b = <span class="hljs-number">3</span>;  <span class="hljs-comment">// 右值引用类型变量b</span><br></code></pre></td></tr></table></figure><p><strong>左值和右值</strong>的区分：</p><ul><li>可以取地址的（如存在内存中），有名字的（有标识符），非临时的就是左值；</li><li>不能取地址的（如存在寄存器中），没有名字的（没有标识符），临时的就是右值；</li></ul></blockquote><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;&amp;tmprv)</span><span class="hljs-comment">// 参数tmprv是一个右值引用类型（int &amp;&amp;），只能传入右值引用类型的实参，传入左值引用类型实参将会报错</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; tmprv &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(T&amp;&amp; tmprv)</span><span class="hljs-comment">// 参数tmprv是一个万能引用类型（T&amp;&amp;），既可以传入右值引用类型参数，也可以传入左值引用类型参数</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; tmprv &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>参数成为<strong>万能引用</strong>（也叫做未定义引用）类型必须满足如下条件：</p><ul><li>必须是<strong>函数模板</strong>；</li><li>必须是发生了模板参数<strong>类型推断</strong>并且函数模板参数形如T&amp;&amp;。</li></ul><blockquote><p>在 <code>T&amp;&amp;</code> 前加 <code>const</code> 关键字进行修饰，会将万能引用退化为右值引用。</p></blockquote><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>完美转发概念：从主函数中调用函数A，通过函数A调用函数B，这个过程叫做<strong>转发</strong>。函数A作为<strong>跳板函数</strong>，将主函数出入的参数传递给函数B。在普通转发过程中，参数的某些类型信息（如const属性、左值或右值属性）会丢失。而<strong>完美转发</strong>能够使在转发过程中参数的类型信息不丢失。</p><p>函数形参的完美转发：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">A</span><span class="hljs-params">(F B, T&amp;&amp; t)</span><span class="hljs-comment">// t为万能引用类型</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">B</span>(std::forward&lt;T&gt;(t));<br>&#125;<br></code></pre></td></tr></table></figure><p>上述完美转发实现方式为：通过一个函数模板A，可以把任意函数名B、任意类型参数传递给函数模板A，从而达到间接调用任意函数B的目的。<code>std::forward&lt;T&gt;(t)</code>是C++标准库中的函数，作用是<strong>保持函数模板输入原始实参的左值性或右值性</strong>，实现函数形参的完美转发。</p><h2 id="常用标准库模板"><a href="#常用标准库模板" class="headerlink" title="常用标准库模板"></a>常用标准库模板</h2><ul><li><p><code>std::declval</code></p><blockquote><p>作用：</p><ol><li>将一个类型转换成右值引用类型。</li><li>配合decltype，让在decltype表达式中不必经过类类型的构造函数（不创建类对象）就能使用该类型的成员函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">decltype</span>(std::declval&lt;A&gt;().<span class="hljs-built_in">Afunc</span>());<br></code></pre></td></tr></table></figure></blockquote></li><li><p><code>std::true_type和std::false_type</code></p><blockquote><p><code>std::true_type/std::false_type</code>为类型别名（类类型），代表一个类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> true_type = integral_constant&lt;<span class="hljs-keyword">bool</span>, <span class="hljs-literal">true</span>&gt;<br><span class="hljs-keyword">using</span> false_type = integral_constant&lt;<span class="hljs-keyword">bool</span>, <span class="hljs-literal">false</span>&gt;<br></code></pre></td></tr></table></figure><p>作用：该类型在trait技术中应用广泛。</p></blockquote></li><li><p><code>std::void_t</code></p><blockquote><p>C++17别名模板，应用：</p><ul><li><p><strong>判断类中是否存在某个类型别名</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NoInnerType</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> m_i;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HaveInnerType</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">int</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// 类模板泛化版本</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U = std::<span class="hljs-keyword">void_t</span>&lt;&gt;&gt;<br>struct HasTypeMem : std::false_type<br>&#123;<br>    <br>&#125;;<br><br><span class="hljs-comment">// 偏特化版本</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HasTypeMem</span>&lt;</span>T, std::<span class="hljs-keyword">void_t</span>&lt;<span class="hljs-keyword">typename</span> T::type&gt;&gt; : std::true_type<br>&#123;<br>    <br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; HasTypeMem&lt;NoInnerType&gt;::value &lt;&lt; endl;<span class="hljs-comment">// 调用泛化版本</span><br>    cout &lt;&lt; HasTypeMem&lt;HaveInnerType&gt;::value &lt;&lt; endl;<span class="hljs-comment">// 调用偏特化版本</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>判断类中是否存在某个成员变量</strong></p><p>改写上述偏特化版本实现，其他代码不变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 偏特化版本</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HasTypeMem</span>&lt;</span>T, std::<span class="hljs-keyword">void_t</span>&lt;<span class="hljs-keyword">decltype</span>(T::m_i)&gt; : std::true_type<br>&#123;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>判断类中是否存在某个成员函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HasTypeMem</span>&lt;</span>T, std::<span class="hljs-keyword">void_t</span>&lt;<span class="hljs-keyword">decltype</span>(std::declval&lt;T&gt;().<span class="hljs-built_in">func</span>())&gt; : std::true_type<br></code></pre></td></tr></table></figure></li></ul></blockquote></li><li><p><code>std::conditional</code></p><blockquote><p>C++11类模板，表现编译期的分支逻辑。实现代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">bool</span> b, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">U</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">conditional</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">using</span> type = T;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title">U</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">conditional</span>&lt;</span><span class="hljs-literal">false</span>, T, U&gt;<br>&#123;<br>    <span class="hljs-keyword">using</span> type = U;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>std::conditional&lt;true, A, B&gt;::type</code>返回A；<code>std::conditional&lt;false, A, B&gt;::type</code>返回B，类似于<code>if-then-else</code>逻辑。</p></blockquote></li><li><p><code>std::function</code></p><blockquote><p>可调用对象包装器，C++11类模板。</p></blockquote></li><li><p><code>std::remove_all_extents</code></p><blockquote><p>C++11类模板，功能为把一个数组中的数组类型部分移除，只保留元素类型。即int[10]变为int。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];<br>std::remove_all_extents&lt;<span class="hljs-keyword">decltype</span>(a)&gt;;<br></code></pre></td></tr></table></figure></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++泛型学习笔记】模板基础知识补充</title>
    <link href="/2022/12/07/%E3%80%90C++%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%A8%A1%E6%9D%BF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
    <url>/2022/12/07/%E3%80%90C++%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E6%A8%A1%E6%9D%BF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学习参考书籍：王健伟《C++新经典：模板与泛型编程》</p></blockquote><h2 id="奇异的递归模板模式"><a href="#奇异的递归模板模式" class="headerlink" title="奇异的递归模板模式"></a>奇异的递归模板模式</h2><p><strong>派生类作为基类的模板参数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>// 基类模板</span><br><span class="hljs-class">&#123;</span><br>    <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> :</span> <span class="hljs-keyword">public</span> A&lt;B&gt;<span class="hljs-comment">// 派生普通类</span><br>&#123;<br>    <br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> :</span> <span class="hljs-keyword">public</span> A&lt;C&lt;T&gt;&gt;<span class="hljs-comment">// 派生类模板</span><br>&#123;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><p>应用：</p><ul><li>在基类中使用派生类对象。</li><li>通过友元函数将派生类的一些重复代码在基类中实现，减少派生类代码量。</li><li>基类中调用派生类接口。</li></ul><h2 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h2><p><strong>将传入的模板参数作为该类模板的父类</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> :</span> <span class="hljs-keyword">public</span> T...<br>&#123;<br>    <span class="hljs-built_in">A</span>() : <span class="hljs-built_in">T</span>()... &#123;&#125;<span class="hljs-comment">// 继承父类的构造函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模板代码组织结构"><a href="#模板代码组织结构" class="headerlink" title="模板代码组织结构"></a>模板代码组织结构</h2><p>只有当模板被源程序调用时，编译器才会根据调用传入的模板参数实例化对应模板，进而生成相关代码。编译器在生成代码时，需要能够找到模板的代码实现部分，故**(类)模板的定义和实现通常都放在.h头文件中**，不能分成不同文件进行编写。对于特化版本，应该紧跟在泛化版本之后编写。</p><h2 id="模板显示实例化"><a href="#模板显示实例化" class="headerlink" title="模板显示实例化"></a>模板显示实例化</h2><p>试想一下，每当使用模板时，编译器就会对其实例化一次，那么如果多个不同源文件中对对同一个模板进行相同模板参数的实例化，那么整个编译过程和结果就会变得非常冗余，没必要做重复性的工作。所以我们可以通过在一个源文件中对模板进行实例化定义，在其他源文件中对实例化进行声明（声明这个具体类型的模板已经在其他文件中实例化过了，所以本文件中不再进行实例化），以此（显示实例化）来解决上述问题。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> A&lt;<span class="hljs-keyword">int</span>&gt;;<span class="hljs-comment">// 类模板的实例化定义</span><br><span class="hljs-function"><span class="hljs-keyword">template</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">float</span> b)</span></span>;<span class="hljs-comment">// 函数模板的实例化定义</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> A&lt;<span class="hljs-keyword">int</span>&gt;;<span class="hljs-comment">// 类模板的实例化声明</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">float</span> b)</span></span>;<span class="hljs-comment">// 函数模板的实例化声明</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++泛型学习笔记】友元、可变参模板</title>
    <link href="/2022/12/06/%E3%80%90C++%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8F%8B%E5%85%83%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/12/06/%E3%80%90C++%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%8F%8B%E5%85%83%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学习参考书籍：王健伟《C++新经典：模板与泛型编程》</p></blockquote><h2 id="类模板中的友元"><a href="#类模板中的友元" class="headerlink" title="类模板中的友元"></a>类模板中的友元</h2><p>友元，即若A为B的友元，那么A可以访问B中的所有成员（任何修饰符修饰）。</p><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p><B><font color=gray>1.类模板的实例成为友元类</font></b></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&lt;</span><span class="hljs-keyword">long</span>&gt;;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> data;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">callBAF</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>A&lt;<span class="hljs-keyword">int</span>&gt; atmpobj;<br>atmpobj.data = <span class="hljs-number">5</span>;<br>cout &lt;&lt; atmpobj.data &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>B&lt;<span class="hljs-keyword">long</span>&gt; bobj;<br>bobj.<span class="hljs-built_in">callBAF</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面例子中，我们让类模板<code>B</code>的实例<code>B&lt;long&gt;</code>成为类模板A的友元类，因此可以在实例<code>B&lt;long&gt;</code>中访问类模板<code>A</code>的私有变量<code>data</code>。需要注意的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><span class="hljs-comment">// 在类模板A的定义前增加类模板B的声明</span><br><span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&lt;</span><span class="hljs-keyword">long</span>&gt;;<span class="hljs-comment">// 在类模板A中声明友元类B&lt;long&gt;</span><br></code></pre></td></tr></table></figure><p><B><font color=gray>2.类模板成为友元类模板</font></b></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//template&lt;typename U&gt; class B;</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-comment">//friend class B&lt;long&gt;;</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">int</span> data;<br>&#125;;<br></code></pre></td></tr></table></figure><p><B><font color=gray>3.类型模板参数成为友元类</font></b></p><p>让某个模板将其为<strong>类</strong>类型的模板参数作为其友元类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">friend</span> T;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">callBAF</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        A&lt;B&gt; aobj;<span class="hljs-comment">// 将类作为模板参数传入类模板A</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p><B><font color=gray>1.函数模板的实例成为友元函数</font></b></p><p>若将实例化后的模板函数<code>func&lt;int,int&gt;</code>作为普通类<code>A</code>的友元函数，语法如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> func&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;(<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>);<span class="hljs-comment">// 在普通类A中添加函数模板实例化对象为友元函数</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span> V&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(U val1, V val2)</span></span>;<span class="hljs-comment">// 在普通类A定义前增加函数模板的声明，和类实例成为友元类一样</span><br></code></pre></td></tr></table></figure><p><B><font color=gray>2.函数模板成为友元函数模板</font></b></p><p>若我们想让函数模板的所有实例都成为类A的友元函数，那么我们直接将函数模板作为类A的友元模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span> V&gt; <span class="hljs-keyword">friend</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(U val1,V val2)</span></span>;<span class="hljs-comment">// 在普通类A中添加函数模板为友元模板</span><br></code></pre></td></tr></table></figure><p>和类模板成为友元模板一样，在类A的的定义前毋需声明模板。</p><h2 id="可变参模板"><a href="#可变参模板" class="headerlink" title="可变参模板"></a>可变参模板</h2><p>可变参模板运行模板定义中含有0到多个模板参数。</p><h3 id="可变参函数模板"><a href="#可变参函数模板" class="headerlink" title="可变参函数模板"></a>可变参函数模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;<span class="hljs-comment">// typename...代表参数包</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myfunc</span><span class="hljs-params">(T... args)</span><span class="hljs-comment">// T: 一包类型，args：一包形参。T后面加...代表T为可变参类型</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>...(args) &lt;&lt; endl;<span class="hljs-comment">// 函数接收到的形参数量</span><br>cout &lt;&lt; <span class="hljs-keyword">sizeof</span>...(T) &lt;&lt; endl;<span class="hljs-comment">// 函数接收到的类型数量</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">myfunc</span>(<span class="hljs-number">25</span>, <span class="hljs-string">&quot;mstifiy&quot;</span>, <span class="hljs-number">0.7</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>sizeof...</code>用于表示收到模板参数个数和类型数量，固定语法，C++11引入。</p></blockquote><p>为了将接收到的参数解包，使用递归调用实现。</p><p><b><font color= gray>方式一：参数包展开函数+同名递归终止函数</font></b></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myfunc</span><span class="hljs-params">()</span><span class="hljs-comment">// 同名的递归终止函数</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;参数包解包递归函数终止&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myfunc</span><span class="hljs-params">(T firstarg, U... otherargs)</span><span class="hljs-comment">// 参数包展开函数</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;收到的参数值为：&quot;</span> &lt;&lt; firstarg &lt;&lt; endl;<br><span class="hljs-built_in">myfunc</span>(otherargs...);<span class="hljs-comment">// 递归调用，实现参数的解包</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>递归终止函数必须在递归展开函数前定义，否则报错。</p></blockquote><p><b><font color= gray>方式二：constexpr if</font></b></p><p>C++17标准中引入了<strong>编译期间if语句</strong>，即在编译时只有满足条件代码才会被编译。重写myfunc函数模板如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myfunc</span><span class="hljs-params">(T firstarg, U... otherargs)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;收到的参数值为：&quot;</span> &lt;&lt; firstarg &lt;&lt; endl;<br><span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(<span class="hljs-keyword">sizeof</span>...(otherargs) &gt; <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">myfunc</span>(otherargs...);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;参数包解包递归函数终止&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h3><p>折叠表达式的引入方便了需要所有可变参数参与计算才能得到的表达式结果的书写，即不用像上述一样将可变参数包解包再计算，而是可以直接通过简短的折叠表达式进行计算。折叠表达式一般有四种格式，每种格式都是用<strong>圆括号</strong>括起来的。参数从左侧开始计算叫<strong>左折</strong>，从右侧开始计算叫<strong>右折</strong>。</p><p><b><font color= gray>1.一元左折</font></b></p><p>格式：<code>(... 运算符 一包参数)</code></p><p>计算方式：<code>(((参数1 运算符 参数2) 运算符 参数3) ··· 运算符 参数N)</code></p><p><b><font color= gray>2.一元右折</font></b></p><p>格式：<code>(一包参数 运算符 ...)</code></p><p>计算方式：<code>(参数1 运算符 (··· (参数N-1 运算符 参数N)))</code></p><p><b><font color= gray>3.二元左折</font></b></p><p>格式：<code>(init 运算符 ... 运算符 一包参数)</code></p><p>计算方式：<code>(((init 运算符 参数1) 运算符 参数2) ··· 运算符 参数N)</code></p><p><b><font color= gray>4.二元右折</font></b></p><p>格式：<code>(一包参数 运算符 ... 运算符 init)</code></p><p>计算方式：<code>(参数1 运算符 (··· (参赛N 运算符 init)))</code></p><h3 id="可变参表达式"><a href="#可变参表达式" class="headerlink" title="可变参表达式"></a>可变参表达式</h3><p>折叠表达式主要体现的是参数之间的运算，当需要让可变参数本身进行一些运算时，可以使用可变参表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">func</span>((args * <span class="hljs-number">2</span>) ...) <span class="hljs-comment">// 等价于func(arg1*2,arg2*2,...,argN*2)</span><br></code></pre></td></tr></table></figure><p>格式：<code>((可变参数自身运算) ...)</code></p><h3 id="可变参类模板"><a href="#可变参类模板" class="headerlink" title="可变参类模板"></a>可变参类模板</h3><p>模板参数列表语法和可变参函数模板一样，这里主要学习几种参数包的展开方式。</p><p><b><font color= gray>方式一：递归继承展开</font></b></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... args&gt;<span class="hljs-comment">// 类模板泛化版本</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myclasst</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myclasst</span>()<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;myclasst::myclasst()泛化版本执行了，this=%p\n&quot;</span>, <span class="hljs-keyword">this</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<span class="hljs-comment">// 0个模板参数的特化版本</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myclasst</span>&lt;</span>&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myclasst</span>()<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;myclasst::myclasst()特殊的特化版本执行了，this=%p\n&quot;</span>, <span class="hljs-keyword">this</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Others&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myclasst</span>&lt;</span>First, Others...&gt; :<span class="hljs-keyword">private</span> myclasst&lt;Others...&gt;<span class="hljs-comment">// 偏特化版本</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myclasst</span>() :<span class="hljs-built_in">m_i</span>(<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;myclasst::myclasst()偏特化版本执行了，this = %p，sizeof...(Others)=%d\n&quot;</span>, <span class="hljs-keyword">this</span>, <span class="hljs-keyword">sizeof</span>...(Others));<br>&#125;<br><br><span class="hljs-built_in">myclasst</span>(First parf, Others... paro) :<span class="hljs-built_in">m_i</span>(parf), myclasst&lt;Others...&gt;(paro...)<span class="hljs-comment">// 在初始化前先调用myclasst&lt;Others...&gt;（父类）的构造函数进行初始化</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;myclasst::myclasst(parf, ...paro)执行了,this = %p\n&quot;</span>, <span class="hljs-keyword">this</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; endl;<br>&#125;<br>First m_i;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">myclasst&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>, <span class="hljs-keyword">double</span>&gt; <span class="hljs-title">myc</span><span class="hljs-params">(<span class="hljs-number">12</span>, <span class="hljs-number">13.5f</span>, <span class="hljs-number">30.0</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于类模板可变参模板参数的展开操作，递归继承主要使用类模板的<strong>偏特化</strong>进行继承递归。对于非类型模板参数和<strong>模板模板参数</strong>，语法相似。</p><p><strong>非类型模板参数包展开</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">double</span>... args&gt;<span class="hljs-comment">// 泛化版本</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">...</span><br><span class="hljs-class"><span class="hljs-title">template</span>&lt;</span><span class="hljs-keyword">double</span> First, <span class="hljs-keyword">double</span>... Others&gt;<span class="hljs-comment">// double也可以换成auto</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;</span>First, Others...&gt; : <span class="hljs-keyword">private</span> A&lt;Others...&gt;<span class="hljs-comment">// 偏特化</span><br>...<br></code></pre></td></tr></table></figure><p><strong>模板模板参数包展开</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">typename</span>... Container&gt;<span class="hljs-comment">// 泛化版本</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">...</span><br><span class="hljs-class"><span class="hljs-title">template</span>&lt;</span><span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">typename</span> FirstContainer, <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">typename</span>... OthersContainer&gt;<span class="hljs-comment">// double也可以换成auto</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;</span>T, FirstContainer, OthersContainer...&gt; : <span class="hljs-keyword">private</span> A&lt;OthersContainer...&gt;<span class="hljs-comment">// 偏特化</span><br>...<br></code></pre></td></tr></table></figure><p><b><font color= gray>方式二：递归组合展开</font></b></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... args&gt; <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>//泛化版本</span><br><span class="hljs-class">...</span><br><span class="hljs-class"><span class="hljs-title">template</span>&lt;</span><span class="hljs-keyword">typename</span> First, <span class="hljs-keyword">typename</span>... Others&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;</span>First, Others...&gt;<span class="hljs-comment">// 偏特化</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(First parf, Others... paro) : <span class="hljs-built_in">m_i</span>(parf), <span class="hljs-built_in">m_o</span>(paro...)<br>    &#123;<br>        cout &lt;&lt; m_i &lt;&lt; endl;<br>    &#125;<br>    First m_i;<br>    A&lt;Others...&gt; m_o;<span class="hljs-comment">//增加一个m_o变量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>递归组合展开方式的思想是类的组合关系（一种包含关系）。</p><p><b><font color= gray>方式三：元组和递归调用展开</font></b></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> count, <span class="hljs-keyword">int</span> maxcount, <span class="hljs-keyword">typename</span>... T&gt; <span class="hljs-comment">// count用于统计，从0开始，maxcount表示参数数量</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> tuple&lt;T...&gt;&amp; t)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; get&lt;count&gt;(t) &lt;&lt; endl;<span class="hljs-comment">// 将每个参数从元组中取出</span><br>        A&lt;count + <span class="hljs-number">1</span>, maxcount, T...&gt;::<span class="hljs-built_in">func</span>(t); <span class="hljs-comment">// 递归调用，输出count+1，也就是下一个参数</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 偏特化版本，用于结束递归调用，必须存在</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> maxcount, <span class="hljs-keyword">typename</span>... T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&lt;</span>maxcount, maxcount, T...&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">const</span> tuple&lt;T...&gt;&amp; t)</span></span><br><span class="hljs-function">    </span>&#123;<br>       <span class="hljs-comment">// 调用该偏特化模板时，count = maxcount（可由sizeof...计算），即元组中所有参数都已取出，参数包展开完成</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">functuple</span><span class="hljs-params">(<span class="hljs-keyword">const</span> tuple&lt;T...&gt;&amp; t)</span><span class="hljs-comment">//可变参函数模板</span></span><br><span class="hljs-function"></span>&#123;<br>    A&lt;<span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>...(T), T...&gt;::<span class="hljs-built_in">func</span>(t);<span class="hljs-comment">// count为0，从元组0号位开始</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">tuple&lt;<span class="hljs-keyword">float</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">mytuple</span><span class="hljs-params">(<span class="hljs-number">1.0f</span>, <span class="hljs-number">100</span>, <span class="hljs-number">12</span>)</span></span>;<br>    <span class="hljs-built_in">functuple</span>(mytuple);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第二章模板基础知识已经学了4小节了，我个人感受是很杂和多，而且有一点难度的，这种难度主要来自于缺乏码代码的实践经验。把书翻得差不多之后，还是要多写多练才行，在动手写代码的同时，遗忘的知识点可以回过来翻书翻资料，这样学习吸收效果较佳。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++泛型学习笔记】类模板、变量模板和别名模板</title>
    <link href="/2022/12/05/%E3%80%90C++%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%B1%BB%E6%A8%A1%E6%9D%BF%E3%80%81%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%88%AB%E5%90%8D%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/12/05/%E3%80%90C++%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E7%B1%BB%E6%A8%A1%E6%9D%BF%E3%80%81%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%88%AB%E5%90%8D%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学习参考书籍：王健伟《C++新经典：模板与泛型编程》</p></blockquote><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>和函数模板一样，类模板可以理解为产生类的模具，通过给定的模板参数生成具体的类。vector容器就是一个类模板应用的例子，vector可以存放不同类型的数据类型元素，其就是通过引入类模板来减少不同类型元素存储时重复的代码，代码更加精简和通用。示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//标识符为T的模板参数，表示myvector容器所保存的元素类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myvector</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> T* myiterator;<span class="hljs-comment">// 迭代器</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myvector</span>();<span class="hljs-comment">//构造函数</span><br>    <span class="hljs-built_in">myvector</span>(T tmpt) <span class="hljs-comment">// 带参数的构造函数</span><br>    &#123;<br>        <br>    &#125;<br>myvector&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> myvector&amp;);<span class="hljs-comment">// 重载赋值运算符，在类模板中使用模板名可以不用提供模板参数，如myvector&lt;T&gt;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myfunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;mufunc() 被调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 迭代器接口</span><br><span class="hljs-function">myiterator <span class="hljs-title">mybegin</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//迭代器起始位置</span><br><span class="hljs-function">myiterator <span class="hljs-title">myend</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//迭代器结束位置</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>myvector&lt;T&gt;::<span class="hljs-built_in">myvector</span>()<span class="hljs-comment">// 类外构造函数实现</span><br>&#123;<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>myvector&lt;<span class="hljs-keyword">int</span>&gt; tempvec;<span class="hljs-comment">//T被替换成int，即指定模板参数T为int</span><br>    <span class="hljs-function">myvector <span class="hljs-title">tempvec1</span><span class="hljs-params">(<span class="hljs-number">6</span>)</span></span>;    <span class="hljs-comment">// 不用指定模板参数</span><br>tempvec.<span class="hljs-built_in">myfunc</span>();<span class="hljs-comment">//调用类模板中的普通成员函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于类模板myvector，myvector称为<strong>类名</strong>或<strong>类模板</strong>，myvector&lt;T&gt;称为<strong>类型名</strong>，其中T称为<strong>模板参数</strong>，T本身代表容器中的元素<strong>类型</strong>。在类模板内部类型名可以简写成类名，如<code>myvector&amp; operator=(const myvector&amp;);</code>，但在类模板外不可以，如<code>myvector&lt;T&gt;::myvector()</code>。</p><p>对于类模板的<strong>模板参数推导</strong>，代码<code>myvector tempvec1(6);</code> 中，我们通过调用含参数的构造函数实例化模板类，编译器通过传入的实参类型可以自动推导出T的类型。而<code>myvector&lt;int&gt; tempvec;</code>则是通过<code>类名&lt;类型&gt;</code>指定T的类型（倘若没有带参数的构造函数，T仍需指定）。实现模板参数推导的功能是通过使用<strong>推断指南</strong>（deduction guide）,其作用为<strong>推断类模板参数时提供推断指引</strong>。一般我们常见的（如上面代码中的例子）都为隐式推断指南，无需指定（前提是待传入参数的构造函数存在）编译器自动推断。当然，程序员也可以自定义推断指南（如不存在构造函数的情况）。形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">(T,T)</span>-&gt;A&lt;T&gt;</span>;<br></code></pre></td></tr></table></figure><p>对于类模板的<strong>特化</strong>。<strong>类模板的全特化</strong>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">myvector</span>&lt;</span><span class="hljs-keyword">int</span>&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myvector</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;全特化版本&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myfunc</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">void</span> myvector&lt;<span class="hljs-keyword">int</span>&gt;::<span class="hljs-built_in">myfunc</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;全特化版本的myfunc&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>myvector&lt;<span class="hljs-keyword">int</span>&gt; tempvec;<br>tempvec.<span class="hljs-built_in">myfunc</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>需要区分的是，泛化版本的类模板和全特化版本的类模板只是同名，两者实例化后的对象是完全不同的两个类，即成员属性和函数无法共享。其次对在全特化版本类模板外定义的成员函数不能在开头加<code>template&lt;&gt;</code>，相当于全特化后变成了一个普通类。</p><p><strong>普通成员函数和静态变量的全特化</strong>如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//标识符为T的模板参数，表示myvector容器所保存的元素类型</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myvector</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">typedef</span> T* myiterator;<span class="hljs-comment">// 迭代器</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> m_stc;<span class="hljs-comment">// 静态变量声明</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myvector</span>();<span class="hljs-comment">//构造函数</span><br><span class="hljs-built_in">myvector</span>(T tmpt) <span class="hljs-comment">// 带参数的构造函数</span><br>&#123;<br><br>&#125;<br>myvector&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> myvector&amp;);<span class="hljs-comment">// 重载赋值运算符，在类模板中使用模板名可以不用提供模板参数，如myvector&lt;T&gt;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myfunc</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 迭代器接口</span><br><span class="hljs-function">myiterator <span class="hljs-title">mybegin</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//迭代器起始位置</span><br><span class="hljs-function">myiterator <span class="hljs-title">myend</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//迭代器结束位置</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>myvector&lt;T&gt;::<span class="hljs-built_in">myvector</span>()<span class="hljs-comment">// 类外构造函数实现</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;泛化版本的构造函数被调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">myvector</span>&lt;</span><span class="hljs-keyword">int</span>&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myvector</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;全特化版本&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myfunc</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">void</span> myvector&lt;<span class="hljs-keyword">int</span>&gt;::<span class="hljs-built_in">myfunc</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;全特化版本的myfunc&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">void</span> myvector&lt;T&gt;::<span class="hljs-built_in">myfunc</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;泛化版本的普通成员函数myfunc()被调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">void</span> myvector&lt;<span class="hljs-keyword">double</span>&gt;::<span class="hljs-built_in">myfunc</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;泛化版本的普通成员函数myfunc()的全特化版本被调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">int</span> myvector&lt;T&gt;::m_stc = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">int</span> myvector&lt;<span class="hljs-keyword">double</span>&gt;::m_stc = <span class="hljs-number">100</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>myvector&lt;<span class="hljs-keyword">float</span>&gt; tempvec;<br>tempvec.<span class="hljs-built_in">myfunc</span>();<br>cout &lt;&lt; tempvec.m_stc &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码的mian函数中，我们使用<code>myvector&lt;float&gt; tempvec;</code>指令模板参数类型为float实例化了类模板，因为myvector类模板存在全特化版本，所以编译器会先找到全特化版本，但是由于全特化版本中模板参数特化类型为int，<code>class  myvector&lt;int&gt;</code>，所以只能使用泛化版本，因此运行的是泛化版本的构造函数。接着，运行代码<code>tempvec.myfunc();</code>，tempvec是泛化版本示例化后的类，所以<code>myfunc</code>函数也是泛化版本中的，不过在泛化版本中存在全特化的同名函数，所以会优先选择其。不过由于该成员函数的全特化版本模板参数类型为double，<code>void myvector&lt;double&gt;::myfunc()</code>，不是该实例化类中模板参数float，所以该全特化函数不会取代原来的同名成员函数。对于模板类中的静态变量m_stc同理。亦然，我们如果最开始指定模板类型为double，那么会依次执行泛化版本的构造函数，泛化版本的全特化myfunc成员函数，输出泛化版本的m_stc静态变量。想一想，如果实例化类的模板参数类型为int，那么<code>cout &lt;&lt; tempvec.m_stc &lt;&lt; endl;</code>必然会报错，因为类模板的全特化版本中没有这一静态变量。</p><blockquote><p>注意：<strong>如果进行了普通成员函数或静态成员变量的全特化，那么就无法用这些全特化时指定的类型对整个类模板进行全特化了</strong>。因为在对成员函数或静态成员变量进行了全特化后导致实例化了对应类型的类模板，如果再次进行全特化，将不会重复进行相同类型的实例化，编译器报错。</p></blockquote><p>对于类模板的<strong>偏特化</strong>有两种：一是模板参数数量上的偏特化；一是模板参数范围上的偏特化。具体实现和原理类似于函数模板的偏特化。</p><p>对于<strong>默认参数</strong>：</p><ul><li>与函数模板的默认参数不同，类模板的默认参数规定：如果某一模板参数具有默认值，那么其后所有的模板参数都得有默认值。</li><li>有默认值的模板参数在类模板实例化时可以不用提供，如<code>myvector&lt;&gt; tmpvec</code>。</li><li>后面的模板参数可以依赖前面的模板参数，如<code>template&lt;typename T, typename U=T*&gt;</code>。</li><li>还可以在模板声明中指定默认参数。</li></ul><p><strong>类型别名</strong>，可以通过typedef或者using关键字给类型名起一个别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> TC&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>&gt; IF_TC;<br><span class="hljs-keyword">using</span> IF_TCU = TC&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">float</span>&gt;;<br></code></pre></td></tr></table></figure><p>和函数模板一样，类模板中同样也可以有非类型模板参数，但全局指针、浮点数和字符串常量不能作为非类型模板参数。</p><h2 id="成员函数模板"><a href="#成员函数模板" class="headerlink" title="成员函数模板"></a>成员函数模板</h2><p>示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">A</span>(<span class="hljs-keyword">double</span> v1, <span class="hljs-keyword">double</span> v2)<span class="hljs-comment">// 普通构造函数</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A::A(double,double)执行了！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-built_in">A</span>(T1 v1, T1 v2)<span class="hljs-comment">// 使用类模板参数类型的构造函数</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A::A(T1,T1)执行了！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">(T2 v1, T2 v2)</span></span>;<span class="hljs-comment">// 构造函数模板</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T3&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myfunc</span><span class="hljs-params">(T3 tmpt)</span><span class="hljs-comment">// 普通成员函模板</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; tmpt &lt;&lt; endl;<br>&#125;<br>T1 m_ic;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">int</span> m_stcvalue = <span class="hljs-number">200</span>;<br>&#125;;<br><br><span class="hljs-comment">// 在类外实现类模板的构造函数模板</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1&gt;<span class="hljs-comment">// 先写类模板的模板参数列表</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T2&gt;<span class="hljs-comment">// 再写构造函数模板自己的模板参数列表</span><br>A&lt;T1&gt;::<span class="hljs-built_in">A</span>(T2 v1, T2 v3)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;A::A(T2,T2)执行了！&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">A&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>a.<span class="hljs-built_in">myfunc</span>(<span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类模板中的成员函数，只有在源代码中调用时，对应成员函数才会出现在实例化的类模板中。</li><li>类模板中的成员函数模板，只有在源代码中调用时，对应成员函数模板的具体实例才会出现在实例化的类模板中。</li><li>编译器目前不支持虚成员函数模板。</li></ul><p>拷贝构造函数模板<strong>不等同且永远不可能成为</strong>拷贝构造函数，拷贝赋值运算符模板<strong>不等同且永远不可能成为</strong>拷贝赋值运算符。类型相同的对象拷贝构造调用的是拷贝构造函数，类型不同的对象拷贝构造调用的是拷贝构造函数模板，并不会因为找不到对应调用对象而且调用另一个。</p><p>对于成员函数模板也具有特化版本。</p><blockquote><p>相关资料表示，C++标准不允许在类模板之外全特化一个未被全特化的类模板的成员函数模板。即在类模板外，如果要全特化一个成员函数模板，需要确保该成员函数模板所属的类模板为全特化版本。</p></blockquote><h2 id="类模板嵌套"><a href="#类模板嵌套" class="headerlink" title="类模板嵌套"></a>类模板嵌套</h2><p>类模板中套类模板和类中类相差不大。需要注意的是，将子类模板的成员函数写在父类模板的泛化版本之外，应当如下形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1&gt;<span class="hljs-comment">//父类模板参数列表</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;<span class="hljs-comment">//子类模板参数列表</span><br><span class="hljs-keyword">void</span> A&lt;T1&gt;::B&lt;U&gt;::<span class="hljs-built_in">myfunc</span>()<br>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="变量模板与成员变量模板"><a href="#变量模板与成员变量模板" class="headerlink" title="变量模板与成员变量模板"></a>变量模板与成员变量模板</h2><p>变量模板定义和使用如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T myvar&#123;&#125;;<span class="hljs-comment">// 变量模板，&#123;&#125;为零初始化</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>myvar&lt;<span class="hljs-keyword">int</span>&gt; = <span class="hljs-number">13</span>;<br>myvar&lt;<span class="hljs-keyword">double</span>&gt; = <span class="hljs-number">13.1</span>;<br>cout &lt;&lt; myvar&lt;<span class="hljs-keyword">int</span>&gt; &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; myvar&lt;<span class="hljs-keyword">double</span>&gt; &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>不同的指定类型得到不同的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T myvar&#123;&#125;;<span class="hljs-comment">// 泛化版本</span><br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">char</span> myvar&lt;<span class="hljs-keyword">int</span>&gt;&#123;&#125;;<span class="hljs-comment">// 全特化版本，myvar&lt;int&gt;可以当作char类型使用</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>T myvar&lt;T *&gt;&#123;<span class="hljs-number">120</span>&#125;;<span class="hljs-comment">// 偏特化版本</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T = <span class="hljs-keyword">int</span>&gt;<br>T myvar&#123;&#125;;<span class="hljs-comment">// 默认模板参数</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">int</span> val&gt;<br>T myvar[val];<span class="hljs-comment">// 非类型模板参数</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> W&gt;<br>    <span class="hljs-keyword">static</span> W m_tpi;<span class="hljs-comment">// 成员变量模板</span><br>&#125;;<br><br><span class="hljs-comment">// 成员变量模板在类模板外定义</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> W&gt;<br>W A&lt;T&gt;::m_tpi = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h2 id="别名模板与成员别名模板"><a href="#别名模板与成员别名模板" class="headerlink" title="别名模板与成员别名模板"></a>别名模板与成员别名模板</h2><p>别名模板的作用主要是简化书写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">str_map_t</span> = std::map&lt;std::string, T&gt;;<span class="hljs-comment">// 别名模板</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">str_map_t</span> = std::map&lt;std::string, T&gt;;<span class="hljs-comment">// 成员别名模板</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">str_map_t</span>&lt;<span class="hljs-keyword">int</span>&gt; map1;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">str_map_t</span>&lt;<span class="hljs-keyword">int</span>&gt; map1;<br>    map1.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-number">1</span>&#125;);<br>    map1.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-number">2</span>&#125;);<br>    A&lt;<span class="hljs-keyword">float</span>&gt; obja;<br>    obja.map1.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-number">1</span>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模板模板参数"><a href="#模板模板参数" class="headerlink" title="模板模板参数"></a>模板模板参数</h2><p>之前我们学习的模板参数有类型模板参数和非类型模板参数，这一部分将提出模板模板参数，即<strong>模板参数本身为模板</strong>，将类模板当作参数传递到另一个模板中。我们在学习类模板的时候知道vector、list等容器类其实也是类模板，所以若我们想要将这些容器类作为模板参数传入模板中，写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> =</span> std::vector&gt;<br><span class="hljs-comment">//template&lt;typename T, template&lt;typename W&gt; typename Container = std::vector&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myclass</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>Container&lt;T&gt; myc;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-built_in">myclass</span>()<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>myc.<span class="hljs-built_in">push_back</span>(i);<span class="hljs-comment">// 本行代码正确性取决于模板参数类型</span><br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span>&gt;</span><br><span class="hljs-keyword">void</span> myclass&lt;T, Container&gt;::<span class="hljs-built_in">func</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;mstifiy&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>myclass&lt;<span class="hljs-keyword">double</span>, list&gt; mylistobj; <span class="hljs-comment">// double是容器中的元素类型，list是容器类型</span><br>mylistobj.<span class="hljs-built_in">func</span>();<br>std::cout &lt;&lt; mylistobj.myc.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中重点注意模板参数列表的写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span>&gt;</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Container</span> =</span> std::vector&gt;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> W&gt; <span class="hljs-keyword">typename</span> Container = std::vector&gt;<span class="hljs-comment">// class也能替换成typename修饰</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">typename</span> Container = std::vector&gt;<span class="hljs-comment">// W为容器模板的类型模板参数，不能用，故省略</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>&gt; <span class="hljs-keyword">typename</span> Container&gt;<span class="hljs-comment">// 没有默认模板参数</span><br></code></pre></td></tr></table></figure><blockquote><p>class和typename可以相互替代，都是合法的。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【C++泛型学习笔记】函数模板</title>
    <link href="/2022/12/04/%E3%80%90C++%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/12/04/%E3%80%90C++%E6%B3%9B%E5%9E%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>提到C++的程序设计方法，最先想到的便是两种：<strong>面向过程和面向对象编程</strong>。但是当我们去阅读一些优秀的C++库源码时（比如CGAL），就会直接被其的<strong>泛型编程</strong>劝退。泛型编程也是C++程序设计方法中的一种，不同于上述两种设计方法，其最突出的特点是<strong>提高代码复用性和减少代码冗余</strong>，这也是大型开源项目使用泛型的原因之一。而我学习泛型编程的目的在于，能够看懂CGAL等库的源码和具备高复用性代码编写能力，并且为学习STL、Boost等库打下基础。</p><blockquote><p> 学习参考书籍：王健伟《C++新经典：模板与泛型编程》</p></blockquote><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="基本范例"><a href="#基本范例" class="headerlink" title="基本范例"></a>基本范例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 函数重载</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tv1,<span class="hljs-keyword">int</span> tv2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> tv1 - tv2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">Sub</span><span class="hljs-params">(<span class="hljs-keyword">double</span> tv1, <span class="hljs-keyword">double</span> tv2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> tv1 - tv2;<br>&#125;<br><br><span class="hljs-comment">// 函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">Sub</span><span class="hljs-params">(T tv1, T tv2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> tv1 - tv2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> subv1 = <span class="hljs-built_in">Sub</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;subv1 = &quot;</span> &lt;&lt; subv1 &lt;&lt; endl;<br><span class="hljs-keyword">double</span> subv2 = <span class="hljs-built_in">Sub</span>(<span class="hljs-number">4.7</span>, <span class="hljs-number">2.1</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;subv2 = &quot;</span> &lt;&lt; subv2 &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于C++这种强类型语言，我们创建一个Sub函数用于返回两数相减结果，如果希望该函数不仅支持整数相减还支持浮点数相减，那么我们会通过重载函数的方式，写两个不同参数类型的同名Sub函数。这时，如果我们定义一个模板函数Sub，便可以减少一半的代码量。通过定义一个通用的模板函数，避免为每个类型都定义一个不同的函数。</p><p>函数模板的定义范例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">Sub</span><span class="hljs-params">(T tv1, T tv2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> tv1 - tv2;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>T：称为<strong>模板参数</strong>，确切讲是一个<strong>类型模板参数</strong>，代表的是一个<strong>类型</strong>。“T”也可以换成其他标识符。</p></li><li><p>模板的定义以关键字<strong>template</strong>开头。</p></li><li><p>模板参数前面用<strong>typename</strong>进行修饰。</p><blockquote><p>也可以使用<strong>class</strong>代替<strong>typename</strong>对模板参数进行修饰。一般人们习惯用<strong>typename</strong>表明模板实参可以是任一类型，而<strong>class</strong>表明模板实参必须是一个类类型。</p></blockquote></li><li><p>模板参数及其修饰符都用一对**尖括号&lt;&gt;**括起来。</p></li><li><p>虽然模板参数不限制类型，但是需要注意的是传入参数类型必须合法，即对函数中进行的操作是合法的，不然在编译阶段编译器将会判断出来，并报错。</p></li></ul><h2 id="模板实例化"><a href="#模板实例化" class="headerlink" title="模板实例化"></a>模板实例化</h2><p>我们会疑惑，既然没有声明函数参数的类型，那么程序是怎么计算出来的呢？其实在编译过程中，若我们调用了某个函数模板，那么编译器会对这个函数模板进行实例化，用具体的“类型”代替“类型模板参数”的过程叫做<strong>实例化</strong>（也称<strong>代码生成器</strong>）。</p><p>所以，我们可以认为虽然我们没有完成对函数参数进行类型声明，但是编译器却很智能的根据我们调用函数输入的参数类型自动对模板进行了实例化。为了证实这个想法，我们通过在Developer Command Prompt for VS中使用dumpbin工具将编译生成的.obj文件转换成.txt便于我们分析编译结果。</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221203172956885.png" alt="image-20221203172956885"></p><blockquote><p>注意需要用管理员权限打开命令行，并且进入到.obj所在文件夹下执行如上语句。</p></blockquote><p>在生成的.txt文件中，我们可以找到如下字段：</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221203173317433.png" alt="image-20221203173317433"></p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221203173340176.png" alt="image-20221203173340176"></p><p>如上则是Sub函数模板实例化的结果，实例化后的函数名分别为Sub&lt;int&gt;和Sub&lt;double&gt;。该函数名由三部分组成：模板名、一对尖括号&lt;&gt;和括号间一个具体类型。</p><h2 id="模板参数推断"><a href="#模板参数推断" class="headerlink" title="模板参数推断"></a>模板参数推断</h2><p>前面讲到，编译器能根据传入参数类型自动推断模板参数类型。但是如果出现下面这种情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U,<span class="hljs-keyword">typename</span> V&gt;</span><br><span class="hljs-function">V <span class="hljs-title">Sub</span><span class="hljs-params">(T tv1, U tv2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> tv1 - tv2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span> subv1 = <span class="hljs-built_in">Sub</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5.1</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;subv1 = &quot;</span> &lt;&lt; subv1 &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>模板参数有三个，分别是传入类型T、U和返回类型V，运行报错：<code>error C2783: &quot;V Sub(T,U)&quot;: 无法推导 &quot;V&quot; 的 模板 参数</code>。虽然T、U的类型能够像之前那样根据传入参数类型推断出来，但是这里完全没有告诉任何返回值的类型，所以会报错。解决方法如下：</p><ul><li>手动指定类型。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">double</span> subv1 = Sub&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">double</span>,<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">5.1</span>);<br></code></pre></td></tr></table></figure><p>这里可以看到，我们为了指定第三个模板参数V的类型，将前两个都指定了。因为规定我们可以在调用时通过尖括号<strong>指定一部分模板参数</strong>，另一部分则可以由编译器去推断。规定语法为：一旦某一位置模板参数需要编译器推断，那么之后的所有参数都应该由编译器推断。故我们可以将需要推断的模板参数置后，需指定的参数置前，就得到如下写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> V,<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">V <span class="hljs-title">Sub</span><span class="hljs-params">(T tv1, U tv2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> tv1 - tv2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span> subv1 = Sub&lt;<span class="hljs-keyword">double</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">5.1</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;subv1 = &quot;</span> &lt;&lt; subv1 &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>再者，还可以通过<strong>返回类型后置语法</strong>进行改写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Sub</span><span class="hljs-params">(T tv1, U tv2)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(tv1 + tv2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> tv1 - tv2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">double</span> subv1 = <span class="hljs-built_in">Sub</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5.1</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;subv1 = &quot;</span> &lt;&lt; subv1 &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，使用<strong>auto</strong>结合<strong>decltype</strong>完成返回类型推断。当然也能去掉 <code>-&gt; decltype(tv1 + tv2)</code>，使用<strong>auto</strong>关键字对类型进行自动推断。</p><blockquote><p><strong>空模板参数列表</strong>：&lt;&gt;，在调用函数时，在函数名后加上&lt;&gt;，可以明确所调用的对象为函数模板，而非同名的普通函数。</p></blockquote><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>函数模板重载概念：函数模板名字相同，但参数数量和参数类型不同。对于重载函数模板和同名普通函数，编译器会选择最合适的一个进行使用。当同名普通函数和函数模板都比较合适时，优先选择普通函数；在两个重载函数模板之间选择形参数量和类型最接近函数调用输入实参的一个。</p><h2 id="泛化、全特化和偏特化"><a href="#泛化、全特化和偏特化" class="headerlink" title="泛化、全特化和偏特化"></a>泛化、全特化和偏特化</h2><p>通常我们写的函数模板（如上面的示例）都是<strong>泛化</strong>的函数模板。而<strong>特化</strong>版本是从函数模板的泛化版本中抽出的一个<strong>子集</strong>。</p><p><strong>全特化</strong>：把泛化版本中所有的模板参数都用具体类型替代。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数模板（泛化版本）</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Sub</span><span class="hljs-params">(T tv1, U tv2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;泛化版本&quot;</span>);<br><span class="hljs-keyword">return</span> tv1 - tv2;<br>&#125;<br><br><span class="hljs-comment">// 全特化版本</span><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-comment">// 全特化&lt;&gt;中为空，所有模板参数都用具体类型替代</span><br><span class="hljs-keyword">auto</span> Sub&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">double</span>&gt;(<span class="hljs-keyword">int</span> tv1, <span class="hljs-keyword">double</span> tv2)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;全特化版本&quot;</span>);<br><span class="hljs-keyword">return</span> tv1 - tv2;<br>&#125;<br><br><span class="hljs-comment">// 偏特化版本（局部特化）-模板参数数量上的偏特化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">Sub</span><span class="hljs-params">(T tv1, <span class="hljs-keyword">int</span> tv2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;偏特化版本&quot;</span>);<br><span class="hljs-keyword">return</span> tv1 - tv2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>, b = <span class="hljs-number">5</span>;<span class="hljs-comment">// 调用偏特化版本</span><br><span class="hljs-comment">//double a = 3.0, b = 5.0;// 调用泛化版本</span><br><span class="hljs-comment">//int a = 3; double b = 5.0;// 调用全特化版本</span><br>cout &lt;&lt; <span class="hljs-built_in">Sub</span>(a, b) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>函数调用顺序：同名普通函数&gt;模板特化版本&gt;模板泛化版本</p></blockquote><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>函数模板中的类型模板参数可以设置默认值。这样就可以不用指定形参类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> V </span>= <span class="hljs-keyword">double</span>, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function">V <span class="hljs-title">Sub</span><span class="hljs-params">(T tv1, U tv2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> tv1 - tv2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;subv1 = &quot;</span> &lt;&lt; <span class="hljs-built_in">Sub</span>(<span class="hljs-number">3</span>, <span class="hljs-number">5.1</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h2><p>除了类型模板参数以外，函数模板还可以有非类型的普通模板参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> val, <span class="hljs-keyword">typename</span> V </span>= <span class="hljs-keyword">double</span>, <span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-function">V <span class="hljs-title">Sub</span><span class="hljs-params">(T tv1, U tv2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> tv1 - tv2 - val;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;subv1 = &quot;</span> &lt;&lt; Sub&lt;<span class="hljs-number">10</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">5.1</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，非类型模板参数val也能设置默认值。</p><p>Tips：</p><ul><li>非类型模板参数的值一般为<strong>常量</strong>。</li><li><strong>并非任何类型的参数都能作为非类型模板参数</strong>。int类型可以，float、double或类类型不可以。</li></ul><h2 id="一些奇怪但合法的语法"><a href="#一些奇怪但合法的语法" class="headerlink" title="一些奇怪但合法的语法"></a>一些奇怪但合法的语法</h2><ul><li><p>```c++<br>template&lt;typename, int&gt;<br>auto Add2()<br>{</p><pre><code>return 100;</code></pre><p>}</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nim"><br>  &gt; 模板参数未用到，可以省略标识符。<br><br>- ```c++<br>  <span class="hljs-keyword">template</span>&lt;typename T, typename <span class="hljs-built_in">int</span> val&gt;<br>  <span class="hljs-built_in">auto</span> <span class="hljs-type">Add2</span>()<br>  &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>第一个typename修饰类型模板参数T，第二个typename表示其后修饰的int是一个类型，虽然多余但是合法。</p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【VTK+增材CAM】模型切片</title>
    <link href="/2022/12/01/%E3%80%90VTK+%E5%A2%9E%E6%9D%90CAM%E3%80%91%E6%A8%A1%E5%9E%8B%E5%88%87%E7%89%87/"/>
    <url>/2022/12/01/%E3%80%90VTK+%E5%A2%9E%E6%9D%90CAM%E3%80%91%E6%A8%A1%E5%9E%8B%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>模型切片在3D打印喷头路径规划中是非常重要的一环。实现切片的算法有很多，主流的思想是平面与模型三角面片求交得到相交的线段，再将这些线段组织连接成折线轮廓，以便接下来进行切片层内的路径规划。下文将使用VTK简单实现模型Z轴方向的平面切片。</p><h2 id="关键函数"><a href="#关键函数" class="headerlink" title="关键函数"></a>关键函数</h2><p>vtkCutte是一个用于剪切数据的过滤器。在代码中用于得到平面和模型面片求交得到的线段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">cutter = vtk.vtkCutter()<br>cutter.SetInputData(polydata)<br>cutter.SetCutFunction(plane)<br>cutter.SetSortByToSortByCell()  <span class="hljs-comment"># 按切片层数进行排序</span><br>cutter.SetValue(i, z) <span class="hljs-comment"># 设置轮廓的值</span><br></code></pre></td></tr></table></figure><p>vtkStripper是一个用于从输入线段生成折线的过滤器。在代码中用于将散乱的线段组织连接起来成为折线轮廓。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">stripper = vtk.vtkStripper()<br>stripper.SetInputConnection(cutter.GetOutputPort())<br>stripper.JoinContiguousSegmentsOn()<span class="hljs-comment"># 将输出的折线首尾相连成封闭轮廓</span><br>stripper.Update()<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> vtk<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">slice_vtk</span>(<span class="hljs-params">polydata, layerThk</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;slice model with VTK into layers</span><br><span class="hljs-string"></span><br><span class="hljs-string">    :param polydata: vtkPolyData，输入模型</span><br><span class="hljs-string">    :param layerThk: float，层高</span><br><span class="hljs-string">    :return: 切片列表</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 平面相交切片</span><br>    plane = vtk.vtkPlane()<br>    cutter = vtk.vtkCutter()<br>    cutter.SetInputData(polydata)<br>    cutter.SetCutFunction(plane)<br>    cutter.SetSortByToSortByCell()  <span class="hljs-comment"># 按切片层数进行排序</span><br>    _, _, _, _, zMin, zMax = polydata.GetBounds()<br>    i, z = <span class="hljs-number">0</span>, zMin + layerThk<br>    <span class="hljs-keyword">while</span> z &lt; zMax:<br>        cutter.SetValue(i, z)<br>        z += layerThk<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 提取轮廓</span><br>    stripper = vtk.vtkStripper()<br>    stripper.SetInputConnection(cutter.GetOutputPort())<br>    stripper.JoinContiguousSegmentsOn()<br>    stripper.Update()<br><br>    <span class="hljs-comment"># numberOfLines = stripper.GetOutput().GetNumberOfLines()</span><br>    points = stripper.GetOutput().GetPoints()<br>    cells = stripper.GetOutput().GetLines()<br>    cells.InitTraversal()<br>    indices = vtk.vtkIdList()<br>    lineCount = <span class="hljs-number">0</span><br>    contours = []<br>    <span class="hljs-keyword">while</span> cells.GetNextCell(indices):<br>        <span class="hljs-comment"># print(&quot;Line &#123;0&#125;:&quot;.format(lineCount))</span><br>        contour = []<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(indices.GetNumberOfIds()):<br>            point = points.GetPoint(indices.GetId(i))<br>            contour.append((point[<span class="hljs-number">0</span>], point[<span class="hljs-number">1</span>], point[<span class="hljs-number">2</span>]))<br>            <span class="hljs-comment"># print(&quot;\t(&#123;0:0.6f&#125; ,&#123;1:0.6f&#125;, &#123;2:0.6f&#125;)&quot;.format(point[0], point[1], point[2]))</span><br>        contours.append(contour)<br>        lineCount += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> stripper, contours2Layers(contours)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">contours2Layers</span>(<span class="hljs-params">contours</span>):</span><br>    layers = []<br>    <span class="hljs-keyword">for</span> contour <span class="hljs-keyword">in</span> contours:<br>        layer = <span class="hljs-built_in">next</span>((c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> layers <span class="hljs-keyword">if</span> (contour[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] == c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>])), [])<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> layer:<br>            layers.append(layer)<br>        layer.append(contour)<br>    <span class="hljs-keyword">return</span> layers<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    colors = vtk.vtkNamedColors()<br>    lineColor = colors.GetColor3d(<span class="hljs-string">&quot;black&quot;</span>)<br>    modelColor = colors.GetColor3d(<span class="hljs-string">&quot;silver&quot;</span>)<br>    backgroundColor = colors.GetColor3d(<span class="hljs-string">&quot;wheat&quot;</span>)<br><br>    <span class="hljs-comment"># 加载STL模型</span><br>    reader = vtk.vtkSTLReader()<br>    reader.SetFileName(modelFileName)<br>    reader.Update()<br><br>    stripper, layers = slice_vtk(reader.GetOutput(), <span class="hljs-number">2</span>)<br><br>    modelMapper = vtk.vtkPolyDataMapper()<br>    modelMapper.SetInputConnection(reader.GetOutputPort())<br><br>    model = vtk.vtkActor()<br>    model.SetMapper(modelMapper)<br>    model.GetProperty().SetDiffuseColor(modelColor)<br>    model.GetProperty().SetInterpolationToFlat()<br><br>    linesMapper = vtk.vtkPolyDataMapper()<br>    linesMapper.SetInputConnection(stripper.GetOutputPort())<br><br>    lines = vtk.vtkActor()<br>    lines.SetMapper(linesMapper)<br>    lines.GetProperty().SetDiffuseColor(lineColor)<br>    lines.GetProperty().SetLineWidth(<span class="hljs-number">3.</span>)<br><br>    renderer = vtk.vtkRenderer()<br>    renderWindow = vtk.vtkRenderWindow()<br><br>    renderWindow.AddRenderer(renderer)<br>    renderWindow.SetSize(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>)<br><br>    interactor = vtk.vtkRenderWindowInteractor()<br>    interactor.SetRenderWindow(renderWindow)<br><br>    <span class="hljs-comment"># Add the actors to the renderer.</span><br>    renderer.AddActor(model)<br>    renderer.AddActor(lines)<br>    renderer.SetBackground(backgroundColor)<br><br>    <span class="hljs-comment"># This starts the event loop and as a side effect causes an</span><br>    <span class="hljs-comment"># initial render.</span><br>    renderWindow.Render()<br>    interactor.Start()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>在上面代码中，为了将得到的轮廓按照所属切片层进行归类管理，使用如下函数进行实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">contours2Layers</span>(<span class="hljs-params">contours</span>):</span><br>    layers = []<br>    <span class="hljs-keyword">for</span> contour <span class="hljs-keyword">in</span> contours:<br>        layer = <span class="hljs-built_in">next</span>((c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> layers <span class="hljs-keyword">if</span> (contour[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] == c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">2</span>])), [])<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> layer:<br>            layers.append(layer)<br>        layer.append(contour)<br>    <span class="hljs-keyword">return</span> layers<br></code></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221201131742669.png" alt="image-20221201131742669"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于平面切片计算，VTK官方文档中提到了vtkPlaneCutter。vtkPlaneCutter专门用于平面切割，相较于vtkCutter速度更快，且是多线程。为了提高切片算法效率，后期可尝试vtkPlaneCutter。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一维离散数据的分区均匀采样</title>
    <link href="/2022/11/28/%E4%B8%80%E7%BB%B4%E7%A6%BB%E6%95%A3%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E5%8C%BA%E5%9D%87%E5%8C%80%E9%87%87%E6%A0%B7/"/>
    <url>/2022/11/28/%E4%B8%80%E7%BB%B4%E7%A6%BB%E6%95%A3%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E5%8C%BA%E5%9D%87%E5%8C%80%E9%87%87%E6%A0%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>原理类似文章<a href="https://blog.csdn.net/qq_39784672/article/details/128062714">点云梯度下采样</a>中提到的梯度下采样。</p><p>大致采样思路如下：</p><p>Step1：计算出每个待采样点 $p_i$ 的梯度 $G_i$，并计算节点点云整体的平均梯度作为梯度阈值 $G_t$。</p><p>Step2：比较 $G_i$ 与梯度阈值 $G_t$ 大小，如果小于梯度阈值 $G_t$，则把采样点 $p_i$ 划分到节点属性变化剧烈区间，反之划分到节点属性变化缓慢区间。</p><p>Step3：采用均匀网格法对两个区域的节点点云进行精简（下采样），剧烈区间和缓慢区间的边长阈值分别设置为 $A$ 和 $B$ ，并且 $A &lt; B$。</p><blockquote><p>相对空间离散三维点的梯度下采样，一维离散数据分区采样只是在维度上降到了一维，其余采样点计算流程并无差异。</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">SamplingDiscrete1D</span>():</span><br>    y = np.loadtxt(<span class="hljs-string">&#x27;y_data.csv&#x27;</span>, delimiter = <span class="hljs-string">&#x27;,&#x27;</span>)<br>    y_t = np.mean(y)<br>    a_x, b_x = [], []<br>    <span class="hljs-keyword">for</span> i, y_i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(y):<br>        <span class="hljs-keyword">if</span> y_i &gt; y_t:<br>            a_x.append(i + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            b_x.append(i + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">uniform_sample</span>(<span class="hljs-params">origin_points, interval</span>):</span><br>        filtered_points = []<br>        <span class="hljs-comment"># 计算边界点和划分区间数量</span><br>        x_min, x_max = np.amin(y), np.amax(y)<br>        h = []  <span class="hljs-comment"># h 为保存索引的列表</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(origin_points)):<br>            hx = (origin_points[j] - x_min) // interval<br>            h.append(hx)<br>        h = np.array(h)<br>        <span class="hljs-comment"># 采样点</span><br>        h_indice = np.argsort(h)  <span class="hljs-comment"># 返回h里面的元素按从小到大排序的索引</span><br>        h_sorted = h[h_indice]<br>        begin = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(h_sorted)):<br>            point_idx = h_indice[begin: j + <span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(h_sorted) - <span class="hljs-number">1</span>:  <span class="hljs-comment"># 到最后一个区间的最后一个点</span><br>                filtered_points.append(np.<span class="hljs-built_in">round</span>(np.mean(origin_points[point_idx])))  <span class="hljs-comment"># 计算最后一个体素的采样点</span><br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> h_sorted[j] == h_sorted[j + <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">else</span>:<br>                filtered_points.append(np.<span class="hljs-built_in">round</span>(np.mean(origin_points[point_idx])))<br>                begin = j + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> filtered_points<br><br>    filter_a = uniform_sample(np.array(a_x), <span class="hljs-number">4</span>)<br>    filter_b = uniform_sample(np.array(b_x), <span class="hljs-number">20</span>)<br>    sample_point = <span class="hljs-built_in">sorted</span>(<span class="hljs-built_in">set</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, filter_a + filter_b))))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(sample_point))<br>    <span class="hljs-comment"># print(sample_point)</span><br>    <span class="hljs-keyword">return</span> sample_point<br></code></pre></td></tr></table></figure><p>其中通过如下两行代码进行分区均匀采样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">filter_a = uniform_sample(np.array(a_x), <span class="hljs-number">4</span>)<br>filter_b = uniform_sample(np.array(b_x), <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p><code>4和20</code>分别为filter_a（变化剧烈分区）和filter_b（变化缓慢分区）的采样间隙大小。</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>filter_a=4，filter_b=20。</p><p>待采样点总数206，采样点总数32。</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221128091149893.png" alt="image-20221128091149893"></p><p>filter_a=2，filter_b=20。</p><p>待采样点总数206，采样点总数47。</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221128091833786.png" alt="image-20221128091833786"></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>点云梯度下采样</title>
    <link href="/2022/11/27/%E7%82%B9%E4%BA%91%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%87%87%E6%A0%B7/"/>
    <url>/2022/11/27/%E7%82%B9%E4%BA%91%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%87%87%E6%A0%B7/</url>
    
    <content type="html"><![CDATA[<p>点云下采样又称点云精简。</p><h2 id="均匀网格下采样"><a href="#均匀网格下采样" class="headerlink" title="均匀网格下采样"></a>均匀网格下采样</h2><p>均匀网格下采样法是建立在空间包围盒精简算法之上对散乱点云快速简化的一种算法，其基本思想为：根据点云数据的密度确定最小三维网格（体素）的边长为$a<em>b</em>c$，计算最小三维网格的重心，通过邻域搜索保留离重心点最近的点并删除其余的点。每个三维网格重心依据式下式进行计算。<br>$$<br>X=\frac{\sum_{i=1}^n x_i}{n}, \quad Y=\frac{\sum_{i=1}^n y_i}{n}, \quad Z=\frac{\sum_{i=1}^n z_i}{n}<br>$$<br>其中 $n$ 表示最小三维网格中的点云数据量$^{[1]}$。</p><blockquote><p>原理类似与<a href="https://blog.csdn.net/qq_39784672/article/details/125987962">点云降采样（DownSampling</a>这篇中所提到的体素网格下采样。</p></blockquote><h2 id="曲率下采样"><a href="#曲率下采样" class="headerlink" title="曲率下采样"></a>曲率下采样</h2><p>对于上述的均匀下采样（体素下采样），随着体素尺寸的增大，采样后得到的点云将会丢失细节特征，如曲率较大处，相反，如果在曲率变化不大的地方采样过多点，会显得冗余。所以，在这种情况下基于曲率特征的点云采样方法更加合适。</p><p>采样思路如下：</p><p>Step1：使用局部曲面拟合法计算出每个待采样点 $p_i$ 的曲率 $H_i$，并计算点云整体的平均曲率作为曲率阈值 $H_t$。</p><p>Step2：比较 $H_i$ 与曲率阈值 $H_t$ 的大小，如果小于曲率阈值 $H_t$，则把采样点 $p_i$ 划分到平缓区域，反之划分到陡峭区域。<br>Step3：采用均匀网格法对两个区域的点云进行精简（下采样），陡峭区域和平缓区域的边长阈值分别设置为 $A$ 和 $B$ ，并且 $A&lt;B$ $^{[1]}$。  </p><h2 id="梯度下采样"><a href="#梯度下采样" class="headerlink" title="梯度下采样"></a>梯度下采样</h2><p>通过类比法，我们用有限元体网格节点梯度替代表面曲率，设计出一种基于梯度特征的节点点云下采样方法。</p><p>采样思路如下：</p><p>Step1：计算出每个待采样点 $p_i$ 的梯度 $G_i$，并计算节点点云整体的平均梯度作为梯度阈值 $G_t$。</p><p>Step2：比较 $G_i$ 与梯度阈值 $G_t$ 大小，如果小于梯度阈值 $G_t$，则把采样点 $p_i$ 划分到节点属性变化剧烈区域，反之划分到节点属性变化缓慢区域。<br>Step3：采用均匀网格法对两个区域的节点点云进行精简（下采样），剧烈区域和缓慢区域的边长阈值分别设置为 $A$ 和 $B$ ，并且 $A&lt;B$。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="均匀网格下采样-1"><a href="#均匀网格下采样-1" class="headerlink" title="均匀网格下采样"></a>均匀网格下采样</h3><p>均匀网格下采样，也就是体素下采样的python代码实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">voxel_filter</span>(<span class="hljs-params">origin_points, leaf_size</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;体素下采样&quot;&quot;&quot;</span><br>    filtered_points = []<br>    <span class="hljs-comment"># 计算边界点</span><br>    x_min, y_min, z_min = np.amin(origin_points, axis = <span class="hljs-number">0</span>)  <span class="hljs-comment"># 计算x y z 三个维度的最值</span><br>    x_max, y_max, z_max = np.amax(origin_points, axis = <span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># 计算 voxel grid维度</span><br>    Dx = (x_max - x_min) // leaf_size + <span class="hljs-number">1</span><br>    Dy = (y_max - y_min) // leaf_size + <span class="hljs-number">1</span><br>    Dz = (z_max - z_min) // leaf_size + <span class="hljs-number">1</span><br>    <span class="hljs-comment"># print(&quot;Dx x Dy x Dz is &#123;&#125; x &#123;&#125; x &#123;&#125;&quot;.format(Dx, Dy, Dz))</span><br><br>    <span class="hljs-comment"># 计算每个点的voxel索引，即确定每个点所被划分到的voxel</span><br>    h = []  <span class="hljs-comment"># h 为保存索引的列表</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(origin_points)):<br>        hx = (origin_points[i][<span class="hljs-number">0</span>] - x_min) // leaf_size<br>        hy = (origin_points[i][<span class="hljs-number">1</span>] - y_min) // leaf_size<br>        hz = (origin_points[i][<span class="hljs-number">2</span>] - z_min) // leaf_size<br>        h.append(hx + hy * Dx + hz * Dx * Dy)  <span class="hljs-comment"># voxel索引填充顺序x-y-z</span><br>    h = np.array(h)<br><br>    <span class="hljs-comment"># 筛选点</span><br>    h_indice = np.argsort(h)  <span class="hljs-comment"># 返回h里面的元素按从小到大排序的索引</span><br>    h_sorted = h[h_indice]<br>    begin = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(h_sorted)):<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(h_sorted) - <span class="hljs-number">1</span>:  <span class="hljs-comment"># 到最后一个体素的最后一个点</span><br>            point_idx = h_indice[begin: i + <span class="hljs-number">1</span>]<br>            filtered_points.append(np.mean(origin_points[point_idx], axis = <span class="hljs-number">0</span>))  <span class="hljs-comment"># 计算最后一个体素的采样点</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> h_sorted[i] == h_sorted[i + <span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">else</span>:<br>            point_idx = h_indice[begin: i + <span class="hljs-number">1</span>]<br>            filtered_points.append(np.mean(origin_points[point_idx], axis = <span class="hljs-number">0</span>))<br>            begin = i + <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 把点云格式改成array，并对外返回</span><br>    filtered_points = np.array(filtered_points, dtype = np.float64)<br>    <span class="hljs-keyword">return</span> filtered_points<br></code></pre></td></tr></table></figure><p>上面代码参考这篇文章<a href="https://blog.csdn.net/qinlele1994/article/details/106140805">【点云学习】Python实现点云体素下采样（Voxel Filter）</a>中的代码。原文中的代码在迭代采样体素过程中，存在无法在最后一个体素中采样的问题。所以，我在迭代中添加了如下语句，进行完善。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(h_sorted) - <span class="hljs-number">1</span>:  <span class="hljs-comment"># 到最后一个体素的最后一个点</span><br>    point_idx = h_indice[begin: i + <span class="hljs-number">1</span>]<br>    filtered_points.append(np.mean(origin_points[point_idx], axis = <span class="hljs-number">0</span>))  <span class="hljs-comment"># 计算最后一个体素的采样点</span><br>    <span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><h3 id="梯度下采样-1"><a href="#梯度下采样-1" class="headerlink" title="梯度下采样"></a>梯度下采样</h3><p>结合上述的算法流程，梯度下采样python代码实现如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gradient_downsampling</span>(<span class="hljs-params">origin_points, G, a, b</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;gradient downsampling</span><br><span class="hljs-string"></span><br><span class="hljs-string">    :param origin_points: 源点云</span><br><span class="hljs-string">    :param G: 点云梯度值</span><br><span class="hljs-string">    :param a: 梯度变化剧烈区域采样体素尺寸</span><br><span class="hljs-string">    :param b: 梯度变化缓慢区域采样体素尺寸</span><br><span class="hljs-string">    :return: 采样点云</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    filtered_points, a_points, b_points = [], [], []<br>    <span class="hljs-comment"># 将点与其对应梯度绑定</span><br>    <span class="hljs-comment"># origin_points = np.hstack((origin_points, G.reshape(-1, 1)))</span><br>    <span class="hljs-comment"># Step1: 将平均梯度作为梯度阈值</span><br>    G_t = np.mean(G)<br>    <span class="hljs-comment"># Step2: 根据梯度划分点云为a_points和b_points两个区域</span><br>    <span class="hljs-keyword">for</span> i, G_i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(G):<br>        <span class="hljs-keyword">if</span> G_i &gt; G_t:<br>            a_points.append(origin_points[i])<br>        <span class="hljs-keyword">else</span>:<br>            b_points.append(origin_points[i])<br><br>    <span class="hljs-comment"># Step3: 采样体素下采样对a_points和b_points两个区域进行采样</span><br>    a_filtered = voxel_filter(np.array(a_points), a, near = <span class="hljs-literal">True</span>)<br>    b_filtered = voxel_filter(np.array(b_points), b, near = <span class="hljs-literal">True</span>)<br>    filtered_points = np.vstack((a_filtered, b_filtered))<br><br>    <span class="hljs-keyword">return</span> filtered_points<br></code></pre></td></tr></table></figure><p>为了满足采样点为源点云中的点，即采样距离体素重心最近的点，改写voxel_filter函数如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">voxel_filter</span>(<span class="hljs-params">origin_points, leaf_size, near = <span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;体素下采样&quot;&quot;&quot;</span><br>    filtered_points = []<br>    <span class="hljs-keyword">if</span> near:<br>        <span class="hljs-comment"># 构建KD-Tree寻找最近点</span><br>        <span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> spatial<br>        tree = spatial.KDTree(data = origin_points[:, :<span class="hljs-number">3</span>])<br><br>    <span class="hljs-comment"># 计算边界点</span><br>    x_min, y_min, z_min = np.amin(origin_points[:, :<span class="hljs-number">3</span>], axis = <span class="hljs-number">0</span>)  <span class="hljs-comment"># 计算x y z 三个维度的最值</span><br>    x_max, y_max, z_max = np.amax(origin_points[:, :<span class="hljs-number">3</span>], axis = <span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># 计算 voxel grid维度</span><br>    Dx = (x_max - x_min) // leaf_size + <span class="hljs-number">1</span><br>    Dy = (y_max - y_min) // leaf_size + <span class="hljs-number">1</span><br>    Dz = (z_max - z_min) // leaf_size + <span class="hljs-number">1</span><br>    <span class="hljs-comment"># print(&quot;Dx x Dy x Dz is &#123;&#125; x &#123;&#125; x &#123;&#125;&quot;.format(Dx, Dy, Dz))</span><br><br>    <span class="hljs-comment"># 计算每个点的voxel索引，即确定每个点所被划分到的voxel</span><br>    h = []  <span class="hljs-comment"># h 为保存索引的列表</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(origin_points)):<br>        hx = (origin_points[i][<span class="hljs-number">0</span>] - x_min) // leaf_size<br>        hy = (origin_points[i][<span class="hljs-number">1</span>] - y_min) // leaf_size<br>        hz = (origin_points[i][<span class="hljs-number">2</span>] - z_min) // leaf_size<br>        h.append(hx + hy * Dx + hz * Dx * Dy)  <span class="hljs-comment"># voxel索引填充顺序x-y-z</span><br>    h = np.array(h)<br><br>    <span class="hljs-comment"># 筛选点</span><br>    h_indice = np.argsort(h)  <span class="hljs-comment"># 返回h里面的元素按从小到大排序的索引</span><br>    h_sorted = h[h_indice]<br>    begin = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(h_sorted)):<br>        point_idx = h_indice[begin: i + <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(h_sorted) - <span class="hljs-number">1</span>:  <span class="hljs-comment"># 到最后一个体素的最后一个点</span><br>            <span class="hljs-keyword">if</span> near:<br>                query_point = np.mean(origin_points[point_idx], axis = <span class="hljs-number">0</span>)[:<span class="hljs-number">3</span>]<br>                dist, ind = tree.query(query_point, k = <span class="hljs-number">1</span>)<br>                filtered_points.append(origin_points[ind])<br>            <span class="hljs-keyword">else</span>:<br>                filtered_points.append(np.mean(origin_points[point_idx], axis = <span class="hljs-number">0</span>))  <span class="hljs-comment"># 计算最后一个体素的采样点</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">if</span> h_sorted[i] == h_sorted[i + <span class="hljs-number">1</span>]:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> near:<br>                query_point = np.mean(origin_points[point_idx], axis = <span class="hljs-number">0</span>)[:<span class="hljs-number">3</span>]<br>                dist, ind = tree.query(query_point, k = <span class="hljs-number">1</span>)<br>                filtered_points.append(origin_points[ind])<br>            <span class="hljs-keyword">else</span>:<br>                filtered_points.append(np.mean(origin_points[point_idx], axis = <span class="hljs-number">0</span>))<br>            begin = i + <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 把点云格式改成array，并对外返回</span><br>    filtered_points = np.array(filtered_points, dtype = np.float64)<br>    <span class="hljs-keyword">return</span> filtered_points<br></code></pre></td></tr></table></figure><p>通过构建待采样点云的KD-Tree实现最邻近搜索。</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>我们对比测试同一待采样点云的体素下采样和梯度下采样，测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">input_points = np.hstack((points, gradient))<br>drawPointCloud(input_points, color = <span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 体素下采样</span><br>Vsample_points = voxel_filter(input_points, <span class="hljs-number">5</span>)<br>drawPointCloud(Vsample_points, color = <span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 梯度下采样</span><br>Gsample_points = gradient_downsampling(input_points, gradient, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<br>drawPointCloud(Gsample_points, color = <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>这里我们通过使用open3d库进行点云可视化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drawPointCloud</span>(<span class="hljs-params">points, color = <span class="hljs-literal">False</span></span>):</span><br>    <span class="hljs-keyword">import</span> open3d <span class="hljs-keyword">as</span> o3d<br>    cloud = o3d.geometry.PointCloud()<br>    cloud.points = o3d.utility.Vector3dVector(points[:, :<span class="hljs-number">3</span>])<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(cloud.points))<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> color:<br>        <span class="hljs-comment"># 所有点统一颜色</span><br>        cloud.paint_uniform_color([<span class="hljs-number">241</span> / <span class="hljs-number">255</span>, <span class="hljs-number">135</span> / <span class="hljs-number">255</span>, <span class="hljs-number">184</span> / <span class="hljs-number">255</span>])<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 颜色映射</span><br>        colors = np.zeros([points.shape[<span class="hljs-number">0</span>], <span class="hljs-number">3</span>])<br>        color_max = np.<span class="hljs-built_in">max</span>(points[:, <span class="hljs-number">3</span>])<br>        color_min = np.<span class="hljs-built_in">min</span>(points[:, <span class="hljs-number">3</span>])<br>        delta_c = <span class="hljs-built_in">abs</span>(color_max - color_min) / (<span class="hljs-number">255</span> * <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(points.shape[<span class="hljs-number">0</span>]):<br>            color_n = (points[:, <span class="hljs-number">3</span>][j] - color_min) / delta_c<br>            <span class="hljs-keyword">if</span> color_n &lt;= <span class="hljs-number">255</span>:<br>                colors[j, :] = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span> - color_n / <span class="hljs-number">255</span>, <span class="hljs-number">1</span>]<br>            <span class="hljs-keyword">else</span>:<br>                colors[j, :] = [(color_n - <span class="hljs-number">255</span>) / <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br><br>        cloud.colors = o3d.utility.Vector3dVector(colors)<br>    o3d.visualization.draw_geometries([cloud])<br></code></pre></td></tr></table></figure><p>测试结果如下图所示。</p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221127115752863.png" alt="image-20221127115752863"></p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221127115817292.png" alt="image-20221127115817292"></p><p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20221127115849878.png" alt="image-20221127115849878"></p><p><font color =#f187b8>PinkCAx</font>中测试结果如下。</p><p>![GIF 2022-11-27 12-06-29](D:\OneDrive\桌面\GIF 2022-11-27 12-06-29.gif)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 李国远,梁周雁,石信肖,等. 基于曲率特征约束的激光点云精简方法研究[J]. 计算机与数字工程,2020,48(8):2034-2037,2063. DOI:10.3969/j.issn.1672-9722.2020.08.042.</p><p>[2] <a href="https://blog.csdn.net/qinlele1994/article/details/106140805">【点云学习】Python实现点云体素下采样（Voxel Filter）</a></p><p>[3] <a href="https://blog.csdn.net/weixin_41496173/article/details/121081281">采用Open3d绘制高度颜色点云图</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【VTK+有限元后处理】节点点云属性颜色映射</title>
    <link href="/2022/11/25/%E3%80%90VTK+%E6%9C%89%E9%99%90%E5%85%83%E5%90%8E%E5%A4%84%E7%90%86%E3%80%91%E8%8A%82%E7%82%B9%E7%82%B9%E4%BA%91%E5%B1%9E%E6%80%A7%E9%A2%9C%E8%89%B2%E6%98%A0%E5%B0%84/"/>
    <url>/2022/11/25/%E3%80%90VTK+%E6%9C%89%E9%99%90%E5%85%83%E5%90%8E%E5%A4%84%E7%90%86%E3%80%91%E8%8A%82%E7%82%B9%E7%82%B9%E4%BA%91%E5%B1%9E%E6%80%A7%E9%A2%9C%E8%89%B2%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>在之前的一篇文章<a href="https://blog.csdn.net/qq_39784672/article/details/127931413">【VTK+有限元后处理】可视化结果云图</a>中，我们实现了对有限元结果的云图显示，效果如下：</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221125173918307.png" alt="image-20221125173918307"></p><p>这样的云图显示也有不足之处，比如想要查看内部单元的属性值分布情况，这种可视化方式显然是不能满足需求的。解决方法之一，便是对模型进行剖切显示，详见文章：<a href="https://blog.csdn.net/qq_39784672/article/details/127938561">【VTK+有限元后处理】实时剖切视图</a>。剖切显示需要调整剖切平面位置和法向以满足我们对内部单元属性分布的观察，个人认为有些许的繁琐。</p><p>于是，我想如果能得到节点的点云，再将属性值映射到点云上，就能很方便的查看内部单元节点的属性分布情况。</p><h2 id="代码及测试结果"><a href="#代码及测试结果" class="headerlink" title="代码及测试结果"></a>代码及测试结果</h2><h3 id="节点点云提取"><a href="#节点点云提取" class="headerlink" title="节点点云提取"></a>节点点云提取</h3><p>用到VTK中的vtkVertexGlyphFilter过滤器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nodes2points</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;节点转点云&quot;&quot;&quot;</span><br>    points = vtk.vtkPolyData()<br>    points.SetPoints(self.FEModel.ugrid.GetPoints())<br><br>    <span class="hljs-comment"># vtkVertexGlyphFilter类将丢弃输入数据中的所有单元，取而代之的是在每个点上创建一个顶点</span><br>    vertexGlyphFilter = vtk.vtkVertexGlyphFilter()<br>    vertexGlyphFilter.AddInputData(points)<br>    vertexGlyphFilter.Update()<br>    self.pointCloud = vertexGlyphFilter.GetOutput()<br>    <span class="hljs-comment"># 点云绘制</span><br>    self.SceneManager.drawPdSrc(self.pointCloud, (<span class="hljs-number">241</span> / <span class="hljs-number">255</span>, <span class="hljs-number">135</span> / <span class="hljs-number">255</span>, <span class="hljs-number">184</span> / <span class="hljs-number">255</span>), point_size = <span class="hljs-number">3</span>)<br>    self.SceneManager.display()<br></code></pre></td></tr></table></figure><p>![GIF 2022-11-25 17-51-25](D:\OneDrive\桌面\GIF 2022-11-25 17-51-25.gif)</p><h3 id="属性颜色映射"><a href="#属性颜色映射" class="headerlink" title="属性颜色映射"></a>属性颜色映射</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loadScalarField</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.FEModel.nodes) == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 节点是否为空</span><br>        self.statusbar.showMessage(<span class="hljs-string">&quot;laod FEModel file first!&quot;</span>, <span class="hljs-number">3000</span>)<br>        <span class="hljs-keyword">return</span><br>    fn, _<span class="hljs-built_in">type</span> = QtWidgets.QFileDialog.getOpenFileName(self, <span class="hljs-string">&#x27;打开标量场文件&#x27;</span>, self.last_path, <span class="hljs-string">&#x27;*.csv;;*.ntl&#x27;</span>)<br>    <span class="hljs-keyword">if</span> fn:<br>        <span class="hljs-keyword">if</span> _<span class="hljs-built_in">type</span> == <span class="hljs-string">&quot;*.ntl&quot;</span>:<br>            self.FEModel.read_ntl(fn)<br>        <span class="hljs-keyword">elif</span> _<span class="hljs-built_in">type</span> == <span class="hljs-string">&#x27;*.csv&#x27;</span>:<br>            self.FEModel.read_csv(fn)<br>        <span class="hljs-comment"># 属性（标量）赋值</span><br>        mapper = self.SceneManager.main_actor.GetMapper()<br>        <span class="hljs-keyword">if</span> mapper.GetInput() == self.pointCloud:<br>            self.pointCloud.GetPointData().SetScalars(self.FEModel.ugrid.GetPointData().GetScalars())<br>            mapper.SetInputData(self.pointCloud)<br>        <span class="hljs-comment"># 可视化属性映射结果</span><br>        scalarRange = self.FEModel.ugrid.GetPointData().GetScalars().GetRange()<br>        title = self.FEModel.ugrid.GetPointData().GetScalars().GetName()<br>        self.SceneManager.drawScalarField(mapper, scalarRange, title)<br>        self.SceneManager.display()<br></code></pre></td></tr></table></figure><p>关键代码<code>self.pointCloud.GetPointData().SetScalars(self.FEModel.ugrid.GetPointData().GetScalars())</code>，将<code>vtkUnstructuredGrid</code>数据（有限元模型）中存储的节点的标量值赋给<code>vtkPolyData</code>数据（节点点云）。上述代码中，<code>drawScalarField</code>函数定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drawScalarField</span>(<span class="hljs-params">self, scalar_mapper, scalarRange, title</span>):</span><br>    <span class="hljs-comment"># 定义颜色映射表</span><br>    lut = vtk.vtkLookupTable()<br>    lut.SetHueRange(<span class="hljs-number">0.67</span>, <span class="hljs-number">0.0</span>)  <span class="hljs-comment"># 色调范围从红色到蓝色</span><br>    <span class="hljs-comment"># lut.SetAlphaRange(1.0, 1.0) # 透明度范围</span><br>    <span class="hljs-comment"># lut.SetValueRange(1.0, 1.0)</span><br>    <span class="hljs-comment"># lut.SetSaturationRange(1.0, 1.0) # 颜色饱和度</span><br>    <span class="hljs-comment"># lut.SetNumberOfTableValues(256)</span><br>    lut.SetNumberOfColors(<span class="hljs-number">256</span>)  <span class="hljs-comment"># 颜色个数</span><br>    <span class="hljs-comment"># lut.SetRange(scalarRange)</span><br>    lut.Build()<br><br>    scalar_mapper.SetScalarRange(scalarRange)<br>    scalar_mapper.SetLookupTable(lut)<br>    self.renderer.RemoveActor(self.main_actor)  <span class="hljs-comment"># 移除main_actor</span><br>    self.main_actor = vtk.vtkActor()<br>    self.main_actor.SetMapper(scalar_mapper)<br>    self.main_actor.GetProperty().SetPointSize(<span class="hljs-number">3</span>)<br>    self.main_actor.GetProperty().SetOpacity(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 设置透明度</span><br>    self.renderer.AddActor(self.main_actor)<br>    <span class="hljs-comment"># 色标带</span><br>    self.scalarBar_actor.SetLookupTable(scalar_mapper.GetLookupTable())  <span class="hljs-comment"># 将颜色查找表传入窗口中的色标带</span><br>    self.scalarBar_actor.SetTitle(title)<br>    self.scalarBar_actor.SetNumberOfLabels(<span class="hljs-number">5</span>)<br>    self.renderer.AddActor2D(self.scalarBar_actor)<br></code></pre></td></tr></table></figure><p>代码测试效果如下所示。</p><p>![GIF 2022-11-25 18-02-30](D:\OneDrive\桌面\GIF 2022-11-25 18-02-30.gif)</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【CGAL+Python】安装CGAL的Python绑定</title>
    <link href="/2022/11/23/%E3%80%90CGAL+Python%E3%80%91%E5%AE%89%E8%A3%85CGAL%E7%9A%84Python%E7%BB%91%E5%AE%9A/"/>
    <url>/2022/11/23/%E3%80%90CGAL+Python%E3%80%91%E5%AE%89%E8%A3%85CGAL%E7%9A%84Python%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>由于CGAL是由C++开发的，在Python中使用一般需要创建Python与C++程序的绑定。想了解更多Python调用C/C++程序的细节参见：<a href="https://zhuanlan.zhihu.com/p/143356193">Python Bindings - 从 Python 调用 C/C++</a>。而我们使用到的绑定是通过SWIG通用工具生成的。SWIG可用于创建与许多其他语言（不仅限于 Python）的 C 和 C++ 程序的绑定。 目前Github上已开源cgal-swig-bindings项目能帮助我们在Python下调用CGAL的一些程序包。这个项目仍处于实验阶段，未来会不断添加更多包。相关信息参见：<a href="https://github.com/CGAL/cgal-swig-bindings/wiki%E3%80%82">https://github.com/CGAL/cgal-swig-bindings/wiki。</a></p><p>cgal-swig-bindings项目已实现Python绑定的CGAL包如下：</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221123151619901.png" alt="image-20221123151619901"></p><p>我们通过pip在Pyhton下安装CGAL，安装命令如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pip install cgal<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221123150645028.png" alt="image-20221123150645028"></p><p>测试一下安装是否成功，该python环境下运行下面代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> CGAL.CGAL_Kernel <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p1 = Point_2(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    p2 = Point_2(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">print</span>(squared_distance(p1, p2))<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221123150847216.png" alt="image-20221123150847216"></p><p>运行成功，结果正确，没有报错。接下来我们便可以愉快的在Python下调用CGAL的算法啦~</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【VTK+有限元后处理】单元信息查询</title>
    <link href="/2022/11/23/%E3%80%90VTK+%E6%9C%89%E9%99%90%E5%85%83%E5%90%8E%E5%A4%84%E7%90%86%E3%80%91%E5%8D%95%E5%85%83%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/11/23/%E3%80%90VTK+%E6%9C%89%E9%99%90%E5%85%83%E5%90%8E%E5%A4%84%E7%90%86%E3%80%91%E5%8D%95%E5%85%83%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>通过可视化界面交互，实现对有限元模型上单元的选择和查询。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>大体思路和<a href="https://blog.csdn.net/qq_39784672/article/details/127984852">【VTK+有限元后处理】节点属性值查询</a>的代码是差不多的。不同的地方在于标记（高亮）显示的方法。单元拾取交互的类型定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CellPickerInteractorStyle</span>(<span class="hljs-params">vtk.vtkInteractorStyleTrackballCamera</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent = <span class="hljs-literal">None</span></span>):</span><br>        self.AddObserver(<span class="hljs-string">&quot;LeftButtonPressEvent&quot;</span>, self.leftButtonPressEvent)<br>        self.selectedMapper = vtk.vtkDataSetMapper()<br>        self.selectedActor = vtk.vtkActor()<br>        self.dataset = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># Setup the text and add it to the renderer</span><br>        self.textActor = vtk.vtkTextActor()<br>        self.textActor.SetPosition(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br>        self.textActor.GetTextProperty().SetFontSize(<span class="hljs-number">24</span>)<br>        self.textActor.GetTextProperty().SetColor(<span class="hljs-number">241</span> / <span class="hljs-number">255</span>, <span class="hljs-number">135</span> / <span class="hljs-number">255</span>, <span class="hljs-number">184</span> / <span class="hljs-number">255</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leftButtonPressEvent</span>(<span class="hljs-params">self, obj, event</span>):</span><br>        clickPos = self.GetInteractor().GetEventPosition()<br>        <span class="hljs-comment"># 打印鼠标左键像素位置</span><br>        <span class="hljs-comment"># print(f&quot;Picking pixel: &#123;clickPos[0]&#125; &#123;clickPos[1]&#125;&quot;)</span><br>        <span class="hljs-comment"># 注册拾取单元函数</span><br>        cellPicker = self.GetInteractor().GetPicker()<br>        cellPicker.SetTolerance(<span class="hljs-number">0.0005</span>)<br>        cellPicker.Pick(clickPos[<span class="hljs-number">0</span>], clickPos[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>, self.GetDefaultRenderer())<br><br>        <span class="hljs-keyword">if</span> cellPicker.GetCellId() != -<span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># print(&quot;Pick position is: &quot;, cellPicker.GetPickPosition())</span><br>            <span class="hljs-comment"># print(&quot;Cell id is:&quot;, cellPicker.GetCellId())</span><br>            <span class="hljs-comment"># print(&quot;Point id is:&quot;, cellPicker.GetPointId())</span><br>            <span class="hljs-keyword">if</span> self.dataset <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Source data not found! &quot;</span>)<br>                <span class="hljs-keyword">return</span><br><br>            cell = self.dataset.GetCell(cellPicker.GetCellId())  <span class="hljs-comment"># 通过拾取的CellId获取vtkCell</span><br>            <span class="hljs-comment"># 打印单元信息</span><br>            self.textActor.SetInput(<span class="hljs-string">f&quot;Picked Cell Type: <span class="hljs-subst">&#123;cell.GetClassName()&#125;</span>\nCell Id: <span class="hljs-subst">&#123;cellPicker.GetCellId()&#125;</span>&quot;</span>)<br>            <span class="hljs-comment">## 高亮选择的单元方法1</span><br>            <span class="hljs-comment"># selectedCells = vtk.vtkUnstructuredGrid()</span><br>            <span class="hljs-comment"># cellArray = vtk.vtkCellArray()</span><br>            <span class="hljs-comment"># pointList = vtk.vtkPoints()</span><br>            <span class="hljs-comment"># idList = vtk.vtkIdList()</span><br>            <span class="hljs-comment"># points = cell.GetPoints()</span><br>            <span class="hljs-comment"># num = points.GetNumberOfPoints()</span><br>            <span class="hljs-comment"># p = [0.0, 0.0, 0.0]</span><br>            <span class="hljs-comment"># for i in range(num):</span><br>            <span class="hljs-comment">#     p = points.GetPoint(i)</span><br>            <span class="hljs-comment">#     print(f&quot;Point&#123;i&#125; :\tx = &#123;p[0]&#125;\ty = &#123;p[1]&#125;\tz =&#123;p[2]&#125;&quot;)</span><br>            <span class="hljs-comment">#     idList.InsertNextId(pointList.InsertNextPoint(p))</span><br>            <span class="hljs-comment"># selectedCells.SetPoints(pointList)</span><br>            <span class="hljs-comment"># selectedCells.InsertNextCell(cell.GetCellType(), idList)</span><br>            <span class="hljs-comment"># print(f&quot;Number of points in the selection: &#123;selectedCells.GetNumberOfPoints()&#125;&quot;)</span><br>            <span class="hljs-comment"># print(f&quot;Number of cells in the selection : &#123;selectedCells.GetNumberOfCells()&#125;&quot;)</span><br>            <span class="hljs-comment"># mapper = vtk.vtkDataSetMapper()</span><br>            <span class="hljs-comment"># mapper.SetInputData(selectedCells)</span><br>            <span class="hljs-comment"># self.GetDefaultRenderer().RemoveActor(self.selectedActor)</span><br>            <span class="hljs-comment"># self.selectedActor.SetMapper(mapper)</span><br>            <span class="hljs-comment"># self.selectedActor.GetProperty().EdgeVisibilityOn()</span><br>            <span class="hljs-comment"># self.selectedActor.GetProperty().SetColor(1.0, 0.0, 0.0)</span><br>            <span class="hljs-comment"># self.selectedActor.GetProperty().SetPointSize(5.0)</span><br>            <span class="hljs-comment"># self.GetDefaultRenderer().AddActor(self.selectedActor)</span><br><br>            <span class="hljs-comment">## 高亮选择的单元方法2</span><br>            ids = vtk.vtkIdTypeArray()<br>            ids.SetNumberOfComponents(<span class="hljs-number">1</span>)<br>            ids.InsertNextValue(cellPicker.GetCellId())<br><br>            selectionNode = vtk.vtkSelectionNode()<br>            selectionNode.SetFieldType(vtk.vtkSelectionNode.CELL)<br>            selectionNode.SetContentType(vtk.vtkSelectionNode.INDICES)<br>            selectionNode.SetSelectionList(ids)<br><br>            selection = vtk.vtkSelection()<br>            selection.AddNode(selectionNode)<br><br>            extractSelection = vtk.vtkExtractSelection()<br>            extractSelection.SetInputData(<span class="hljs-number">0</span>, self.dataset)<br>            extractSelection.SetInputData(<span class="hljs-number">1</span>, selection)<br>            extractSelection.Update()<br><br>            self.selectedMapper.SetInputData(extractSelection.GetOutput())<br>            self.GetDefaultRenderer().RemoveActor(self.selectedActor)<br>            self.selectedActor.SetMapper(self.selectedMapper)<br>            self.selectedActor.GetProperty().EdgeVisibilityOn()<br>            self.selectedActor.GetProperty().SetEdgeColor(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>            self.selectedActor.GetProperty().SetLineWidth(<span class="hljs-number">3</span>)<br>            self.GetDefaultRenderer().AddActor2D(self.textActor)<br>            self.GetDefaultRenderer().AddActor(self.selectedActor)<br><br>        self.OnLeftButtonDown()<br></code></pre></td></tr></table></figure><p>在上面代码中，高亮选中单元的方法有两个。一是通过选中的单元信息构建vtkUnstructuredGrid进行显示，另一是通过vtkExtractSelection从原模型上提取选中的单元进行显示。</p><p>主干代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cellPick</span>(<span class="hljs-params">self</span>):</span><br>    self.ToggleOpacity(<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 透明显示，以便单元观察</span><br>    cellPicker = vtk.vtkCellPicker()<br>    self.interactor.SetPicker(cellPicker)  <span class="hljs-comment"># 设置cellPicker</span><br>    style = CellPickerInteractorStyle()  <span class="hljs-comment"># 设置自定义的单元拾取交互类型</span><br>    style.dataset = self.main_actor.GetMapper().GetInput()<br>    style.SetDefaultRenderer(self.renderer)<br>    self.interactor.SetInteractorStyle(style)<br></code></pre></td></tr></table></figure><p>其中加入ToggleOpacity把actor的透明度调高，以便于观察单元。</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>![GIF 2022-11-23 12-22-38](D:\OneDrive\桌面\GIF 2022-11-23 12-22-38.gif)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://blog.csdn.net/m0_45306991/article/details/125020246">VTK：交互与拾取——单位拾取</a></p><p>[2] <a href="https://www.cnblogs.com/chanyuantiandao/p/16497006.html">vtk拾取单元</a></p><p>[3] <a href="https://vtk.org/doc/nightly/html/classvtkCellPicker.html">VTK: vtkCellPicker Class Reference</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【VTK+有限元后处理】节点属性值查询</title>
    <link href="/2022/11/22/%E3%80%90VTK+%E6%9C%89%E9%99%90%E5%85%83%E5%90%8E%E5%A4%84%E7%90%86%E3%80%91%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7%E5%80%BC%E6%9F%A5%E8%AF%A2/"/>
    <url>/2022/11/22/%E3%80%90VTK+%E6%9C%89%E9%99%90%E5%85%83%E5%90%8E%E5%A4%84%E7%90%86%E3%80%91%E8%8A%82%E7%82%B9%E5%B1%9E%E6%80%A7%E5%80%BC%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>有限元在后处理过程中，我们如果想获取某一个节点的属性数据值，最直接的方法就是点击这个节点，然后显示其属性数据。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先我们需要使用到VTK的点拾取类<code>vtkPointPicker</code>类。</p><p>从需求可知，我们需要与窗口进行交互，所以先自定义一个继承自vtkInteractorStyleTrackballCamera的类（在类中定义了点拾取的交互类型）。我最开始参考了这篇文章<a href="https://blog.csdn.net/m0_45306991/article/details/125014875">VTK：交互与拾取——点拾取</a>的代码，虽然运行成功了，但有些地方似乎不符合预期。第一，其中点拾取代码中有一行为<code>actor-&gt;SetScale(0.05);</code>，即把选中点的圆点标记大小设为常值。带来的结果是，当在一个模型整体尺寸小于这一设定常值（0.05）的时候，标记点会变得特别大（甚至直接覆盖原模型），相反，当模型尺寸远大于这一常值，标记点会变得特别小（很难发现那种）。第二，对于一些不在模型上的点也会被选中并标记，在后处理中，我们希望选中的都是有限元模型节点。对于上述两个问题，我进行了一些优化。优化后的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PointPickerInteractorStyle</span>(<span class="hljs-params">vtk.vtkInteractorStyleTrackballCamera</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent = <span class="hljs-literal">None</span>, dataset = <span class="hljs-literal">None</span></span>):</span><br>        self.AddObserver(<span class="hljs-string">&quot;LeftButtonPressEvent&quot;</span>, self.leftButtonPressEvent)<br>        self.dataset = dataset<br>        self.points = dataset.GetPoints()<br>        <span class="hljs-comment"># 对拾取点进行标记</span><br>        sphereSource = vtk.vtkSphereSource()<br>        sphereSource.Update()<br>        self.mapper = vtk.vtkPolyDataMapper()<br>        self.mapper.SetInputConnection(sphereSource.GetOutputPort())<br>        self.marker_actor = vtk.vtkActor()<br>        self.marker_actor.SetMapper(self.mapper)<br>        <span class="hljs-comment"># Setup the text and add it to the renderer</span><br>        self.textActor = vtk.vtkTextActor()<br>        self.textActor.SetPosition(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)<br>        self.textActor.GetTextProperty().SetFontSize(<span class="hljs-number">24</span>)<br>        self.textActor.GetTextProperty().SetColor(<span class="hljs-number">241</span> / <span class="hljs-number">255</span>, <span class="hljs-number">135</span> / <span class="hljs-number">255</span>, <span class="hljs-number">184</span> / <span class="hljs-number">255</span>)<br>        <span class="hljs-comment"># kd-tree</span><br>        self.tree = vtk.vtkKdTree()<br>        self.tree.BuildLocatorFromPoints(self.points)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leftButtonPressEvent</span>(<span class="hljs-params">self, obj, event</span>):</span><br>        clickPos = self.GetInteractor().GetEventPosition()<br>        <span class="hljs-comment"># 打印鼠标左键像素位置</span><br>        <span class="hljs-comment"># print(f&quot;Picking pixel: &#123;clickPos[0]&#125; &#123;clickPos[1]&#125;&quot;)</span><br>        <span class="hljs-comment"># 注册拾取点函数</span><br>        pointPicker = self.GetInteractor().GetPicker()<br>        pointPicker.Pick(clickPos[<span class="hljs-number">0</span>], clickPos[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>, self.GetDefaultRenderer())<br>        <span class="hljs-comment"># 打印拾取点空间位置</span><br>        pickId = pointPicker.GetPointId()  <span class="hljs-comment"># 获取拾取点的ID，无ID返回-1</span><br>        <span class="hljs-keyword">if</span> pickId != -<span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># 显示模型上被拾取的点</span><br>            pickPos = pointPicker.GetPickPosition()<br>            <span class="hljs-comment"># print(f&quot;Picked value: &#123;pickPos[0]&#125; &#123;pickPos[1]&#125; &#123;pickPos[2]&#125;&quot;)</span><br>            self.marker_actor.SetPosition(pickPos)<br>            <span class="hljs-comment"># Find the 2 closest points to pickPos</span><br>            ClosestIdList = vtk.vtkIdList()<br>            self.tree.FindClosestNPoints(<span class="hljs-number">2</span>, pickPos, ClosestIdList)<br>            pt1 = self.points.GetPoint(ClosestIdList.GetId(<span class="hljs-number">0</span>))<br>            pt2 = self.points.GetPoint(ClosestIdList.GetId(<span class="hljs-number">1</span>))<br>            distance = np.sqrt(vtk.vtkMath.Distance2BetweenPoints(pt1, pt2))<br>            self.marker_actor.SetScale(distance / <span class="hljs-number">5</span>)<br>            self.marker_actor.GetProperty().SetColor(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>)<br>            self.GetDefaultRenderer().AddActor(self.marker_actor)<br>            <span class="hljs-comment"># 打印节点信息</span><br>            <span class="hljs-keyword">if</span> self.dataset.GetPointData().GetScalars():<br>                scalars = self.dataset.GetPointData().GetScalars()<br>                self.textActor.SetInput(<span class="hljs-string">&quot;Picked Point: %.2f %.2f %.2f\nAttribute Value: %.2f&quot;</span> % (<br>                    pickPos[<span class="hljs-number">0</span>], pickPos[<span class="hljs-number">1</span>], pickPos[<span class="hljs-number">2</span>], scalars.GetValue(pickId)))<br>            <span class="hljs-keyword">else</span>:<br>                self.textActor.SetInput(<span class="hljs-string">&quot;Picked Point: %.2f %.2f %.2f\n&quot;</span> % (pickPos[<span class="hljs-number">0</span>], pickPos[<span class="hljs-number">1</span>], pickPos[<span class="hljs-number">2</span>]))<br>            self.GetDefaultRenderer().AddActor2D(self.textActor)<br>        self.OnLeftButtonDown()<br></code></pre></td></tr></table></figure><p>为了能根据模型尺寸改变标记点的大小，我目前的思路是：寻找到距离被拾取点最近的一个点（不包括拾取点本身），计算与其之间的距离<code>distance</code>，然后设置标记对象的尺寸为<code>distance / 5</code>，即设置标签点的直径为与其最近点的五分之一（反正比distance小就行）,这样就实现了动态的尺寸调整。当然这种方法也不是唯一解，只要是能动态合理调节标记对象尺寸的方法都可。因为只有节点才具有ID，所以我们对其ID进行判断，实现只标记节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pickId = pointPicker.GetPointId()  <span class="hljs-comment"># 获取拾取点的ID，无ID返回-1</span><br>        <span class="hljs-keyword">if</span> pickId != -<span class="hljs-number">1</span>:<br>        <span class="hljs-comment"># 标记代码</span><br></code></pre></td></tr></table></figure><p>主干代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">piontPick</span>(<span class="hljs-params">self</span>):</span><br>    dataset = self.main_actor.GetMapper().GetInput()<br><br>    pointPicker = vtk.vtkPointPicker()<br>    self.interactor.SetPicker(pointPicker)  <span class="hljs-comment"># 设置pointPicker</span><br>    style = PointPickerInteractorStyle(dataset = dataset)  <span class="hljs-comment"># 设置自定义的点拾取交互类型</span><br>    style.SetDefaultRenderer(self.renderer)<br>    self.interactor.SetInteractorStyle(style)<br></code></pre></td></tr></table></figure><p>这里传入数据对象<code>dataset</code>的原因是实现对不同的模型尺寸动态调节标记尺寸。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>下面测试结果演示了标记点随模型整体尺寸动态变化。</p><p>![GIF 2022-11-22 16-02-30](D:\OneDrive\桌面\GIF 2022-11-22 16-02-30.gif)</p><p>下面测试结果演示了对有限元节点的属性值查询。</p><p>![GIF 2022-11-22 15-57-08](D:\OneDrive\桌面\GIF 2022-11-22 15-57-08.gif)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://blog.csdn.net/m0_45306991/article/details/125014875">VTK：交互与拾取——点拾取</a></p><p>[2] <a href="https://vtk.org/doc/nightly/html/classvtkKdTree.html">VTK: vtkKdTree Class Reference</a></p><p>[3] <a href="https://vtk.org/doc/nightly/html/classvtkMath.html">VTK: vtkMath Class Reference</a></p><p>[4] <a href="https://vtk.org/doc/nightly/html/classvtkPointPicker.html">VTK: vtkPointPicker Class Reference</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【PinkCAx】可视化工具开发记录与总结</title>
    <link href="/2022/11/21/%E3%80%90PinkCAx%E3%80%91%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <url>/2022/11/21/%E3%80%90PinkCAx%E3%80%91%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<center><b><font color=#f187b8 size=6> -----------PinkCAx----------- </font></b></center><blockquote><p>仅以此篇，记录我的一次可视化软件开发尝试点滴。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PinkCAx是一款采用Python语言编写的，基于QT5+VTK架构的三维可视化工具。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221121222934560.png" alt="image-20221121222934560"></p><p>该工具目前的功能如下：</p><p><b><font size=4 color=gray>基本操作</font></b></p><ul><li><p><input checked="" disabled="" type="checkbox">  网格文件的打开与保存（支持STL、PLY、VTK等）</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221121220318262.png" alt="image-20221121220318262"></p></li><li><p><input checked="" disabled="" type="checkbox">  基本视图（线框、包围盒、刻度包围盒）</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221121220415216.png" alt="image-20221121220415216"></p></li><li><p><input checked="" disabled="" type="checkbox">  文件分类树视图</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221121222525906.png" alt="image-20221121222525906"></p></li><li><p><input checked="" disabled="" type="checkbox">  一些不知道如何分类的功能</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221121220516161.png" alt="image-20221121220516161"></p><blockquote><p>模型曲率计算包括高斯、最大、最小、平均曲率计算；加载属性作用是加载有限元模型的节点属性数据（温度、应力等）；属性比较作用是计算两个属性数据的偏差（用于可视化评估代理模型预测效果）。</p></blockquote></li></ul><p><b><font size=4 color=gray>有限元后处理</font></b></p><ul><li><p><input checked="" disabled="" type="checkbox">  关于有限元后处理的操作</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221121220605096.png" alt="image-20221121220605096"></p></li><li><p><input checked="" disabled="" type="checkbox">  关于</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221121220718196.png" alt="image-20221121220718196"></p></li><li><p><input checked="" disabled="" type="checkbox">  代理模型预测</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221121222648008.png" alt="image-20221121222648008"></p><blockquote><p>构建代理模型，可视化训练结果。（开始跑题ing）</p></blockquote></li></ul><p><b><font size=4 color=gray>点云处理</font></b></p><ul><li><p><input checked="" disabled="" type="checkbox">  三个（两个）功能</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221121220923548.png" alt="image-20221121220923548"></p><blockquote><p>依次是：模型转换点云、点云降采样、有限元模型外表面抽取。</p></blockquote></li></ul><p><b><font size=4 color=gray>待添加功能</font></b></p><ul><li><input disabled="" type="checkbox"> 有限元模型上任意点/单元的信息和属性查询</li><li><input disabled="" type="checkbox"> 增材CAM相关功能</li><li><input disabled="" type="checkbox"> 点云相关功能（ICP配准、点云手动对齐等）</li><li><input disabled="" type="checkbox"> ……</li></ul><h2 id="部分功能展示"><a href="#部分功能展示" class="headerlink" title="部分功能展示"></a>部分功能展示</h2><h3 id="可视化操作"><a href="#可视化操作" class="headerlink" title="可视化操作"></a>可视化操作</h3><p>![GIF 2022-11-21 22-35-43](D:\OneDrive\桌面\GIF 2022-11-21 22-35-43.gif)</p><h3 id="代理模型预测"><a href="#代理模型预测" class="headerlink" title="代理模型预测"></a>代理模型预测</h3><p>![GIF 2022-11-21 22-49-50](D:\OneDrive\桌面\GIF 2022-11-21 22-49-50.gif)</p><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><p>![GIF 2022-11-21 22-57-37](D:\OneDrive\桌面\GIF 2022-11-21 22-57-37.gif)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>记录第一次QT5+VTK开发工具的点滴，总共历时五天。在这期间每天都很充实，持续在：<code>产生需求--&gt;开源学习--&gt;编写程序--&gt;调试程序--&gt;产生下一个需求--&gt;……</code>的状态。并且深刻认识到了实践的重要性，通过对这个小工具的开发，我逐步上手QT5和VTK。对于VTK，上半年就有接触了，不过一直被其各种数据结构劝退，觉得numpy数组最好用（当时网格计算接触的比较多），不过到现在见识到了VTK在很多数据结构上的表现（特别是vtkUnstructuredGrid与有限元数据模型，恰到好处），加之对VTK的管线机制和各种Filter深入了解之后，现在频频“真香”。回到工具本身，其实尚存许多bug，且代码臃肿，后期还需调试和优化。</p><p>同时，PinkCAx工具的开发借鉴了许多开源代码，开源万岁！</p><blockquote><p>有一说一，这个粉色还挺好看的。#f187b8 / 241,135,18。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【VTK+有限元后处理】符号化矢量场绘制</title>
    <link href="/2022/11/20/%E3%80%90VTK+%E6%9C%89%E9%99%90%E5%85%83%E5%90%8E%E5%A4%84%E7%90%86%E3%80%91%E7%AC%A6%E5%8F%B7%E5%8C%96%E7%9F%A2%E9%87%8F%E5%9C%BA%E7%BB%98%E5%88%B6/"/>
    <url>/2022/11/20/%E3%80%90VTK+%E6%9C%89%E9%99%90%E5%85%83%E5%90%8E%E5%A4%84%E7%90%86%E3%80%91%E7%AC%A6%E5%8F%B7%E5%8C%96%E7%9F%A2%E9%87%8F%E5%9C%BA%E7%BB%98%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>符号化有限元模型的节点矢量属性（应力等），将其可视化显示。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>构建drawVectorField函数，用于矢量场的符号化显示。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drawVectorField</span>(<span class="hljs-params">self, FEMapper, sample_ratio = <span class="hljs-number">10</span>, scale_ratio = <span class="hljs-number">0.015</span>, symbol = <span class="hljs-string">&#x27;arrow&#x27;</span></span>):</span><br>    self.main_actor.SetMapper(FEMapper)<br>    self.main_actor.GetProperty().SetOpacity(<span class="hljs-number">0.3</span>)  <span class="hljs-comment"># 设置透明度</span><br>    self.main_actor.GetProperty().SetColor(<span class="hljs-number">241</span> / <span class="hljs-number">255</span>, <span class="hljs-number">135</span> / <span class="hljs-number">255</span>, <span class="hljs-number">184</span> / <span class="hljs-number">255</span>)  <span class="hljs-comment"># 设置颜色</span><br>    <span class="hljs-comment"># 数据采样</span><br>    maskPoints = vtk.vtkMaskPoints()<br>    maskPoints.SetInputData(FEMapper.GetInput())<br>    maskPoints.SetOnRatio(sample_ratio)  <span class="hljs-comment"># 采样率</span><br>    maskPoints.Update()<br>    <span class="hljs-comment"># 符号化向量场</span><br>    glyph3D = vtk.vtkGlyph3D()  <span class="hljs-comment"># vtkGlyph3D是一个过滤器，他会将固定的几何数据（符号数据）复制到输入的数据集的每一个点上</span><br>    glyph3D.SetInputData(maskPoints.GetOutput())<br>    <span class="hljs-keyword">if</span> symbol == <span class="hljs-string">&#x27;arrow&#x27;</span>:<br>        arrow = vtk.vtkArrowSource()  <span class="hljs-comment"># 箭头符号</span><br>        arrow.Update()<br>        glyph3D.SetSourceData(arrow.GetOutput())  <span class="hljs-comment"># 设置符号</span><br>    <span class="hljs-keyword">elif</span> symbol == <span class="hljs-string">&#x27;cone&#x27;</span>:<br>        cone = vtk.vtkConeSource()  <span class="hljs-comment"># 圆锥符号</span><br>        cone.SetResolution(<span class="hljs-number">6</span>)  <span class="hljs-comment"># 设置用于表示圆锥的面数</span><br>        cone.Update()<br>        glyph3D.SetSourceData(cone.GetOutput())  <span class="hljs-comment"># 设置符号</span><br>    <span class="hljs-comment"># glyph3D.SetVectorModeToUseNormal()  # 使用法向控制符号方向</span><br>    glyph3D.SetVectorModeToUseVector()  <span class="hljs-comment"># 使用向量控制符号方向</span><br>    glyph3D.SetScaleModeToScaleByVector()  <span class="hljs-comment"># 使用点上的vector数据控制缩放</span><br>    <span class="hljs-comment"># glyph3D.SetScaleModeToDataScalingOff()  # 这里没有标量，所以关闭符号缩放控制</span><br>    glyph3D.SetScaleFactor(scale_ratio)  <span class="hljs-comment"># 设置缩放比例</span><br>    glyph3D.Update()<br><br>    glMapper = vtk.vtkDataSetMapper()<br>    glMapper.SetInputData(glyph3D.GetOutput())<br>    glMapper.Update()<br>    glActor = vtk.vtkActor()<br>    glActor.SetMapper(glMapper)<br>    glActor.GetProperty().SetColor(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.79</span>, <span class="hljs-number">0.34</span>)  <span class="hljs-comment"># glyphActor</span><br><br>    self.renderer.AddActor(self.main_actor)<br>    self.renderer.AddActor(glActor)<br></code></pre></td></tr></table></figure><p>在上面代码中，由于有限元模型通常节点和单元数量很多，为了方便观察，我们可以对数据进行降采样。关键代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">maskPoints.SetOnRatio(sample_ratio)  <span class="hljs-comment"># 采样率</span><br></code></pre></td></tr></table></figure><p>其中<code>sample_ratio</code>为采样率。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>![GIF 2022-11-20 9-33-08](D:\OneDrive\桌面\GIF 2022-11-20 9-33-08.gif)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="http://cppdebug.com/archives/265">VTK使数据符号化显示矢量数据</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【VTK+有限元后处理】实时剖切视图</title>
    <link href="/2022/11/19/%E3%80%90VTK+%E6%9C%89%E9%99%90%E5%85%83%E5%90%8E%E5%A4%84%E7%90%86%E3%80%91%E5%AE%9E%E6%97%B6%E5%89%96%E5%88%87%E8%A7%86%E5%9B%BE/"/>
    <url>/2022/11/19/%E3%80%90VTK+%E6%9C%89%E9%99%90%E5%85%83%E5%90%8E%E5%A4%84%E7%90%86%E3%80%91%E5%AE%9E%E6%97%B6%E5%89%96%E5%88%87%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>实现后处理结果云图的平面剖切视图。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>通过使用<code>vtkPlaneWidget</code>控件交互，得到剖切平面，通过<code>vtkClipDataSet</code>完成对<code>vtkUnstructuredGrid</code>有限元结果数据的剖切操作。渲染管线如下图所示$^{[1]}$。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221119155430445.png" alt="image-20221119155430445"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先，我们先写一个创建vtkPlaneWidget控件的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clipFEModel_planeWidget</span>(<span class="hljs-params">self, ugrid</span>):</span><br>    <span class="hljs-comment"># 三维切割平面控件构建</span><br>    self.planeWidget = vtk.vtkPlaneWidget()<br>    self.planeWidget.SetInteractor(self.interactor)  <span class="hljs-comment"># 与交互器关联</span><br>    self.planeWidget.SetInputData(ugrid)  <span class="hljs-comment"># 设置数据集，用于初始化平面，可以不设置</span><br>    self.planeWidget.SetResolution(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 即：设置网格数</span><br>    self.planeWidget.GetPlaneProperty().SetColor(<span class="hljs-number">.2</span>, <span class="hljs-number">.8</span>, <span class="hljs-number">0.1</span>)  <span class="hljs-comment"># 设置颜色</span><br>    self.planeWidget.GetPlaneProperty().SetOpacity(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 设置透明度</span><br>    self.planeWidget.GetPlaneProperty().SetLineWidth(<span class="hljs-number">4</span>)<br>    self.planeWidget.GetHandleProperty().SetColor(<span class="hljs-number">0</span>, <span class="hljs-number">.4</span>, <span class="hljs-number">.7</span>)  <span class="hljs-comment"># 设置平面顶点颜色</span><br>    self.planeWidget.GetHandleProperty().SetPointSize(<span class="hljs-number">1</span>)<br>    self.planeWidget.GetHandleProperty().SetLineWidth(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 设置平面线宽</span><br>    self.planeWidget.NormalToZAxisOn()  <span class="hljs-comment"># 初始法线方向平行于Z轴</span><br>    self.planeWidget.SetRepresentationToWireframe()  <span class="hljs-comment"># 平面显示为网格属性 SetRepresentationToSurface()</span><br>    self.planeWidget.SetCenter(ugrid.GetCenter())  <span class="hljs-comment"># 设置平面坐标</span><br>    self.planeWidget.SetPlaceFactor(<span class="hljs-number">1.0</span>)<br>    self.planeWidget.PlaceWidget()  <span class="hljs-comment"># 放置平面</span><br>    self.planeWidget.On()  <span class="hljs-comment"># 显示平面</span><br><br>    <span class="hljs-comment">#  设置vtkPlaneCallback</span><br>    self.planeWidget.AddObserver(vtk.vtkCommand.InteractionEvent, vtkPlaneCall(self, ugrid))<br></code></pre></td></tr></table></figure><p>上面代码中，通过<code>self.planeWidget.AddObserver(vtk.vtkCommand.InteractionEvent, vtkPlaneCall(self, ugrid))</code>，设置了平面控件的回调函数，传入ugrid参数，即我们的<code>vtkUnstructuredGrid</code>有限元剖切对象。回调类<code>vtkPlaneCall</code>定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">vtkPlaneCall</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, sceneManager, ugrid</span>):</span><br>        self.sceneManager = sceneManager<br>        self.ugrid = ugrid<br>        self.clippingPlane = vtk.vtkPlane()  <span class="hljs-comment"># 剖切平面</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, caller, ev</span>):</span><br>        caller.GetPlane(self.clippingPlane)  <span class="hljs-comment"># 得到当前planeWidget的平面，作为剖切平面</span><br><br>        clipper = vtk.vtkClipDataSet()<br>        clipper.SetClipFunction(self.clippingPlane)  <span class="hljs-comment"># 设置剖切方法为平面剖切</span><br>        clipper.SetInputData(self.ugrid)  <span class="hljs-comment"># 设置剖切对象</span><br>        <span class="hljs-comment"># clipper.SetValue(0.0)</span><br>        clipper.GenerateClippedOutputOn()<br>        clipper.Update()<br><br>        insideMapper = vtk.vtkDataSetMapper()<br>        insideMapper.SetInputData(clipper.GetOutput())<br>        insideMapper.ScalarVisibilityOn()<br><br>        self.sceneManager.drawOutline(self.ugrid)<br><br>        <span class="hljs-comment"># clippedMapper = vtk.vtkDataSetMapper()</span><br>        <span class="hljs-comment"># clippedMapper.SetInputData(clipper.GetClippedOutput())</span><br>        <span class="hljs-comment"># clippedMapper.ScalarVisibilityOn()</span><br><br>        scalarRange = clipper.GetOutput().GetPointData().GetScalars().GetRange()<br>        title = clipper.GetOutput().GetPointData().GetScalars().GetName()<br>        self.sceneManager.drawScalarField(insideMapper, scalarRange, title)<br>        self.sceneManager.display()<br></code></pre></td></tr></table></figure><p>这里的<code>sceneManager</code>参数为显示管理类，主要用于可视化渲染。<code>drawScalarField</code>函数为云图绘制函数，具体实现细节参加：<a href="https://blog.csdn.net/qq_39784672/article/details/127931413">【VTK+有限元后处理】可视化结果云图</a>。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>![GIF 2022-11-19 16-18-47](D:\OneDrive\桌面\GIF 2022-11-19 16-18-47.gif)</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 陈航. 基于Qt和VTK的铸造有限元后处理可视化系统研发[D]. 湖北:华中科技大学,2018. DOI:10.7666/d.D01542051.</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【VTK+有限元后处理】可视化结果云图</title>
    <link href="/2022/11/18/%E3%80%90VTK+%E6%9C%89%E9%99%90%E5%85%83%E5%90%8E%E5%A4%84%E7%90%86%E3%80%91%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BB%93%E6%9E%9C%E4%BA%91%E5%9B%BE/"/>
    <url>/2022/11/18/%E3%80%90VTK+%E6%9C%89%E9%99%90%E5%85%83%E5%90%8E%E5%A4%84%E7%90%86%E3%80%91%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BB%93%E6%9E%9C%E4%BA%91%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="构建vtkUnstructuredGrid对象"><a href="#构建vtkUnstructuredGrid对象" class="headerlink" title="构建vtkUnstructuredGrid对象"></a>构建vtkUnstructuredGrid对象</h2><p>为了读取不同格式的有限元计算结果文件，我们先写一个<code>FEDataModel类</code>来管理有限元的几何拓扑和属性信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FEDataModel</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;有限元数据模型类&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.nodes = []  <span class="hljs-comment"># 节点几何坐标</span><br>        self.elements = []  <span class="hljs-comment"># 单元拓扑信息</span><br>        self.scalars = &#123;&#125;  <span class="hljs-comment"># 节点标量属性</span><br>        self.vectors = &#123;&#125;  <span class="hljs-comment"># 节点向量属性</span><br>        self.ugrid = vtk.vtkUnstructuredGrid()  <span class="hljs-comment"># 用于VTK可视化的数据模型</span><br>        self.ugrid.Allocate(<span class="hljs-number">100</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_inp</span>(<span class="hljs-params">self, filename</span>):</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> f:<br>            node_flag, element_flag = <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f.readlines():<br>                line = line.replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;*ELEMENT&#x27;</span> <span class="hljs-keyword">in</span> line:<br>                    node_flag, element_flag = <span class="hljs-literal">False</span>, <span class="hljs-literal">True</span><br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;*NODE&#x27;</span> <span class="hljs-keyword">in</span> line:<br>                    node_flag, element_flag = <span class="hljs-literal">True</span>, <span class="hljs-literal">False</span><br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">elif</span> <span class="hljs-string">&#x27;*&#x27;</span> <span class="hljs-keyword">in</span> line:<br>                    node_flag, element_flag = <span class="hljs-literal">False</span>, <span class="hljs-literal">False</span><br>                    <span class="hljs-keyword">continue</span><br>                <span class="hljs-keyword">if</span> node_flag:<br>                    self.nodes.append(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">float</span>(x), line.split(<span class="hljs-string">&#x27;,&#x27;</span>)))[<span class="hljs-number">1</span>:])<br>                <span class="hljs-keyword">elif</span> element_flag:<br>                    self.elements.append(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">int</span>(x) - <span class="hljs-number">1</span>, line.split(<span class="hljs-string">&#x27;,&#x27;</span>)))[<span class="hljs-number">1</span>:])<br>        <span class="hljs-comment"># print(len(self.nodes), len(self.elements))</span><br><br>        nodes = vtk.vtkPoints()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(self.nodes)):<br>            nodes.InsertPoint(i, self.nodes[i])<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(self.elements)):<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.elements[i]) == <span class="hljs-number">4</span>:  <span class="hljs-comment"># 四面体单元</span><br>                self.ugrid.InsertNextCell(vtk.VTK_TETRA, <span class="hljs-number">4</span>, self.elements[i])<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(self.elements[i]) == <span class="hljs-number">6</span>:  <span class="hljs-comment"># 六面体单元</span><br>                self.ugrid.InsertNextCell(vtk.VTK_POLYGON, <span class="hljs-number">6</span>, self.elements[i])<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(self.elements[i]) == <span class="hljs-number">3</span>:  <span class="hljs-comment"># 三角面片单元</span><br>                self.ugrid.InsertNextCell(vtk.VTK_TRIANGLE, <span class="hljs-number">3</span>, self.elements[i])<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;FEDataModel构建中遇到错误单元类型！&quot;</span>)<br>        self.ugrid.SetPoints(nodes)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_ntl</span>(<span class="hljs-params">self, filename</span>):</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename) <span class="hljs-keyword">as</span> f:<br>            lines = f.readlines()<br>            attribute_name = <span class="hljs-string">&#x27;&#x27;</span>.join(lines[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">1</span>:-<span class="hljs-number">1</span>])<br>            scalar = []<br>            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines[<span class="hljs-number">4</span>:]:<br>                line = line.replace(<span class="hljs-string">&#x27;\n&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).split(<span class="hljs-string">&#x27; &#x27;</span>)<br>                scalar.append(<span class="hljs-built_in">float</span>(line[-<span class="hljs-number">1</span>]))<br>            self.scalars[attribute_name] = scalar<br>        <span class="hljs-comment"># print(attribute_name + &#x27; scalar number: &#x27; + str(len(scalar)))</span><br><br>        <span class="hljs-comment"># 存储标量值</span><br>        scalars = vtk.vtkFloatArray()<br>        scalars.SetName(attribute_name)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(scalar)):<br>            scalars.InsertTuple1(i, scalar[i])<br>        <span class="hljs-comment"># 设定每个节点的标量值</span><br>        self.ugrid.GetPointData().SetScalars(scalars)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display</span>(<span class="hljs-params">self</span>):</span><br>        renderer = vtk.vtkRenderer()<br>        renWin = vtk.vtkRenderWindow()<br>        renWin.AddRenderer(renderer)<br>        iren = vtk.vtkRenderWindowInteractor()<br>        iren.SetRenderWindow(renWin)<br><br>        colors = vtk.vtkNamedColors()<br>        ugridMapper = vtk.vtkDataSetMapper()<br>        ugridMapper.SetInputData(self.ugrid)<br><br>        ugridActor = vtk.vtkActor()<br>        ugridActor.SetMapper(ugridMapper)<br>        ugridActor.GetProperty().SetColor(colors.GetColor3d(<span class="hljs-string">&quot;Peacock&quot;</span>))<br>        ugridActor.GetProperty().EdgeVisibilityOn()<br><br>        renderer.AddActor(ugridActor)<br>        renderer.SetBackground(colors.GetColor3d(<span class="hljs-string">&quot;Beige&quot;</span>))<br><br>        renderer.ResetCamera()<br>        renderer.GetActiveCamera().Elevation(<span class="hljs-number">60.0</span>)<br>        renderer.GetActiveCamera().Azimuth(<span class="hljs-number">30.0</span>)<br>        renderer.GetActiveCamera().Dolly(<span class="hljs-number">1.2</span>)<br>        renWin.SetSize(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>)<br>        <span class="hljs-comment"># Interact with the data.</span><br>        renWin.Render()<br>        iren.Start()<br></code></pre></td></tr></table></figure><p>这个类的作用是，方便我们读取并构建用于在VTK中显示的<code>vtkUnstructuredGrid</code>类对象。<code>vtkUnstructuredGrid</code>类是VTK中的非结构化网格类，可用于有限元分析、计算几何和几何建模这类领域。</p><p><code>vtkUnstructuredGrid</code>类详情参见：<a href="https://blog.csdn.net/liushao1031177/article/details/120708061">VTK笔记-使用vtkUnstructuredGrid类构建非结构化数据</a>。</p><p>其中<code>read_inp</code>成员函数和<code>read_ntl</code>成员函数分别用于读取从ProCAST软件中导出的inp文件（存储有限元的几何拓扑数据）和ntl文件（存储有限元的节点属性数据，如温度、应力等）。</p><h2 id="存储vtkUnstructuredGrid对象"><a href="#存储vtkUnstructuredGrid对象" class="headerlink" title="存储vtkUnstructuredGrid对象"></a>存储vtkUnstructuredGrid对象</h2><p>为了能一次性读取有限元模型整体数据，我们可以将其保存为vtk格式的文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">writer = vtk.vtkUnstructuredGridWriter()<br>writer.SetFileName(save_fn)<br>writer.SetInputData(self.FEModel.ugrid)<br>writer.Write()<br>writer.Update()<br></code></pre></td></tr></table></figure><p>下一次只需读取对应的vtk文件即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">reader = vtk.vtkUnstructuredGridReader()<br>reader.SetFileName(read_fn)<br>reader.Update()<br>self.FEModel.ugrid = reader.GetOutput()<br></code></pre></td></tr></table></figure><h2 id="云图可视化"><a href="#云图可视化" class="headerlink" title="云图可视化"></a>云图可视化</h2><p>可视化节点属性数据（标量场），关键代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drawScalarField</span>(<span class="hljs-params">self, scalar_mapper, scalarRange, title</span>):</span><br>    <span class="hljs-comment"># 定义颜色映射表</span><br>    lut = vtk.vtkLookupTable()<br>    lut.SetHueRange(<span class="hljs-number">0.67</span>, <span class="hljs-number">0.0</span>)  <span class="hljs-comment"># 色调范围从红色到蓝色</span><br>    <span class="hljs-comment"># lut.SetAlphaRange(1.0, 1.0) # 透明度范围</span><br>    <span class="hljs-comment"># lut.SetValueRange(1.0, 1.0)</span><br>    <span class="hljs-comment"># lut.SetSaturationRange(1.0, 1.0) # 颜色饱和度</span><br>    <span class="hljs-comment"># lut.SetNumberOfTableValues(256)</span><br>    lut.SetNumberOfColors(<span class="hljs-number">256</span>)  <span class="hljs-comment"># 颜色个数</span><br>    <span class="hljs-comment"># lut.SetRange(scalarRange)</span><br>    lut.Build()<br><br>    scalar_mapper.SetScalarRange(scalarRange)<br>    scalar_mapper.SetLookupTable(lut)<br>    scalar_actor = vtk.vtkActor()<br>    scalar_actor.SetMapper(scalar_mapper)<br>    self.renderer.AddActor(scalar_actor)<br>    <span class="hljs-comment"># 色标带</span><br>    scalarBar = vtk.vtkScalarBarActor()<br>    scalarBar.SetLookupTable(scalar_mapper.GetLookupTable())  <span class="hljs-comment"># 将颜色查找表传入窗口中的色标带</span><br>    scalarBar.SetTitle(title)<br>    scalarBar.SetNumberOfLabels(<span class="hljs-number">5</span>)<br>    self.renderer.AddActor2D(scalarBar)<br></code></pre></td></tr></table></figure><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p>![GIF 2022-11-18 23-13-41](D:\OneDrive\桌面\GIF 2022-11-18 23-13-41.gif)</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ProCAST一键导出有限元模型的几何拓扑和属性信息</title>
    <link href="/2022/11/18/ProCAST%E4%B8%80%E9%94%AE%E5%AF%BC%E5%87%BA%E6%9C%89%E9%99%90%E5%85%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%87%A0%E4%BD%95%E6%8B%93%E6%89%91%E5%92%8C%E5%B1%9E%E6%80%A7%E4%BF%A1%E6%81%AF/"/>
    <url>/2022/11/18/ProCAST%E4%B8%80%E9%94%AE%E5%AF%BC%E5%87%BA%E6%9C%89%E9%99%90%E5%85%83%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%87%A0%E4%BD%95%E6%8B%93%E6%89%91%E5%92%8C%E5%B1%9E%E6%80%A7%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p>第一次将ProCast有限元后处理中的数据导出，当时没有经验，方法比较粗暴，详情见文章：<a href="https://blog.csdn.net/qq_39784672/article/details/127621354">ProCast导出节点应力数据并格式化</a>。</p><p>最近发现了一种更高效的数据导出“新姿势”，能够快速得到有限元模型的几何拓扑和节点属性数据，在此记录并分享二三。</p><h2 id="几何拓扑导出"><a href="#几何拓扑导出" class="headerlink" title="几何拓扑导出"></a>几何拓扑导出</h2><p>打开有限元模型文件，切换到Visual-Mesh。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221118115803405.png" alt="image-20221118115803405"></p><p>如果模型是装配体，而我们只需要导出其中一个零件的几何信息，这时需要<strong>将其他零件隐藏</strong>。</p><p>然后，点击File–&gt;Export。选择ABAQUS类型，导出文件为inp格式。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221118120304365.png" alt="image-20221118120304365"></p><p>导出文件详细信息如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs routeros">** -------------------------------------------------------<br>** ABAQUS input file<br>** File exported by VISUAL-ENVIRONMENT : Version17.5 <br>**      on 2022-11-18, at 11Hr:3min<br>** -------------------------------------------------------<br>**LENGTH UNITS: mm <br><span class="hljs-number">*E</span>LEMENT, <span class="hljs-attribute">TYPE</span>=C3D4, <span class="hljs-attribute">ELSET</span>=zhujian<br>         1,         1,         2,         3,         4<br>         2,         5,         1,         3,         4<br>         <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><br>         101388,     24146,     24143,     24141,     24142<br>     101389,     24146,     24143,     24142,     24144<br>*NODE<br>         1,  -13.858259916305541992,  -4.2456129193305969238,   310.65000534057617188<br>         2,   -14.32300567626953125,  -5.8872079849243164062,   310.3173065185546875<br>         3,  -14.427429437637329102,  -5.7955080270767211914,   309.04352188110351562  <br>         <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><br>         24153,  -24.285211563110351562,   50.369749069213867188,   517.00000762939453125<br>         24154,   3.8816422224044799805,   6.9511991739273071289,   517.00000762939453125<br><span class="hljs-number">*E</span>LEMENT, <span class="hljs-attribute">TYPE</span>=C3D4, <span class="hljs-attribute">ELSET</span>=lengtong<br><span class="hljs-number">*E</span>LEMENT, <span class="hljs-attribute">TYPE</span>=C3D4, <span class="hljs-attribute">ELSET</span>=moke<br><span class="hljs-number">*E</span>LEMENT, <span class="hljs-attribute">TYPE</span>=S3, <span class="hljs-attribute">ELSET</span>=ENCLOSURE<br>*SOLID SECTION, <span class="hljs-attribute">ELSET</span>=zhujian, <span class="hljs-attribute">MATERIAL</span>=Material<br>*SOLID SECTION, <span class="hljs-attribute">ELSET</span>=lengtong, <span class="hljs-attribute">MATERIAL</span>=Material<br>*SOLID SECTION, <span class="hljs-attribute">ELSET</span>=moke, <span class="hljs-attribute">MATERIAL</span>=Material<br>*SHELL SECTION, <span class="hljs-attribute">ELSET</span>=ENCLOSURE, SECTION <span class="hljs-attribute">INTEGRATION</span>=GAUSS<br>                      0.,         0<br></code></pre></td></tr></table></figure><p>在文件中，保存了四面体单元数据（ELEMENT）和节点数据（NODE）。</p><h2 id="节点属性数据导出"><a href="#节点属性数据导出" class="headerlink" title="节点属性数据导出"></a>节点属性数据导出</h2><p>节点属性数据包括：节点上的温度、应力等等标量或向量数据。</p><p>切换到Visual-Viewer。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221118121154018.png" alt="image-20221118121154018"></p><p>同样，将不需要导出的零件隐藏。其次，导出的数据以主视图窗口中显示的数据为准。选择<code>Export As</code>。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221118121317939.png" alt="image-20221118121317939"></p><p>选择PATRAN类型，导出ntl格式文件。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221118121803246.png" alt="image-20221118121803246"></p><p>导出文件详细信息如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">ProCAST TEMPERATURE RESULTS<br>   <span class="hljs-number"> 24154 </span>      <span class="hljs-number"> 0 </span>      0.000000       <span class="hljs-number"> 0 </span>       1<br>ESI<br><br>      <span class="hljs-number"> 1 </span> 2.585213E+02<br>      <span class="hljs-number"> 2 </span> 2.587285E+02<br>      <span class="hljs-number"> 3 </span> 2.594008E+02<br>       ......<br></code></pre></td></tr></table></figure><p>其中第一列为Node的编号，第二列为属性数据值。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【PyQt5】Model-View分类文件树</title>
    <link href="/2022/11/17/%E3%80%90PyQt5%E3%80%91Model-View%E5%88%86%E7%B1%BB%E6%96%87%E4%BB%B6%E6%A0%91/"/>
    <url>/2022/11/17/%E3%80%90PyQt5%E3%80%91Model-View%E5%88%86%E7%B1%BB%E6%96%87%E4%BB%B6%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>实现一个基于model/view的文件树。具体需求为：打开文件夹后，将文件夹目录下所有的文件归类到不同的父节点下，并通过信号槽机制实现自定义的双击文件事件。</p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>UI代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_fileTreeView</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-comment"># 创建自定义文件树目录</span><br>    self.fileTreeModel = MyFileTreeModel()<br>    self.file_treeView = QtWidgets.QTreeView(self.fileTree_widget)<br>    self.file_treeView.setModel(self.fileTreeModel)<br>    self.file_treeView.header().setVisible(<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 隐藏表头标题</span><br>    self.file_treeView.doubleClicked.connect(self.file_tree_cilcked)<br>    <span class="hljs-comment"># 将创建的窗口进行添加</span><br>    self.layout = QtWidgets.QHBoxLayout(self.fileTree_widget)<br>    self.layout.addWidget(self.file_treeView)<br></code></pre></td></tr></table></figure><p>其中MyFileTreeModel类为自定义的Model类，具体细节参考文章：<a href="https://blog.csdn.net/qq_39784672/article/details/127894718">【PyQt5】QTreeView使用自定义Model</a>。其中<code>self.file_tree_cilcked</code>为自定义的文件树文件双击信号对应的槽函数。</p><p>在MyFileTreeModel类中实现<code>updataData()</code>函数用于更新Model的数据。相关代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 更新模型数据</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updataData</span>(<span class="hljs-params">self, data</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    模型数据构建，可修改拓展</span><br><span class="hljs-string">    :param data: 数据源</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    self.beginResetModel()  <span class="hljs-comment"># 模型重置开始</span><br>    <span class="hljs-comment"># 废弃旧模型数据</span><br>    <span class="hljs-keyword">if</span> self.rootItem:<br>        <span class="hljs-keyword">del</span> self.rootItem<br>        self.rootItem = <span class="hljs-literal">None</span><br><br>    rootData = [<span class="hljs-string">&#x27;FileType&#x27;</span>]<br>    self.rootItem = MyFileTreeItem(rootData)<br>    self._setupModelData(self.rootItem, data)<br>    self.endResetModel()  <span class="hljs-comment"># 模型重置结束</span><br><br><span class="hljs-comment"># 构建模型数据</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_setupModelData</span>(<span class="hljs-params">self, parent, data</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    模型数据构建，可修改拓展</span><br><span class="hljs-string">    :param parent: MyFileTreeItem,父节点</span><br><span class="hljs-string">    :param data: 数据源</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    sorted_data = self._sortFiles(data)  <span class="hljs-comment"># 文件分类</span><br>    father_data = [<span class="hljs-string">&#x27;STL几何模型&#x27;</span>, <span class="hljs-string">&#x27;VTK文件&#x27;</span>, <span class="hljs-string">&#x27;应力场&#x27;</span>, <span class="hljs-string">&#x27;温度场&#x27;</span>, <span class="hljs-string">&#x27;杂项文件&#x27;</span>]  <span class="hljs-comment"># 文件父节点，类别</span><br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> father_data:<br>        primary = MyFileTreeItem([data], parent)<br>        parent.appendChild(primary)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sorted_data[data]) != <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">for</span> ds <span class="hljs-keyword">in</span> sorted_data[data]:<br>                primary.appendChild(MyFileTreeItem([ds], primary))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_sortFiles</span>(<span class="hljs-params">self, fileNames</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;根据输入的文件名，按文件后缀名进行分类&quot;&quot;&quot;</span><br>    sorted_data = &#123;<span class="hljs-string">&#x27;STL几何模型&#x27;</span>: [], <span class="hljs-string">&#x27;VTK文件&#x27;</span>: [], <span class="hljs-string">&#x27;应力场&#x27;</span>: [], <span class="hljs-string">&#x27;温度场&#x27;</span>: [], <span class="hljs-string">&#x27;杂项文件&#x27;</span>: []&#125;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(fileNames) != <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">for</span> fn <span class="hljs-keyword">in</span> fileNames:<br>            suffix = os.path.splitext(fn)[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 读取文件后缀名</span><br>            <span class="hljs-keyword">if</span> suffix == <span class="hljs-string">&#x27;.stl&#x27;</span> <span class="hljs-keyword">or</span> suffix == <span class="hljs-string">&#x27;.STL&#x27;</span>:<br>                sorted_data[<span class="hljs-string">&#x27;STL几何模型&#x27;</span>].append(fn)<br>            <span class="hljs-keyword">elif</span> suffix == <span class="hljs-string">&#x27;.vtk&#x27;</span>:<br>                sorted_data[<span class="hljs-string">&#x27;VTK文件&#x27;</span>].append(fn)<br>            <span class="hljs-keyword">elif</span> suffix == <span class="hljs-string">&#x27;.xtem&#x27;</span>:<br>                sorted_data[<span class="hljs-string">&#x27;温度场&#x27;</span>].append(fn)<br>            <span class="hljs-keyword">else</span>:<br>                sorted_data[<span class="hljs-string">&#x27;杂项文件&#x27;</span>].append(fn)<br>    <span class="hljs-keyword">return</span> sorted_data<br></code></pre></td></tr></table></figure><p>其中输入<code>updataData()</code>函数的参数<code>data</code>为文件夹下所以文件名列表，获取代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">folder_open</span>(<span class="hljs-params">self</span>):</span><br>    self.files_list = []  <span class="hljs-comment"># 文件列表</span><br>    <span class="hljs-comment"># 选择文件夹</span><br>    dir_path = QtWidgets.QFileDialog.getExistingDirectory(self, <span class="hljs-string">&#x27;打开文件夹&#x27;</span>, self.last_path)<br>    <span class="hljs-keyword">if</span> dir_path:<br>        self.last_path = dir_path<br>        self.setting.setValue(<span class="hljs-string">&#x27;LastFilePath&#x27;</span>, self.last_path)  <span class="hljs-comment"># 保存当前目录的路径到配置文件中</span><br>        <span class="hljs-comment"># 读取文件夹文件</span><br>        self.files_list.clear()<br>        <span class="hljs-comment"># 去除子文件夹名 <span class="hljs-doctag">TODO:</span> 判断方法有待优化</span><br>        self.files_list = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> os.listdir(dir_path) <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">in</span> i]<br>        self.fileTreeModel.updataData(self.files_list)<br></code></pre></td></tr></table></figure><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/GIF%202022-11-17%2023-39-49.gif" alt="GIF 2022-11-17 23-39-49"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://blog.csdn.net/qq_39784672/article/details/127894718">【PyQt5】QTreeView使用自定义Model</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【PyQt5】QTreeView使用自定义Model</title>
    <link href="/2022/11/16/%E3%80%90PyQt5%E3%80%91QTreeView%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89Model/"/>
    <url>/2022/11/16/%E3%80%90PyQt5%E3%80%91QTreeView%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89Model/</url>
    
    <content type="html"><![CDATA[<h2 id="Python代码"><a href="#Python代码" class="headerlink" title="Python代码"></a>Python代码</h2><p>TreeModel.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> PyQt5.Qt<br><span class="hljs-keyword">import</span> PyQt5.QtGui<br><span class="hljs-keyword">from</span> PyQt5.QtCore <span class="hljs-keyword">import</span> QAbstractItemModel, QVariant, QModelIndex, Qt<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeItem</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, data, parent = <span class="hljs-literal">None</span></span>):</span><br>        self.parentItem = parent  <span class="hljs-comment"># 父节点</span><br>        self.childItems = []  <span class="hljs-comment"># 子节点</span><br>        self.itemData = data  <span class="hljs-comment"># 子节点对应数据</span><br>        self._row = -<span class="hljs-number">1</span>  <span class="hljs-comment"># 此item位于父节点第几个</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">appendChild</span>(<span class="hljs-params">self, child</span>):</span><br>        child.setRow(<span class="hljs-built_in">len</span>(self.childItems))<br>        self.childItems.append(child)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">child</span>(<span class="hljs-params">self, row</span>):</span><br>        <span class="hljs-keyword">return</span> self.childItems[row]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">childCount</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.childItems)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">columnCount</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.itemData)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data</span>(<span class="hljs-params">self, column</span>):</span><br>        <span class="hljs-keyword">return</span> self.itemData[column]<br><br>    <span class="hljs-comment"># 保存该节点是其父节点的第几个子节点，查询优化所用</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setRow</span>(<span class="hljs-params">self, row: <span class="hljs-built_in">int</span></span>):</span><br>        self._row = row<br><br>    <span class="hljs-comment"># 返回本节点位于父节点下第几个子节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">row</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self._row<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parent</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.parentItem<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeModel</span>(<span class="hljs-params">QAbstractItemModel</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent = <span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>(TreeModel, self).__init__()<br>        self.rootItem = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 最顶层根节点</span><br>        self.updataData()<br><br>    <span class="hljs-comment"># 在parent节点下，第row行，第column列位置上创建索引</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data</span>(<span class="hljs-params">self, index: QModelIndex, role: <span class="hljs-built_in">int</span> = ...</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> index.isValid():<br>            <span class="hljs-keyword">return</span> QVariant()<br>        <span class="hljs-comment"># 添加图标</span><br>        <span class="hljs-keyword">if</span> role == Qt.DecorationRole <span class="hljs-keyword">and</span> index.column() == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> PyQt5.QtGui.QIcon(<span class="hljs-string">&quot;images/snapshot.png&quot;</span>)<br>        <span class="hljs-comment"># 显示节点数据值</span><br>        <span class="hljs-keyword">if</span> role == Qt.DisplayRole:<br>            item = index.internalPointer()<br>            <span class="hljs-keyword">return</span> item.data(index.column())<br>        <span class="hljs-keyword">return</span> QVariant()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flags</span>(<span class="hljs-params">self, index: QModelIndex</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> index.isValid():<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> Qt.ItemIsEnabled | Qt.ItemIsSelectable<br><br>    <span class="hljs-comment"># 获取表头数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">headerData</span>(<span class="hljs-params">self, section: <span class="hljs-built_in">int</span>, orientation: Qt.Orientation, role: <span class="hljs-built_in">int</span> = ...</span>) -&gt; QVariant:</span><br>        <span class="hljs-keyword">if</span> orientation == Qt.Horizontal <span class="hljs-keyword">and</span> role == Qt.DisplayRole:<br>            <span class="hljs-keyword">return</span> self.rootItem.data(section)<br>        <span class="hljs-keyword">return</span> QVariant()<br><br>    <span class="hljs-comment"># 在parent节点下，第row行，第column列位置上创建索引</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>(<span class="hljs-params">self, row: <span class="hljs-built_in">int</span>, column: <span class="hljs-built_in">int</span>, parent: QModelIndex = ...</span>) -&gt; QModelIndex:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.hasIndex(row, column, parent):<br>            <span class="hljs-keyword">return</span> QModelIndex()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> parent.isValid():<br>            parentItem = self.rootItem<br>        <span class="hljs-keyword">else</span>:<br>            parentItem = parent.internalPointer()<br>        childItem = parentItem.child(row)<br>        <span class="hljs-keyword">if</span> childItem:<br>            <span class="hljs-keyword">return</span> self.createIndex(row, column, childItem)  <span class="hljs-comment"># 展开树形，为子节点建立索引</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> QModelIndex()<br><br>    <span class="hljs-comment"># 创建index的父索引</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parent</span>(<span class="hljs-params">self, index: QModelIndex</span>) -&gt; QModelIndex:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> index.isValid():<br>            <span class="hljs-keyword">return</span> QModelIndex()<br>        childItem = index.internalPointer()<br>        parentItem = childItem.parent()<br>        <span class="hljs-comment"># 顶层节点，直接返回空索引</span><br>        <span class="hljs-keyword">if</span> parentItem == self.rootItem:<br>            <span class="hljs-keyword">return</span> QModelIndex()<br>        <span class="hljs-comment"># 为父节点建立索引</span><br>        <span class="hljs-keyword">return</span> self.createIndex(parentItem.row(), <span class="hljs-number">0</span>, parentItem)<br><br>    <span class="hljs-comment"># 获取索引parent下有多少行</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rowCount</span>(<span class="hljs-params">self, parent: QModelIndex = ...</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> parent.isValid():<br>            parentItem = self.rootItem<br>        <span class="hljs-keyword">else</span>:<br>            parentItem = parent.internalPointer()<br>        <span class="hljs-keyword">return</span> parentItem.childCount()  <span class="hljs-comment"># 返回父节点下子节点数目</span><br><br>    <span class="hljs-comment"># 返回索引parent下有多少列</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">columnCount</span>(<span class="hljs-params">self, parent: QModelIndex = ...</span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        <span class="hljs-keyword">return</span> self.rootItem.columnCount()<br><br>    <span class="hljs-comment"># 构建模型数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setupModelData</span>(<span class="hljs-params">self, parent</span>):</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>            datas = [<span class="hljs-string">f&quot;设备-<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>&quot;</span>, <span class="hljs-string">f&quot;类型-<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>&quot;</span>]<br>            <span class="hljs-comment"># 主节点下挂两个子节点</span><br>            primary = TreeItem(datas, parent)<br>            parent.appendChild(primary)<br><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>                ds = [<span class="hljs-string">f&quot;子设备-<span class="hljs-subst">&#123;j + <span class="hljs-number">1</span>&#125;</span>&quot;</span>, <span class="hljs-string">f&quot;子类型-<span class="hljs-subst">&#123;j + <span class="hljs-number">1</span>&#125;</span>&quot;</span>]<br>                primary.appendChild(TreeItem(ds, primary))<br><br>    <span class="hljs-comment"># 更新模型数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updataData</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 废弃旧模型数据</span><br>        <span class="hljs-keyword">if</span> self.rootItem:<br>            <span class="hljs-keyword">del</span> self.rootItem<br>            self.rootItem = <span class="hljs-literal">None</span><br><br>        rootData = [<span class="hljs-string">&#x27;Tag&#x27;</span>, <span class="hljs-string">&#x27;Type&#x27;</span>]<br>        self.rootItem = TreeItem(rootData)<br>        self.setupModelData(self.rootItem)<br></code></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>关键测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">self.model = TreeModel()<br>self.treeView = QTreeView(self)<br>self.treeView.setModel(self.model)<br></code></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221116221218293.png" alt="image-20221116221218293"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://blog.csdn.net/specialsun/article/details/84437740">https://blog.csdn.net/specialsun/article/details/84437740</a></p><p>[2] <a href="https://blog.csdn.net/chenyijun/article/details/125564474">https://blog.csdn.net/chenyijun/article/details/125564474</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PyQt5学习笔记</title>
    <link href="/2022/11/15/PyQt5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/15/PyQt5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Qt-Designer使用Tips"><a href="#Qt-Designer使用Tips" class="headerlink" title="Qt Designer使用Tips"></a>Qt Designer使用Tips</h2><ul><li><p>Designer新建窗体中，分为：Dialog、Widget、Main Window三大类。大致选择思路如下：如果是应用主窗体，即需要显示菜单、工具栏、状态栏等，选择Main Window；如果是顶级对话框，选择Dialog；如果不确定，一律选Widget。</p></li><li><p><strong>布局方式：</strong></p><ul><li>绝对布局：通过设置geometry属性进行布局。</li><li>使用布局管理器进行布局：通过使用垂直布局、水平布局、网格布局等进行布局。</li></ul></li><li><p><strong>QSizePolicy类</strong>，该类是布局属性类，描述了控件水平和垂直大小调整策略。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)<br></code></pre></td></tr></table></figure><p>示例化该类需传入两个参数（水平策略，垂直策略），有许多策略取值，部分取值如下表（其中sizeHint()返回为系统推荐该控件的适合（width，height）大小）：</p><table><thead><tr><th>尺寸调整策略</th><th>解释</th></tr></thead><tbody><tr><td>Fixed</td><td>size固定为sizeHint()返回的大小</td></tr><tr><td>Minimum</td><td>size不能小于sizeHint()返回的大小</td></tr><tr><td>Preferred</td><td>最佳size为sizeHint()返回的大小</td></tr><tr><td>Expanding</td><td>sizeHint()为推荐的size，但尽可能地获得更大的空间</td></tr></tbody></table></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity之C#脚本学习笔记</title>
    <link href="/2022/11/14/Unity%E4%B9%8BC#%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/14/Unity%E4%B9%8BC#%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考书籍：《Unity 2017 从入门到精通》</p></blockquote><h2 id="C-脚本编写Tips"><a href="#C-脚本编写Tips" class="headerlink" title="C#脚本编写Tips"></a>C#脚本编写Tips</h2><ul><li><p>所有添加到游戏对象的C#脚本类都必须直接或间接从<code>MonoBehaviour</code>类中继承。</p></li><li><p>使用<code>Start</code>或者<code>Awake</code>函数来初始化类，避免使用构造函数。</p><blockquote><p>Start和Awake函数在一定条件下会被自动调用，称为<strong>必然事件</strong>。常见的必然事件还有Update、FixedUpdate和LateUpdate。</p></blockquote></li><li><p>类名（特指从<code>MonoBehaviour</code>类中继承的行为类）要与脚本文件名相同，否则在添加脚本到游戏对象时会提示错误。</p></li><li><p>协同函数（Coroutines）返回类型必须是IEnumerator，并且用yield return代替yield。</p><blockquote><p>这一条还不是很明白。</p></blockquote></li></ul><h2 id="访问游戏对象和组件"><a href="#访问游戏对象和组件" class="headerlink" title="访问游戏对象和组件"></a>访问游戏对象和组件</h2><p>访问游戏对象（GameObject）</p><ul><li><p>GameObject.Find()：寻找指定名称或路径的游戏对象。</p><p>无法查找隐藏对象，使用方便但效率低下。</p></li><li><p>GameObject.FindWithTag()：寻找指定标签的游戏对象。</p></li><li><p>Transform.Find()：通过名字或路径查找子对象。</p><p>可以查找隐藏对象，前提是transform所在根节点可见（active=true）。查找对象必须是transform节点下的子对象。</p></li></ul><p>访问组件（Component）</p><blockquote><p>一个游戏对象可以包含多个组件，且脚本也属于组件的一种。</p></blockquote><ul><li>GetComponent/GetComponents&lt;组件（类型）名称&gt;()：得到组件/组件列表。</li><li>GetComponentInChildren/GetComponentsInChildren：得到得到对象或对象子物体上的组件/组件列表。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol><li><p>新建命名为Player的空游戏对象，挂载Player.cs脚本。</p></li><li><p>脚本中在Player类中把要访问的游戏对象和组件声明为成员变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#">//声明GameObject成员变量<br>public GameObject cube;<br>//声明Transform成员变量<br>public Transform sphereTransform;<br></code></pre></td></tr></table></figure></li><li><p>返回Unity，此时打开Player的检视视图，发现多了两个值为None的变量Cube和Sphere Transform。</p></li><li><p>将层级视图中的Cube和Sphere拖到Player脚本的对应变量中进行赋值（将对象和组件的引用保存到成员变量中）。实现了在脚本中访问这两个成员变量。</p></li></ol><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114091516041.png" alt="image-20221114091516041"></p><h2 id="协同程序"><a href="#协同程序" class="headerlink" title="协同程序"></a>协同程序</h2><p>Coroutine称为协同程序，可以和主程序并行运行，和多线程类似。</p><h2 id="鼠标输入"><a href="#鼠标输入" class="headerlink" title="鼠标输入"></a>鼠标输入</h2><p>鼠标输入的相关事件包括鼠标移动、按键的点击等。Input类中和鼠标有关的方法和变量如下：</p><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>mousePosition</td><td>获取当前鼠标指针位置的像素坐标（只读）</td></tr><tr><td>GetMouseButtonDown</td><td>鼠标按键按下的第一帧返回true</td></tr><tr><td>GetMouseButton</td><td>鼠标按键按住期间一直返回true</td></tr><tr><td>GetMouseButtonUp</td><td>鼠标按键松开的第一帧返回true</td></tr><tr><td>GetAxis(“Mouse X”)</td><td>得到一帧内鼠标在水平方向的移动距离</td></tr><tr><td>GetAxis(“Mouse Y”)</td><td>得到一帧内鼠标在垂直方向的移动距离</td></tr></tbody></table><blockquote><p>鼠标指针位置通过屏幕的像素坐标来表示。屏幕左下角为原点(0,0)，右上角为(Screen.width,Screen.height)。mousePosition变量类型为Vector3，x分量对应水平坐标，y分量对应垂直坐标，z分量始终为0。</p></blockquote><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#">using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br><br>public class RotateObjControl : MonoBehaviour<br>&#123;<br>    float horizontalSpeed = 2.0f;<br>    float verticalSpeed = 2.0f;<br><br>    // Update is called once per frame<br>    void Update()<br>    &#123;<br>        // 鼠标左键按住，0左键，1右键，2中键<br>        if (Input.GetMouseButton(0))<br>        &#123;<br>            float h = horizontalSpeed * Input.GetAxis(&quot;Mouse X&quot;);<br>            float v = verticalSpeed * Input.GetAxis(&quot;Mouse Y&quot;);<br>            transform.Rotate(v, h, 0);  // 此处的transform是当前脚本挂载对象的组件<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该示例中，脚本通过读取鼠标左键输入控制挂载对象旋转。</p><h2 id="Socket通信"><a href="#Socket通信" class="headerlink" title="Socket通信"></a>Socket通信</h2><h3 id="示例：创建简单的TCP客户端"><a href="#示例：创建简单的TCP客户端" class="headerlink" title="示例：创建简单的TCP客户端"></a>示例：创建简单的TCP客户端</h3><p><strong>创建流程：</strong></p><ol><li>创建Socket对象。</li><li>将新建的Socket对象连接指定的服务器IP和端口号。</li><li>发送数据到服务器和从服务器接收数据。</li></ol><p>首先，初始化客户端，与服务器建立连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#">String address = &quot;127.0.0.1&quot;;<br>int port = 8000;<br><br>IPAddress ip = IPAddress.Parse(address);  //将address地址字符串转换成IPAddress实例<br>ClientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);//使用指定的地址簇协议、套接字类型和通信协议<br>IPEndPoint endPoint = new IPEndPoint(ip, port); // 用指定的ip和端口号初始化IPEndPoint实例<br>ClientSocket.Connect(endPoint);  //与远程主机建立连接<br></code></pre></td></tr></table></figure><blockquote><p>这里的address可以是局域网或者互联网的IP地址，也可以是本机的IP地址（相当于本机既做服务器又做客户端，主要用于开发测试方便）。</p></blockquote><p>客户端向服务器发送数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">string data = &quot;hello mstifiy!&quot;;<br>byte[] message = Encoding.UTF8.GetBytes(data);<br>ClientSocket.Send(message);<br>//ByteBuffer buffer = new ByteBuffer();<br>//buffer.WriteString(data);<br>//ClientSocket.Send(WriteMessage(buffer.ToBytes()));<br></code></pre></td></tr></table></figure><p>客户端从服务器接收数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c#">byte[] receive = new byte[150000];<br>ClientSocket.Receive(receive);<br>string data = Encoding.UTF8.GetString(receive);<br>//ClientSocket.Receive(receive);<br>//ByteBuffer buffer = new ByteBuffer(receive);<br>//string data = buffer.ReadString();<br></code></pre></td></tr></table></figure><h2 id="UGUI"><a href="#UGUI" class="headerlink" title="UGUI"></a>UGUI</h2><h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>Canvas（画布）是存放所以UI的容器，所有的UI都必须放到画布的子节点下。</p><p>Inspector（检视视图）相关设置：</p><table><thead><tr><th>Render Mode</th><th>渲染模式</th></tr></thead><tbody><tr><td>Screen Space-Overlay</td><td>画布拉伸以适应全屏大小，使控件渲染与其他物体前方。</td></tr><tr><td>Screen Space-Camera</td><td>画布以特定的距离放置在指定的相机前，UI被指定相机渲染。</td></tr><tr><td>World Space</td><td>画布和其他游戏对象一样渲染于世界空间，此时可以调整Rect Transform来改变画布大小。</td></tr></tbody></table><table><thead><tr><th>UI Scale Mode</th><th>UI的缩放模式</th></tr></thead><tbody><tr><td>Constant Pixel Size</td><td>固定的像素大小</td></tr><tr><td>Scale With Screen Size</td><td>根据屏幕大小进行缩放</td></tr><tr><td>Constant Physical Size</td><td>固定的物理大小（cm、mm等）</td></tr></tbody></table><h3 id="Slider滑动条示例"><a href="#Slider滑动条示例" class="headerlink" title="Slider滑动条示例"></a>Slider滑动条示例</h3><ul><li>在Scene中创建一个Slider对象，缩放到合适比例。</li></ul><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114203046046.png" alt="image-20221114203046046"></p><p>控件的相关参数和事件说明如下：</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114203855476.png"></p><ul><li><p>事件绑定</p><ul><li><p>可视化创建及事件绑定。</p><p>新建脚本TestSlider.cs，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#">using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br><br>public class TestSlider : MonoBehaviour<br>&#123;<br>    public void SliderOnValueChanged(float value)<br>    &#123;<br>        Debug.Log(&quot;滑动条值变化：&quot; + value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将该脚本添加到Slider上，然后将层级视图中的Slider（也就是脚本挂载的对象）拖到On Value Changed事件中，然后选择对应的SliderOnValueChanged函数，即可完成事件绑定。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114212008422.png" alt="image-20221114212008422"></p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114212110752.png" alt="image-20221114212110752"></p><p>绑定成功后运行Unity，可以看到随着滑动条的拖动，控制台输出对应的值。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114212325727.png" alt="image-20221114212325727"></p></li><li><p>直接通过脚本监听事件。</p><p>新建脚本TestSlider.cs，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c#">using UnityEngine;<br>using UnityEngine.UI;<br><br>public class TestSlider : MonoBehaviour<br>&#123;<br>    public Slider m_Slider;<br>    private void Start()<br>    &#123;<br>        //监听滑动条变化事件<br>        m_Slider.onValueChanged.AddListener(SliderOnValueChanged);<br>    &#125;<br>    void SliderOnValueChanged(float value)<br>    &#123;<br>        Debug.Log(&quot;滑动条值变化：&quot; + value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将该脚本添加到Slider对象上，并将其面板中的Slider变量设置为Slider对象。完成事件绑定。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114213137816.png" alt="image-20221114213137816"></p><p>运行效果和上一种方法相同。</p></li></ul></li></ul><h2 id="总结示例"><a href="#总结示例" class="headerlink" title="总结示例"></a>总结示例</h2><p>通过滑动条实现对bunny兔子网格渲染颜色的改变，简称“变色兔”。</p><p>首先，把bunny.obj文件拖到Assets文件夹，并进行一些调整配置。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114220943401.png" alt="image-20221114220943401"></p><p>新建ColorChange.cs脚本，其代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#">using System.Collections;<br>using System.Collections.Generic;<br>using UnityEngine;<br>using UnityEngine.UI;<br><br>public class ColorChange : MonoBehaviour<br>&#123;<br>    public Slider m_Slider;<br>    public GameObject bunny;<br><br>    public void bunny_color_change(float value)<br>    &#123;<br>        bunny.GetComponent&lt;Renderer&gt;().material.color = new Vector4(value, value, value, 1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>绑定事件，运行。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114225136096.png" alt="image-20221114225136096"></p><p>效果如下：</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/GIF%202022-11-14%2023-04-35.gif" alt="GIF 2022-11-14 23-04-35"></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Everything分析和清理C盘</title>
    <link href="/2022/11/14/%E4%BD%BF%E7%94%A8Everything%E5%88%86%E6%9E%90%E5%92%8C%E6%B8%85%E7%90%86C%E7%9B%98/"/>
    <url>/2022/11/14/%E4%BD%BF%E7%94%A8Everything%E5%88%86%E6%9E%90%E5%92%8C%E6%B8%85%E7%90%86C%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<p><strong>Everything是一款基于名称快速定位文件和文件夹的搜索工具</strong></p><p>下载地址：<a href="https://www.voidtools.com/zh-cn/">https://www.voidtools.com/zh-cn/</a></p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><ul><li><p>路径下文件夹大小排序。</p><ul><li><p>搜索栏输入：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">size:&gt;100<span class="hljs-title">mb</span> <span class="hljs-title">c</span>:\</span><br></code></pre></td></tr></table></figure><blockquote><p>寻找C盘下所有大于100MB的目标。</p></blockquote></li><li><p>工具–&gt;选项，勾选上<code>索引文件夹大小</code>。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114170445944.png" alt="image-20221114170445944"></p></li><li><p>搜索菜单，勾选<code>文件夹</code>。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114170634007.png" alt="image-20221114170634007"></p></li><li><p>接下来便可以根据大小进行排序，找到路径下比较大的文件夹了。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114170755311.png" alt="image-20221114170755311"></p><blockquote><p>因为everything中的目标大小是动态更新的，所以可以边运行一些<code>潜在</code>的占用内存的程序或应用，通过修改时间进行排序，便可以实时知道哪些文件夹大小在变化。</p></blockquote></li></ul></li><li><p>路径下文件大小排序。方法和文件夹大小排序一样，只不过取消勾选工具–&gt;选项–&gt;<code>索引文件夹大小</code>。</p></li><li><p>搜索文件夹或文件。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过使用上述操作，就能找的很多你不容易发现的大文件，并将其清理或者迁移。</p><ul><li><p>PPT缓存文件，总共2.1G。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114173806836.png" alt="image-20221114173806836"></p><p>通过打开PPT选项，可将自动恢复文件位置进行修改，如果觉得没有恢复的必要也可以将之前的缓存文件删除。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114173945073.png" alt="image-20221114173945073"></p></li><li><p>Edge浏览历史，共1.2G</p><p>位置：C:\Users\xxx\AppData\Local\Microsoft\Edge\User Data\Default\</p><p>直接去Edge浏览历史界面清空就行了。</p></li><li><p>Unity缓存，目前大约1G左右。</p><p>解决方法链接：<a href="https://blog.csdn.net/baidu_39447417/article/details/117829765">修改Unity的Cache缓存位置</a></p></li><li><p>pip缓存，目前大小300M。</p><p>位置：C:\Users\xxx\AppData\Local\pip\</p><p>问题不大，删除就好。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity脚本在VS中显示杂项且无代码提示的问题</title>
    <link href="/2022/11/14/Unity%E8%84%9A%E6%9C%AC%E5%9C%A8VS%E4%B8%AD%E6%98%BE%E7%A4%BA%E6%9D%82%E9%A1%B9%E4%B8%94%E6%97%A0%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2022/11/14/Unity%E8%84%9A%E6%9C%AC%E5%9C%A8VS%E4%B8%AD%E6%98%BE%E7%A4%BA%E6%9D%82%E9%A1%B9%E4%B8%94%E6%97%A0%E4%BB%A3%E7%A0%81%E6%8F%90%E7%A4%BA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>环境：VS2022+Unity2021+C#脚本</p></blockquote><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li><p>在Unity中已配置对应的VS。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114112738855.png" alt="image-20221114112738855"></p></li><li><p>VS相关组件已安装。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114112947425.png" alt="image-20221114112947425"></p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114112956253.png" alt="image-20221114112956253"></p></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在Unity中新建C#脚本后，双击通过VS打开。如下图所示，未能正确显示“Assembly-CSharp”，而是显示“杂项”。并且，脚本编写时无代码提示和自动补全。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114113254239.png" alt="image-20221114113254239"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>VS界面，在Assets文件夹下随便新建一个C#脚本。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221114113641832.png" alt="image-20221114113641832"></p><p>新建成功后，同目录下的其他C#脚本均从“杂项”变为“Assembly-CSharp”，且能够访问定义和具备正常的代码提示。</p><blockquote><p>该方法仅供个人参考。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity2021+VS2022调试</title>
    <link href="/2022/11/13/Unity2021+VS2022%E8%B0%83%E8%AF%95/"/>
    <url>/2022/11/13/Unity2021+VS2022%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="VS2022配置"><a href="#VS2022配置" class="headerlink" title="VS2022配置"></a>VS2022配置</h2><p>打开电脑上的VS安装程序。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221113183948148.png" alt="image-20221113183948148"></p><p>点击<code>修改</code>VS2022，勾选其中的Unity支持组件。如果Unity Hub已经安装好了，可以将其取消勾选。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221113184455671.png" alt="image-20221113184455671"></p><p>选完后，点击右下角<code>修改</code>。等待安装程序进行下载安装完成即可。</p><blockquote><p>如果在第一次安装VS2022时就已经勾选安装Unity相关组件，这部分可以略过。</p></blockquote><h2 id="Unity2021配置"><a href="#Unity2021配置" class="headerlink" title="Unity2021配置"></a>Unity2021配置</h2><p>打开项目后，配置外部脚本编辑器。从菜单栏Edit–&gt;Preferences–&gt;External Tools。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221113185312367.png" alt="image-20221113185312367"></p><p>下拉选择VS2022。如果Unity未能识别到电脑上的VS，需要点击浏览，进行手动选择。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221113185512008.png" alt="image-20221113185512008"></p><h2 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h2><p>上述配置完成后。在Unity中，双击要调试的C#脚本，会自动通过VS2022打开。</p><p>设置调试断点。然后，点击附加到Unity调试程序。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221113190448734.png" alt="image-20221113190448734"></p><p>选择对应的Unity实例（有时会有多个）。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221113190556995.png" alt="image-20221113190556995"></p><p>选完确定后，VS进入到调试状态。此时，切换到Unity，第一次可能会弹出一个是否允许外部调试的窗口，点击是。（可能第一次我点击了默认所有项目执行外部调试的缘故，后面就没有弹窗了。）</p><p>然后，点击Unity的播放按钮，程序便开始运行了。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221113191046273.png" alt="image-20221113191046273"></p><p>一旦运行到VS中设置的断点，Unity中会弹出下面的窗口。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221113191337532.png" alt="image-20221113191337532"></p><p>这是正常的，因为程序运行到断点处停止了。</p><p>此时返回到VS2022中，发现正常命中断点，变量信息可以正常查看，接下来便可以愉快的进行调试了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity安装笔记</title>
    <link href="/2022/11/13/Unity%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/13/Unity%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="下载Unity-Hub"><a href="#下载Unity-Hub" class="headerlink" title="下载Unity Hub"></a>下载Unity Hub</h2><p>Hub的作用是方便管理不同版本的Unity和项目。</p><p>Unity中国官网地址：<a href="https://unity.cn/">Unity实时内容开发平台 - 3D、2D、VR &amp; AR可视化 | Unity中国官网</a>。进入官网，注册用户并登录。</p><p>点击右上角<code>下载Unity</code>。下滑页面，找到<code>下载Unity Hub</code>，下载对应平台的安装包。Hub的安装比较简单，无脑点几下就行了。</p><p>下载的Unity Hub可能是英文，有需要可以更改语言。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221112225111863.png" alt="image-20221112225111863"></p><h2 id="下载Unity"><a href="#下载Unity" class="headerlink" title="下载Unity"></a>下载Unity</h2><p>运行Unity Hub，点击<code>Sign in</code>登录账户。</p><blockquote><p>因为我在网页上账户已登录，直接跳转到了网页上，并完成登录。</p></blockquote><p>此时，Hub界面上弹出如下安装提示。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221112223703219.png" alt="image-20221112223703219"></p><p>这里应该是默认推荐最新的长期支持版本（LTS）的Unity Editor，点击安装即可。然后便是漫长的等待。。。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221112231059912.png" alt="image-20221112231059912"></p><p>等了好久好久。才发现在Hub中<code>安装</code>界面的右上角中有个<code>安装编辑器</code>。在里面选择版本点击安装后，可以进行安装组件选择。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221112232225193.png" alt="image-20221112232225193"></p><p>当然，在安装完成后也能添加模块。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221112232350119.png" alt="image-20221112232350119"></p><p>Unity除了在Hub里面下载以外，也可以通过官网下载安装到本地，然后通过选择<code>Unity.exe</code>文件的位置，将不同版本的Unity导入到Hub中进行统一管理。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221112232607945.png" alt="image-20221112232607945"></p><h2 id="获取许可证"><a href="#获取许可证" class="headerlink" title="获取许可证"></a>获取许可证</h2><p>Unity的许可证分好几种，一般我们选择个人版即可免费使用。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221112232833653.png" alt="image-20221112232833653"></p><p>一般个人免费版许可证有时限，但是可以重复添加，一旦过期，再添加就可。</p><h2 id="运行Unity项目"><a href="#运行Unity项目" class="headerlink" title="运行Unity项目"></a>运行Unity项目</h2><p>Unity安装成功后会在桌面生成快捷方式。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221112233409995.png" alt="image-20221112233409995"></p><p>双击运行。然后，然后，你会发现什么也没发生。。。是的，必须先要在Hub中新建项目后才能打开Unity。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221112234100823.png" alt="image-20221112234100823"></p><p>简单配置一下，点击<code>创建项目</code>。然后弹出下面窗口（<strong>PlasticSCM</strong>是Unity项目的版本控制系统，作用有点类似与Git），直接确认安装即可。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221112234135543.png" alt="image-20221112234135543"></p><p>然后开始下载PlasticSCM，下载完成后再点击安装（默认是安装在C盘，建议手动安装更改安装路径）。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221112235857783.png" alt="image-20221112235857783"></p><p>好吧，是我自作聪明了，不过这是什么见鬼的绑定操作？还不能点<code>取消</code>。</p><p>搞了半天，原来在创建项目的时候，不选择下面这一项就不会出现上述问题了，<code>同意政策条款</code>这句话太有迷惑性了，hhh。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221113003228267.png" alt="image-20221113003228267"></p><p>正常打开Unity如下图所示。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221113002600575.png" alt="image-20221113002600575"></p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul><li>记得把Unity Hub下载的安装包删除，还是很占空间的。默认下载位置在<code>C:\Users\用户名\AppData\Local\Temp</code>下，直接把Temp目录下所有文件删除即可。</li><li>第一次创建并打开新项目的时候，提示是否进入安全模式，如果忽略的话，进去Unity后，控制台输出一个报错信息。但是重启电脑后，就再也不报这个错误了。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>减法聚类</title>
    <link href="/2022/11/10/%E5%87%8F%E6%B3%95%E8%81%9A%E7%B1%BB/"/>
    <url>/2022/11/10/%E5%87%8F%E6%B3%95%E8%81%9A%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><p>减法聚类算法（Subtractive Clustering Method)是一种不需要提前规定聚类数、只需根据样本数据即可快速决定聚类中心的一种密度聚类算法。该算法把所有样本数据点作为聚类中心的候选点，利用密度函数计算每个候选点的密度指标，选取其中密度指标最大的点作为聚类中心，再去掉已知选择的聚类中心，计算剩余点的密度指标，选取其中密度指标最大的点作为下一个聚类中心。不断重复上述过程，直到满足收敛条件$^{[1]}$。最终即可得到的已知数目的聚类中心。</p><h3 id="具体实现流程"><a href="#具体实现流程" class="headerlink" title="具体实现流程"></a>具体实现流程</h3><ul><li><p>Step1：已知n个处于m维空间的数据样本点 $(x_1,x_2,…,x_n)$，每个数据点都是候选聚类中心，定义数据点 $x_i$ 处的密度指标为：<br>$$<br>D_i=\sum_{j=1}^n\exp(-\frac{|x_i-x_j|^2}{(r_a/2)^2})<br>$$<br>其中 $r_a$ 是一个常数，一个数据点的邻近数据点越多，该数据点的密度指标越大。$r_a$ 也可以理解为以 $x_i$ 数据点为中心，以 $r_a$ 为半径的圆形区域，区域以外的数据点对该点的密度指标影响较小。</p></li><li><p>Step2：按照上式计算得到各个样本点的密度指标，密度指标最大的点定义为聚类中心 $c_k$ ，其密度指标为 $D_{c_k}$ 。此时 $k=1$ ，那么每一个数据点 $x_i$ 的密度指标可用以下公式进行更新：<br>$$<br>D_i = D_i - D_{c_k}\exp{(-\frac{|x_i-x_{c_k}|^2}{(r_b/2)^2})}<br>$$<br>其中 $r_b$ 是一个常数。可以看出，经过更新公式重新计算密度指标后，靠近聚类中心 $c_k$ 的数据点密度指标明显减小了，这样做的好处是可以避免其成为下一个聚类中心。$r_b$ 定义了一个密度指标显著减小的影响范围$^{[2]}$。</p></li><li><p>Step3：根据更新修正后的样本数据点密度指标，找出最大值$D_{max}=\max(D_i)$，选出下一个聚类中心$c_{k+1}$，重复Step2进行更新修正。</p></li><li><p>Step4：不断迭代计算修正后的密度指标最大值 $D_{max}$ ，直到满足下式：<br>$$<br>\frac{D_{max}}{D_{c_1}}&lt;\delta<br>$$<br>则迭代结束，最终聚类个数为 $K=k$ 。一般取$\delta\ge0.5$ 效果较好。  </p></li></ul><p>关于Step1和Step2中的$r_a, r_b$ 可通过如下方法进行确定：<br>$$<br>r_a=r_b=\frac{1}{2}\min_j{\max_i(|x_i-x_j|)}<br>$$<br>其中 $r_a、r_b$ 取样本集合最中间的样本到距离它最远的样本之间距离的一半$^{[3]}$。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>为了避免太多循环操作，代码中尽量使用矩阵计算。</p><p>首先，创建CSM减法聚类方法类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> pairwise_distances_argmin<br><span class="hljs-keyword">from</span> sklearn.datasets._samples_generator <span class="hljs-keyword">import</span> make_blobs<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SCM</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, r_a = <span class="hljs-literal">None</span>, r_b = <span class="hljs-literal">None</span>, delta = <span class="hljs-number">0.5</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Subtractive Clustering Method</span><br><span class="hljs-string"></span><br><span class="hljs-string">        :param r_a: float,初始化密度指标邻域大小</span><br><span class="hljs-string">        :param r_b: float,迭代修正密度指标邻域大小</span><br><span class="hljs-string">        :param delta: float,迭代停止阈值</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.r_a = r_a<br>        self.r_b = r_b<br>        self.delta = delta<br>        self.cluster_centers = np.array([])<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span>(<span class="hljs-params">self, X</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;聚类主函数</span><br><span class="hljs-string"></span><br><span class="hljs-string">        :param X: NxM array,输入样本数据点,N为样本点数量,M为样本数据维数</span><br><span class="hljs-string">        :return: KxM array,聚类中心点集合,K为中心点数量,M为中心点维数</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 计算欧式距离矩阵EDM（NxN）</span><br>        EDM = self.compute_squared_EDM(X)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.r_a <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> self.r_b:<br>            <span class="hljs-comment"># 计算r_a和r_b</span><br>            self.r_a = self.r_b = <span class="hljs-number">0.5</span> * np.<span class="hljs-built_in">min</span>(np.<span class="hljs-built_in">max</span>(EDM, axis = <span class="hljs-number">1</span>))<br>        <span class="hljs-comment"># 计算每个样本点的密度指标</span><br>        D = np.<span class="hljs-built_in">sum</span>(np.exp(-<span class="hljs-number">1</span> * EDM / (<span class="hljs-number">0.25</span> * self.r_a ** <span class="hljs-number">2</span>)), axis = <span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 选取最大密度指标点作为聚类中心</span><br>        self.cluster_centers = np.append(self.cluster_centers, X[np.argmax(D)]).reshape(-<span class="hljs-number">1</span>, X.shape[<span class="hljs-number">1</span>])<br>        Dc1, Dmax = np.<span class="hljs-built_in">max</span>(D), np.<span class="hljs-built_in">max</span>(D)<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 更新修正各点密度指标</span><br>            D -= Dmax * np.exp(-<span class="hljs-number">1</span> * EDM[:, np.argmax(D)] / (<span class="hljs-number">0.25</span> * self.r_b ** <span class="hljs-number">2</span>))<br>            Dmax = np.<span class="hljs-built_in">max</span>(D)<br>            <span class="hljs-comment"># 判断是否满足迭代结束条件</span><br>            <span class="hljs-keyword">if</span> Dmax / Dc1 &lt; self.delta:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-comment"># 选取最大密度指标点作为下一个聚类中心</span><br>            self.cluster_centers = np.vstack((self.cluster_centers, X[np.argmax(D)]))<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_squared_EDM</span>(<span class="hljs-params">X</span>):</span><br>        <span class="hljs-comment"># 获得矩阵都行和列，因为是行向量，因此一共有n个向量</span><br>        n, m = X.shape<br>        <span class="hljs-comment"># 计算Gram 矩阵</span><br>        G = np.dot(X, X.T)<br>        <span class="hljs-comment"># 因为是行向量，n是向量个数，沿y轴复制n倍，x轴复制一倍</span><br>        H = np.tile(np.diag(G), (n, <span class="hljs-number">1</span>))<br>        <span class="hljs-keyword">return</span> np.sqrt(H + H.T - <span class="hljs-number">2</span> * G)<br></code></pre></td></tr></table></figure><p>ok，直接开始测试。测试部分代码参考了这篇文章$^{[5]}$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Generate sample data</span><br>np.random.seed(<span class="hljs-number">0</span>)<br>centers = [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], [-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>]]<br>X, labels_true = make_blobs(n_samples = <span class="hljs-number">3000</span>, n_features = <span class="hljs-number">2</span>, centers = centers, cluster_std = <span class="hljs-number">0.5</span>)<br><span class="hljs-comment"># plot result</span><br>fig = plt.figure(figsize = (<span class="hljs-number">8</span>, <span class="hljs-number">3</span>))<br>fig.subplots_adjust(left = <span class="hljs-number">0.02</span>, right = <span class="hljs-number">0.98</span>, bottom = <span class="hljs-number">0.05</span>, top = <span class="hljs-number">0.9</span>)<br><span class="hljs-comment"># original data</span><br>ax = fig.add_subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>row, _ = np.shape(X)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(row):<br>    ax.plot(X[i, <span class="hljs-number">0</span>], X[i, <span class="hljs-number">1</span>], <span class="hljs-string">&#x27;#4EACC5&#x27;</span>, marker = <span class="hljs-string">&#x27;.&#x27;</span>)<br>ax.set_title(<span class="hljs-string">&#x27;Original Data&#x27;</span>)<br>ax.set_xticks(())<br>ax.set_yticks(())<br><span class="hljs-comment"># compute clustering with SCM</span><br>scm = SCM()<br>t0 = time.time()<br>scm.fit(X)<br>t = time.time() - t0<br>csm_cluster_centers = np.sort(scm.cluster_centers, axis = <span class="hljs-number">0</span>)<br>csm_labels = pairwise_distances_argmin(X, csm_cluster_centers)<br><span class="hljs-comment"># SCM</span><br>ax = fig.add_subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">import</span> matplotlib.colors <span class="hljs-keyword">as</span> mcolors<br><br>colors = <span class="hljs-built_in">list</span>(mcolors.TABLEAU_COLORS.keys())  <span class="hljs-comment"># 颜色变化</span><br><span class="hljs-keyword">for</span> k, col <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(csm_cluster_centers)), colors):<br>    my_members = csm_labels == k  <span class="hljs-comment"># my_members是布尔型的数组（用于筛选同类的点，用不同颜色表示）</span><br>    cluster_center = csm_cluster_centers[k]<br>    ax.plot(X[my_members, <span class="hljs-number">0</span>], X[my_members, <span class="hljs-number">1</span>], <span class="hljs-string">&#x27;w&#x27;</span>,<br>            markerfacecolor = col, marker = <span class="hljs-string">&#x27;.&#x27;</span>)  <span class="hljs-comment"># 将同一类的点表示出来</span><br>    ax.plot(cluster_center[<span class="hljs-number">0</span>], cluster_center[<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;o&#x27;</span>, markerfacecolor = col,<br>            markeredgecolor = <span class="hljs-string">&#x27;k&#x27;</span>, marker = <span class="hljs-string">&#x27;o&#x27;</span>)  <span class="hljs-comment"># 将聚类中心单独表示出来</span><br>ax.set_title(<span class="hljs-string">&#x27;Subtractive Clustering&#x27;</span>)<br>ax.set_xticks(())<br>ax.set_yticks(())<br>plt.text(-<span class="hljs-number">3.5</span>, <span class="hljs-number">1.8</span>,<br>             <span class="hljs-string">&#x27;train time: %.2fs\ndelta: %.2f\nnumber of centers: %d&#x27;</span> % (t, scm.delta, <span class="hljs-built_in">len</span>(scm.cluster_centers)))<br>    plt.show()<br></code></pre></td></tr></table></figure><p>测试结果如下图所示。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/csm_0.5.png" alt="csm_0.5"></p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/csm_0.4.png" alt="csm_0.4"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><strong>欧式距离矩阵求解</strong></p><p>矩阵运算很好用，能避免for循环，提升运算效率。本代码中距离矩阵构建方法参见文章$^{[4]}$。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 马慧,赵捧未,王婷婷. 语义减法聚类研究[J]. 计算机工程与科学,2016,38(9):1924-1929. DOI:10.3969/j.issn.1007-130X.2016.09.027.</p><p>[2] 袁银莉. 改进的模糊聚类算法[J]. 绍兴文理学院学报,2009,29(10):46-49. DOI:10.3969/j.issn.1008-293X.2009.10.012. </p><p>[3] 邵堃侠,郭卫民,杨宁,等. 基于K-means算法的RBF神经网络预测光伏电站短期出力[J]. 上海电机学院学报,2017,20(1):27-33. DOI:10.3969/j.issn.2095-0020.2017.01.006.</p><p>[4] <a href="https://blog.csdn.net/LoveCarpenter/article/details/85048291">https://blog.csdn.net/LoveCarpenter/article/details/85048291</a></p><p>[5] <a href="https://blog.csdn.net/qq_41938858/article/details/87738035">https://blog.csdn.net/qq_41938858/article/details/87738035</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PSO-RBFN</title>
    <link href="/2022/11/09/PSO-RBFN/"/>
    <url>/2022/11/09/PSO-RBFN/</url>
    
    <content type="html"><![CDATA[<h2 id="算法原理及流程"><a href="#算法原理及流程" class="headerlink" title="算法原理及流程"></a>算法原理及流程</h2><p>关于RBF神经网络的细节详见：<a href="https://blog.csdn.net/qq_39784672/article/details/127699908">RBF神经网络学习及实践</a>。</p><p>关于PSO算法的细节详见：<a href="https://blog.csdn.net/qq_39784672/article/details/127750401">粒子群优化算法（PSO）python实践</a>。</p><p>PSO算法优化RBF神经网络训练流程图如下所示。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/%E7%BB%98%E5%9B%BE1.jpg"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>代码直接使用文章<a href="https://blog.csdn.net/qq_39784672/article/details/127699908">RBF神经网络学习及实践</a>和<a href="https://blog.csdn.net/qq_39784672/article/details/127750401">粒子群优化算法（PSO）python实践</a>中的代码框架。</p><p>为了能在PSO类内部计算fitness，我们给PSO类初始化方法添加rbfn参数，方便调用rbfn进行训练和计算适应度（适应度直接采用均方误差）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.rbfn = rbfN<br></code></pre></td></tr></table></figure><p>修改RBFN类中的训练测试函数，使之返回适应度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self</span>):</span><br>G = self._calcAct(self.X)<br>Y_pre = np.dot(G, self.W)<br><span class="hljs-comment"># 计算整体均方误差</span><br>E = <span class="hljs-number">0.5</span> * (np.linalg.norm(Y_pre - self.Y)) ** <span class="hljs-number">2</span><br><span class="hljs-keyword">return</span> E<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span>(<span class="hljs-params">self, x</span>):</span><br>G = self._calcAct(x)<br>Y_pre = np.dot(G, self.W)<br><span class="hljs-keyword">return</span> Y_pre<br></code></pre></td></tr></table></figure><p>测试主函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">num_sample, num_center, sample_dim = <span class="hljs-number">30</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span><br><span class="hljs-comment"># 数据生成</span><br>x_train = np.linspace(-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, num_sample).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>y_train = np.multiply(<span class="hljs-number">1.1</span> * (<span class="hljs-number">1</span> - x_train + <span class="hljs-number">2</span> * x_train ** <span class="hljs-number">2</span>), np.exp(-<span class="hljs-number">0.5</span> * x_train ** <span class="hljs-number">2</span>))<br>x_test = np.linspace(-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">500</span>).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>y_test = np.multiply(<span class="hljs-number">1.1</span> * (<span class="hljs-number">1</span> - x_test + <span class="hljs-number">2</span> * x_test ** <span class="hljs-number">2</span>), np.exp(-<span class="hljs-number">0.5</span> * x_test ** <span class="hljs-number">2</span>))<br><span class="hljs-comment"># PSO-RBF</span><br>rbfn = RBFN(<span class="hljs-number">1</span>, num_center, <span class="hljs-number">1</span>, x_train, y_train)<br>pso = PSO_RBFN(num_center * sample_dim, <span class="hljs-number">30</span>, <span class="hljs-number">400</span>, rbfN = rbfn)<br>pso.pso()<br><span class="hljs-comment"># print(pso.g_best)</span><br>rbfn.train(pso.g_best)<br>y_pre = rbfn.predict(x_test)<br><span class="hljs-comment"># 绘图</span><br>plt.figure(<span class="hljs-number">1</span>)<br>plt.plot(x_test, y_pre, <span class="hljs-string">&#x27;k&#x27;</span>)<br>plt.plot(x_test, y_test, <span class="hljs-string">&#x27;r:&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x_train)):<br>    plt.plot(x_train[i], y_train[i], <span class="hljs-string">&#x27;go&#x27;</span>, markerfacecolor = <span class="hljs-string">&#x27;none&#x27;</span>)<br>plt.legend(labels = [<span class="hljs-string">&#x27;reconstruction&#x27;</span>, <span class="hljs-string">&#x27;original&#x27;</span>, <span class="hljs-string">&#x27;sample point&#x27;</span>], loc = <span class="hljs-string">&#x27;lower left&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>测试PSO适应度收敛曲线如下图所示。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/11133.png" alt="11133"></p><p>PSO-RBFN毕竟结果如下。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/Figu1.png" alt="Figu1"></p><blockquote><p>其中绿色空心圆点为样本数据，红色虚线为期望数据，黑色实线为预测数据。</p></blockquote><h2 id="结果分析与总结"><a href="#结果分析与总结" class="headerlink" title="结果分析与总结"></a>结果分析与总结</h2><ul><li><p><strong>PSO粒子与RBFN中心点</strong></p><p>这两个概念我曾混淆，认为：PSO优化RBFN时，每个中心点都编码成一个粒子。但是随后又想，既然在PSO中需要频繁计算每个粒子的适应度，而RBFN的预测结果是由所有中心点共同线性加权决定的，所以这个想法不成立。实际上，我们引入PSO算法的目的在于更好地优化RBFN，使其找到最优的网络构建参数：隐层中心点、方差、输出层到结果的权值。只要隐层中心点确定，方差可以由如下公式计算得到：</p><p>$$<br>\sigma=\frac{d_{\max }}{\sqrt{2 n}}<br>$$<br>这里 $\mathrm{d}_{\max }$ 是选取中心的之间的最大距离。权值也可以通过伪逆法求解得到。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221109213729271.png" alt="image-20221109213729271"></p><p>因此，我们只需找到构建RBFN的最优中心点即可，即粒子编码中包括基函数中心值。设有 $m$ 个中心点，每个中心点为 $k$ 维（中心点维度等于输入样本数据维度），那么，每个粒子的位置和速度均为 $m\times{k}$ 维。</p></li><li><p><strong>粒子位置限制和速度限制</strong></p><p>对于粒子的位置限制，取决于输入样本的各个维度的取值域，如果是取值无约束，可注释掉位置限制相关代码。对于速度限制，一般取最大速度取维度位置变化范围的10%~20%，在测试代码中粒子速度范围限制在[-1,1]之间。</p></li><li><p><strong>RBFN中心点个数确定和初始化</strong></p><p>在测试代码中，对于RBFN中心点个数取3，且在 $[X_{min},X_{max}]$ 中均匀随机初始化，这属于比较简单粗暴的了。正常来说，一般是使用聚类进行初始化。如指定中心点个数进行K-Means聚类得到聚类中心初始化中心点位置。但是K-Means算法的缺点是需要指定聚类中心个数，所以可以考虑采用减法聚类<code>Subtrative Clustering</code>迭代得到一定数量的聚类中心点位置。</p></li><li><p><strong>样本数据归一化</strong></p><p>对于样本数据的不同维度，其数据量纲、量纲单位、数量级存在差别，为防止计算饱和，需要对其进行归一化处理，以建立各类数据的可比性。</p><ul><li><p>min-max标准化</p><p>min-max标准化最终将样本数据限定在[0,1]范围内，其转化函数为：<br>$$<br>X=\frac{X-X_{min}}{X_{max}-X_{min}}<br>$$<br>式中 $X$ 为样本数据，$X_{max}$ 为样本数据最大值，$X_{min}$ 为最小值。</p></li><li><p>z-score标准化</p><p>经过 z-score标准化处理的数据符合标准正态分布，即均值为0，标准差为1，其转化函数为：<br>$$<br>z=\frac{x-\mu}{\sigma}<br>$$<br>其中 $\mu$ 为样本数据的均值，$\sigma$ 为样本数据的标准差，$x$ 为样本数据。</p></li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 庹婧艺,徐冰峰,徐悦,等. 基于PSO算法优化的RBF神经网络水厂混凝投药控制[J]. 工业安全与环保,2022,48(9):83-86. DOI:10.3969/j.issn.1001-425X.2022.09.020.</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>粒子群优化算法（PSO）</title>
    <link href="/2022/11/08/%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%EF%BC%88PSO%EF%BC%89/"/>
    <url>/2022/11/08/%E7%B2%92%E5%AD%90%E7%BE%A4%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%EF%BC%88PSO%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="1-算法介绍和原理"><a href="#1-算法介绍和原理" class="headerlink" title="1 算法介绍和原理"></a>1 算法介绍和原理</h2><h3 id="1-1-算法原理"><a href="#1-1-算法原理" class="headerlink" title="1.1 算法原理"></a>1.1 算法原理</h3><p>强烈推荐知乎大佬的这篇文章：<a href="https://zhuanlan.zhihu.com/p/346355572">粒子群优化算法(Particle Swarm Optimization, PSO)的详细解读 - 知乎 (zhihu.com)</a>。该文章详细介绍了算法的原理、算法流程、参数解释和一些Tips，这里就不过多赘述了。</p><p>粒子群优化算法（PSO, Particle Swarm Optimization），属于启发式算法中的一种，常用于多目标优化，寻找全局最优解，具有收敛速度快、参数少、算法简单的优点。</p><p>算法流程图如下（图片来自<a href="https://zhuanlan.zhihu.com/p/346355572">这篇</a>文章）：</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/v2-1542915a08c301af314c13eddc9cbb88_r.jpg" alt="img"></p><h3 id="1-2-更新公式"><a href="#1-2-更新公式" class="headerlink" title="1.2 更新公式"></a>1.2 更新公式</h3><h4 id="1-2-1-速度更新公式"><a href="#1-2-1-速度更新公式" class="headerlink" title="1.2.1 速度更新公式"></a>1.2.1 速度更新公式</h4><p>$$<br>v_{i d}^{k+1}=\omega v_{i d}^k+c_1 r_1\left(p_{i d, \text { pbest }}^k-x_{i d}^k\right)+c_2 r_2\left(p_{d, \text { gbest }}^k-x_{i d}^k\right)<br>$$</p><blockquote><p>$v_{i d}^{k+1}$ —— 粒子 $i$ 在第 $k$ 次迭代中第 $d$ 维的速度向量。</p><p> $p_{i d, \text { pbest }}^k$ —— 粒子 $i$ 在第 $k$ 次迭代中第 $d$ 维的历史最优位置。</p></blockquote><p>速度可以看作一个向量，具有大小和方向。即是粒子下一轮迭代移动的距离和方向。公式分为三部分，第一部分为惯性项，由该粒子的当前速度和惯性权重 $\omega$ 组成。第二部分为认知项，即是粒子当前位置和自身历史最优位置间的距离和方向。 第三部分为社会项，即是粒子当前位置和群体历史最优位置间的距离和方向。</p><p>对于更新速度的方向，等于三部分向量和向量的方向。</p><h4 id="1-2-2-位置更新公式"><a href="#1-2-2-位置更新公式" class="headerlink" title="1.2.2 位置更新公式"></a>1.2.2 位置更新公式</h4><p>$$<br>x_{i d}^{k+1}=x_{i d}^{k}+v_{i d}^{k+1}<br>$$</p><blockquote><p>点加向量等于点</p></blockquote><p>大致掌握算法原理后，直接上手代码。</p><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h2><p>示例问题：</p><p>求解如下函数的极小值<br>$$<br>y=x_1e^{x_2}+x_3sinx_2+x_4x_5<br>$$<br>每个变量的取值都在(1,25)。</p><p>首先是定义一个求解类及其初始化方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PSO</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, D, N, M, p_low, p_up, v_low, v_high, w = <span class="hljs-number">1.</span>, c1 = <span class="hljs-number">2.</span>, c2 = <span class="hljs-number">2.</span></span>):</span><br>        self.w = w  <span class="hljs-comment"># 惯性权值</span><br>        self.c1 = c1  <span class="hljs-comment"># 个体学习因子</span><br>        self.c2 = c2  <span class="hljs-comment"># 群体学习因子</span><br>        self.D = D  <span class="hljs-comment"># 粒子维度</span><br>        self.N = N  <span class="hljs-comment"># 粒子群规模，初始化种群个数</span><br>        self.M = M  <span class="hljs-comment"># 最大迭代次数</span><br>        self.p_range = [p_low, p_up]  <span class="hljs-comment"># 粒子位置的约束范围</span><br>        self.v_range = [v_low, v_high]  <span class="hljs-comment"># 粒子速度的约束范围</span><br>        self.x = np.zeros((self.N, self.D))  <span class="hljs-comment"># 所有粒子的位置</span><br>        self.v = np.zeros((self.N, self.D))  <span class="hljs-comment"># 所有粒子的速度</span><br>        self.p_best = np.zeros((self.N, self.D))  <span class="hljs-comment"># 每个粒子的最优位置</span><br>        self.g_best = np.zeros((<span class="hljs-number">1</span>, self.D))[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 种群（全局）的最优位置</span><br>        self.p_bestFit = np.zeros(self.N)  <span class="hljs-comment"># 每个粒子的最优适应值</span><br>        self.g_bestFit = <span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;Inf&#x27;</span>)  <span class="hljs-comment"># float(&#x27;-Inf&#x27;)，始化种群（全局）的最优适应值，由于求极小值，故初始值给大，向下收敛，这里默认优化问题中只有一个全局最优解</span><br><br>        <span class="hljs-comment"># 初始化所有个体和全局信息</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.N):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.D):<br>                self.x[i][j] = random.uniform(self.p_range[<span class="hljs-number">0</span>][j], self.p_range[<span class="hljs-number">1</span>][j])<br>                self.v[i][j] = random.uniform(self.v_range[<span class="hljs-number">0</span>], self.v_range[<span class="hljs-number">1</span>])<br>            self.p_best[i] = self.x[i]  <span class="hljs-comment"># 保存个体历史最优位置，初始默认第0代为最优</span><br>            fit = self.fitness(self.p_best[i])<br>            self.p_bestFit[i] = fit  <span class="hljs-comment"># 保存个体历史最优适应值</span><br>            <span class="hljs-keyword">if</span> fit &lt; self.g_bestFit:  <span class="hljs-comment"># 寻找并保存全局最优位置和适应值</span><br>                self.g_best = self.p_best[i]<br>                self.g_bestFit = fit<br></code></pre></td></tr></table></figure><p>然后定义适应度计算函数，也就是我们要寻优的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fitness</span>(<span class="hljs-params">x</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    根据粒子位置计算适应值，可根据问题情况自定义</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>] * np.exp(x[<span class="hljs-number">1</span>]) + x[<span class="hljs-number">2</span>] * np.sin(x[<span class="hljs-number">1</span>]) + x[<span class="hljs-number">3</span>] * x[<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p>定义每次迭代的更新函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.N):<br>        <span class="hljs-comment"># 更新速度(核心公式)</span><br>        self.v[i] = self.w * self.v[i] + self.c1 * random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) * (<br>                self.p_best[i] - self.x[i]) + self.c2 * random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) * (self.g_best - self.x[i])<br>        <span class="hljs-comment"># 速度限制</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.D):<br>            <span class="hljs-keyword">if</span> self.v[i][j] &lt; self.v_range[<span class="hljs-number">0</span>]:<br>                self.v[i][j] = self.v_range[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> self.v[i][j] &gt; self.v_range[<span class="hljs-number">1</span>]:<br>                self.v[i][j] = self.v_range[<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># 更新位置</span><br>        self.x[i] = self.x[i] + self.v[i]<br>        <span class="hljs-comment"># 位置限制</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.D):<br>            <span class="hljs-keyword">if</span> self.x[i][j] &lt; self.p_range[<span class="hljs-number">0</span>][j]:<br>                self.x[i][j] = self.p_range[<span class="hljs-number">0</span>][j]<br>            <span class="hljs-keyword">if</span> self.x[i][j] &gt; self.p_range[<span class="hljs-number">1</span>][j]:<br>                self.x[i][j] = self.p_range[<span class="hljs-number">1</span>][j]<br>        <span class="hljs-comment"># 更新个体和全局历史最优位置及适应值</span><br>        _fit = self.fitness(self.x[i])<br>        <span class="hljs-keyword">if</span> _fit &lt; self.p_bestFit[i]:<br>            self.p_best[i] = self.x[i]<br>            self.p_bestFit[i] = _fit<br>        <span class="hljs-keyword">if</span> _fit &lt; self.g_bestFit:<br>            self.g_best = self.x[i]<br>            self.g_bestFit = _fit<br></code></pre></td></tr></table></figure><p>其中主要完成每轮迭代中单个粒子位置和速度，历史最优位置和最优适应度的更新，以及群体（全局）的最优位置和最优适应度的更新。</p><p>最后，便是主要函数的实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pso</span>(<span class="hljs-params">self, draw = <span class="hljs-number">1</span></span>):</span><br>    best_fit = []  <span class="hljs-comment"># 记录每轮迭代的最佳适应度，用于绘图</span><br>    w_range = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(self.w, <span class="hljs-built_in">tuple</span>):<br>        w_range = self.w[<span class="hljs-number">1</span>] - self.w[<span class="hljs-number">0</span>]<br>        self.w = self.w[<span class="hljs-number">1</span>]<br>    time_start = time.time()  <span class="hljs-comment"># 记录迭代寻优开始时间</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.M):<br>        self.update()  <span class="hljs-comment"># 更新主要参数和信息</span><br>        <span class="hljs-keyword">if</span> w_range:<br>            self.w -= w_range / self.M  <span class="hljs-comment"># 惯性权重线性递减</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\rIter: &#123;:d&#125;/&#123;:d&#125; fitness: &#123;:.4f&#125; &quot;</span>.<span class="hljs-built_in">format</span>(i, self.M, self.g_bestFit, end = <span class="hljs-string">&#x27;\n&#x27;</span>))<br>        best_fit.append(self.g_bestFit.copy())<br>    time_end = time.time()  <span class="hljs-comment"># 记录迭代寻优结束时间</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Algorithm takes <span class="hljs-subst">&#123;time_end - time_start&#125;</span> seconds&#x27;</span>)  <span class="hljs-comment"># 打印算法总运行时间，单位为秒/s</span><br>    <span class="hljs-keyword">if</span> draw:<br>        plt.figure()<br>        plt.plot([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.M)], best_fit)<br>        plt.xlabel(<span class="hljs-string">&quot;iter&quot;</span>)<br>        plt.ylabel(<span class="hljs-string">&quot;fitness&quot;</span>)<br>        plt.title(<span class="hljs-string">&quot;Iter process&quot;</span>)<br>        plt.show()<br></code></pre></td></tr></table></figure><p>测试代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    low = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br>    up = [<span class="hljs-number">25</span>, <span class="hljs-number">25</span>, <span class="hljs-number">25</span>, <span class="hljs-number">25</span>, <span class="hljs-number">25</span>]<br>    pso = PSO(<span class="hljs-number">5</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, low, up, -<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, w = <span class="hljs-number">0.9</span>)<br>    pso.pso()<br></code></pre></td></tr></table></figure><p>测试结果如下图所示。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/Figure_21.png" alt="Figure_21"></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">...<br><span class="hljs-symbol">Iter:</span> <span class="hljs-number">47</span>/<span class="hljs-number">50</span> fitness: <span class="hljs-number">4.5598</span> <br><span class="hljs-symbol">Iter:</span> <span class="hljs-number">48</span>/<span class="hljs-number">50</span> fitness: <span class="hljs-number">4.5598</span> <br><span class="hljs-symbol">Iter:</span> <span class="hljs-number">49</span>/<span class="hljs-number">50</span> fitness: <span class="hljs-number">4.5598</span> <br>Algorithm takes <span class="hljs-number">0.1444549560546875</span> seconds<br></code></pre></td></tr></table></figure><p>可以看到在第30轮就已经完全收敛了，且函数在求解空间中的极小值为4.5598。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><ul><li><p><strong>动态的惯性权重</strong>$^{[1]}$</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221108142132141.png" alt="image-20221108142132141"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">w_range = self.w[<span class="hljs-number">1</span>] - self.w[<span class="hljs-number">0</span>]<br>self.w = self.w[<span class="hljs-number">1</span>]<br>self.w -= w_range / self.M  <span class="hljs-comment"># 惯性权重线性递减</span><br></code></pre></td></tr></table></figure></li><li><p><strong>fitness变化逻辑</strong></p><p>fitness是适应度函数值，通常问题是寻找解空间内的粒子，使得该粒子所代表的解的fitness向下或向上收敛于某一定值。对于不同收敛方向，个体和全局最优fitness一般初始化赋值无穷大或者无穷小<code>float(&#39;Inf&#39;)/float(&#39;Inf&#39;)</code>。并且在判断更新最优适应值时也应当注意大小于符号。</p></li><li><p><strong>程序复用</strong></p><p>对于上面的PSO类代码，不同多元寻优问题均可通过重写类中的<code>fitness</code>函数实现。或者定义<code>self.fitness_function</code>属性进行外部函数名传参赋值。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/346355572">粒子群优化算法(Particle Swarm Optimization, PSO)的详细解读 - 知乎 (zhihu.com)</a></p><p>[2] <a href="https://blog.csdn.net/Cyril_KI/article/details/108589078">粒子群算法(PSO)的Python实现（求解多元函数的极值）_Cyril_KI的博客-CSDN博客_pso算法python</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模型学习记录</title>
    <link href="/2022/11/07/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/11/07/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>代理模型</strong>是工程问题中常用的一个优化方法。当实际问题（高精度模型）计算量很大、不容易求解时，可以使用计算量较小、求解迅速的简化模型来替代原模型，加速优化过程。代理模型的计算结果与原模型非常接近，但是求解计算量较小。通过在仔细选择的有限个点（输入）计算原模型的响应（输出），从而建立代理模型$^{[1]}$。建立得到的代理模型在优化设计中可近似替代比较复杂和费时的数值分析，也可称为响应面模型或者是近似模型。对于优化过程中的一些难以用直观的函数表达式去表达目标函数，这时也可用代理模型来替代目标函数。使用代理模型可以极大的提高优化设计效率以及降低优化的难度。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>从算法层面来分，代理模型通常有径向基模型，神经网络，多项式响应面模型，克里金模型，支持向量机模型等等。</p><p>从解决工程问题的差异性来分，代理模型可分为两类：一种是直接基于实验设计的代理模型优化，一种是带加点准则的代理模型优化。两者区别在于，前者一次性抽取样本点，计算响应值并构建代理模型，在优化过程中代理模型保持不变。而后者是先抽取少量的样本点建立初始代理模型，再不断向总样本中添加新点，不断更新代理模型，直至优化收敛。所以从优化过程中的构造方式来看，前者又被称作”静态代理模型“，后者为”动态代理模型“。</p><h2 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h2><pre><code class=" mermaid">graph TD    样本点获取 --&gt; 对样本点进行数值分析 --&gt; 组成数据集 --&gt; 构建代理模型 </code></pre><ul><li><p>样本点采集通常采用试验设计的方法，通常采用拉丁超立方和均匀设计；</p></li><li><p>样本点数值分析，通常采用线下实验或者线上计算机模拟（有限元分析等等）；</p></li><li><p>将样本点及其对应的数值分析结果组成数据集，用于代理模型构建；</p></li><li><p>建立代理模型时可先对某一模型的参数进行训练，可以极大增强代理模型的精准性，一般采用“最大似然估计”、“交叉验证”等。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><strong>插值、逼近和回归的区别</strong></p><p>从多项式的角度，插值是用一个多项式来近似替代数据列表函数，并要求多项式通过列表函数中给定的数据点。逼近是为复杂函数寻找近似的替代多项式函数，其误差在某种度量意义下最小。</p><blockquote><p>插值和逼近都是通过采样点寻找目标函数的近似替代，区别在于是否经过采样点。插值中替代函数经过样本点，故样本点误差为零；逼近中样本点误差不为零，而是在某种度量意义下最小。</p></blockquote><p>回归反映的是两组数据的关系，假设已知所有样本点同时满足一曲线方程，回归的目的在于求出该方程的系数$^{[3]}$。</p><blockquote><p>对于代理模型中回归模型有多项式响应面模型，插值模型有克里金模型和径向基模型等。</p></blockquote></li><li><p><strong>代理模型的局限性</strong></p><p>随着问题维度的上升，代理模型构建所花费的样本点数和时间会大幅度地增加，而且也会在一定程度上降低代理模型的精度从而影响其提供信息的可信度，从而会导致代理模型的辅助能力下降。因此，可将目前运用较为广泛的降维技术与代理模型所使用的算法相结合进一步提高在求解高维问题时的效果$^{[4]}$。</p></li><li><p><strong>代理模型的发展部分趋势</strong></p><p>相较于静态代理模型，动态代理模型在优化效率和结果精度方面更具有优势。详细实现参见文献<a href="http://d.g.wanfangdata.com.cn/Periodical_jxgcxb201107024.aspx">基于动态径向基函数代理模型的优化策略，DOI:10.3901/JME.2011.07.164</a>。对于多维的样本数据，在构建代理模型前可采用数据降维方法，如POD、PCA等。详情实现参见文献<a href="https://d.wanfangdata.com.cn/periodical/CiFQZXJpb2RpY2FsQ0hJTmV3UzIwMjIxMDI0MjAyMjEwMjQSD2pzbHh4YjIwMjIwNDAxNRoId2puaDFiaDI%3D">基于POD-RBF代理模型的迭代更新反演方法，DOI:10.7511/jslx20201201001</a>。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%9E%8B">维基百科-代理模型</a></p><p>[2] <a href="https://zhuanlan.zhihu.com/p/555814030">代理模型介绍大全 - 知乎 (zhihu.com)</a></p><p>[3] <a href="https://blog.csdn.net/bushixiaofan/article/details/47664567">回归、插值、拟合</a></p><p>[4] <a href="https://blog.csdn.net/weixin_45928096/article/details/123479479">关于代理模型的一些理解</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RBF神经网络python实践学习（BP算法）</title>
    <link href="/2022/11/06/RBF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9Cpython%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%EF%BC%88BP%E7%AE%97%E6%B3%95%EF%BC%89/"/>
    <url>/2022/11/06/RBF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9Cpython%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%EF%BC%88BP%E7%AE%97%E6%B3%95%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>续上一篇：<a href="https://blog.csdn.net/qq_39784672/article/details/127699908">RBF神经网络学习及实践</a></p></blockquote><h2 id="RBF神经网络求解方法"><a href="#RBF神经网络求解方法" class="headerlink" title="RBF神经网络求解方法"></a>RBF神经网络求解方法</h2><p>RBF网络中需要求解的参数为：<strong>径向基函数的中心、方差和隐层到输出层的权值</strong>。</p><p>对于基函数中心的选取方法主要有：<strong>随机选取、聚类选取、有监督学习选取</strong>。对于方差计算方法有：直接公式计算、有监督学习修正计算。权值计算方法有：伪逆法直接求解、最小二乘法直接求解、有监督学习修正求解。</p><p>在上一篇的python代码实现中，我们采用<strong>直接计算法</strong>求解参数。即随机在样本中选取一定数量（即隐层神经元数量）的个体作为径向基函数的中心，且中心自此固定下来，隐层神经元输出便是已知，最终权值直接通过求解线性方程组确定即可。但这种方法的适用前提是样本数据分布具有代表性，否则会导致回归效果不佳。</p><p>其次，对于基函数中心选取也有通过聚类（一般采用K-Means）实现，方程由下面公式计算：<br>$$<br>\sigma=\frac{d_{\max }}{\sqrt{2 n}}<br>$$<br>其中 $d_{max}$ 为聚类得到的中心之间的最大距离，$n$ 为中心数量。</p><p>相较于随机选取，聚类方法更能使中心的选取具有代表性。</p><p>本文将学习如何使用<strong>有监督学习算法</strong>对RBF网络参数进行训练，即对损失函数（一般使用MSE）进行梯度下降，再修正每个参数。</p><p>定义了RBF网络后，定义损失函数（误差函数，这里使用均方误差MSE）如下：<br>$$<br>E=\frac{1}{2 m} \sum_{i=1}^m e_i^2=\frac{1}{2 m} \sum_{i=1}^m(f(x)-y)^2=\frac{1}{2 m} \sum_{i=1}^m\left(\sum_{j=1}^q w_j . \varphi\left(x, c_j\right)-y\right)^2<br>$$<br>我们的目标是最小化损失函数，即使模型预测结果与实际值尽可能逼近。利用BP算法反向传播误差，并利用梯度下降法分别求得RBF网络参数优化的方向。</p><ol><li>隐层到输出层的权值迭代公式<br>$$<br>\Delta w=\frac{\partial E}{\partial w}=\frac{1}{m} \sum_{i=1}^m(f(x)-y) \cdot \varphi(x, c)=\frac{1}{m} \sum_{i=1}^m e_i \cdot \varphi(x, c)<br>$$<br>$$<br>w_{k+1}=w_k-\eta \cdot \Delta w<br>$$</li><li>隐含层的神经元（径向基函数）中心点迭代公式</li></ol><p>$$<br>\begin{aligned}<br>&amp;\Delta c_j=\frac{\partial E}{\partial c_j}=\frac{\partial E}{\partial \varphi\left(x, c_j\right)} \cdot \frac{\partial \varphi\left(x, c_j\right)}{\partial c_j} \<br>&amp;=\frac{1}{m} \sum_{i=1}^m(f(x)-y) w \cdot \frac{\partial \varphi\left(x, c_j\right)}{\partial c_j} \<br>&amp;=\frac{1}{m} \sum_{i=1}^m(f(x)-y) w \cdot \varphi\left(x, c_j\right) \cdot \frac{x-c_j}{\sigma_j^2} \<br>&amp;=\frac{1}{m \cdot \sigma_i^2} \sum_{i=1}^m(f(x)-y) w \cdot \varphi\left(x, c_j\right) \cdot\left(x-c_j\right)<br>\end{aligned}<br>$$</p><p>$$<br>c_{k+1}=c_k-\eta \cdot \Delta c<br>$$<br>3. 方差（高斯核宽度）迭代公式<br>$$<br>\begin{aligned}<br>&amp;\Delta \sigma_j=\frac{\partial E}{\partial \sigma_j}=\frac{\partial E}{\partial \varphi\left(x, c_j\right)} \cdot \frac{\partial \varphi\left(x, c_j\right)}{\partial \sigma_j} \<br>&amp;=\frac{1}{m} \sum_{i=1}^m(f(x)-y) w \cdot \frac{\partial \varphi\left(x, c_j\right)}{\partial \sigma_j} \<br>&amp;=\frac{1}{m \cdot \sigma_j^3} \sum_{i=1}^m(f(x)-y) w \cdot \varphi\left(x, c_j\right) \cdot\left|x_i-c_j\right|^2<br>\end{aligned}<br>$$<br>$$<br>\sigma_{k+1}=\sigma_k-\eta \cdot \Delta \sigma<br>$$</p><p>迭代公式中 $\eta$ 为学习率，对于RBF中不同参数分别设置不同的学习率。经过多轮迭代直至损失函数收敛，训练结束$^{[1]}$。</p><p>对于上述三个参数的迭代，为避免学习率过大过小带来权值振荡或学习速度缓慢，可以在修正公式中增加一个动量项 $\alpha,\alpha \in (0,1)$。 直观上理解就是要是当前梯度方向与前一步的梯度方向一样，那么就增加这一步的权值更新，要是不一样就减少更新。</p><p><img src="https://img-blog.csdnimg.cn/20201209195018438.png"></p><blockquote><p> 动量项参考：<a href="https://blog.csdn.net/bvl10101111/article/details/54973284">神经网络 动量因子</a></p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>python代码来源自参考文章$^{[1]}$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Created on Sun Jul 12 19:15:20 2020</span><br><span class="hljs-string">@author: ecupl</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RBFnetwork</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, hidden_nums, r_w, r_c, r_sigma</span>):</span><br>        self.h = hidden_nums  <span class="hljs-comment"># 隐含层神经元个数</span><br>        self.w = <span class="hljs-number">0</span>  <span class="hljs-comment"># 线性权值</span><br>        self.c = <span class="hljs-number">0</span>  <span class="hljs-comment"># 神经元中心点</span><br>        self.sigma = <span class="hljs-number">0</span>  <span class="hljs-comment"># 高斯核宽度</span><br>        self.r = &#123;<span class="hljs-string">&quot;w&quot;</span>: r_w,<br>                  <span class="hljs-string">&quot;c&quot;</span>: r_c,<br>                  <span class="hljs-string">&quot;sigma&quot;</span>: r_sigma&#125;  <span class="hljs-comment"># 参数迭代的学习率</span><br>        self.errList = []  <span class="hljs-comment"># 误差列表</span><br>        self.n_iters = <span class="hljs-number">0</span>  <span class="hljs-comment"># 实际迭代次数</span><br>        self.tol = <span class="hljs-number">1.0e-5</span>  <span class="hljs-comment"># 最大容忍误差</span><br>        self.X = <span class="hljs-number">0</span>  <span class="hljs-comment"># 训练集特征</span><br>        self.y = <span class="hljs-number">0</span>  <span class="hljs-comment"># 训练集结果</span><br>        self.n_samples = <span class="hljs-number">0</span>  <span class="hljs-comment"># 训练集样本数量</span><br>        self.n_features = <span class="hljs-number">0</span>  <span class="hljs-comment"># 训练集特征数量</span><br><br>    <span class="hljs-comment"># 计算径向基距离函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">guass</span>(<span class="hljs-params">self, sigma, X, ci</span>):</span><br>        <span class="hljs-keyword">return</span> np.exp(-np.linalg.norm((X - ci), axis = <span class="hljs-number">1</span>) ** <span class="hljs-number">2</span> / (<span class="hljs-number">2</span> * sigma ** <span class="hljs-number">2</span>))<br><br>    <span class="hljs-comment"># 将原数据高斯转化成新数据</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">change</span>(<span class="hljs-params">self, sigma, X, c</span>):</span><br>        newX = np.zeros((self.n_samples, <span class="hljs-built_in">len</span>(c)))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(c)):<br>            newX[:, i] = self.guass(sigma[i], X, c[i])<br>        <span class="hljs-keyword">return</span> newX<br><br>    <span class="hljs-comment"># 初始化参数</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init</span>(<span class="hljs-params">self</span>):</span><br>        sigma = np.random.random((self.h, <span class="hljs-number">1</span>))  <span class="hljs-comment"># (h,1)</span><br>        c = np.random.random((self.h, self.n_features))  <span class="hljs-comment"># (h,n)</span><br>        w = np.random.random((self.h + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>))  <span class="hljs-comment"># (h+1,1)</span><br>        <span class="hljs-keyword">return</span> sigma, c, w<br><br>    <span class="hljs-comment"># 给输出层的输入加一列截距项</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addIntercept</span>(<span class="hljs-params">self, X</span>):</span><br>        <span class="hljs-keyword">return</span> np.hstack((X, np.ones((self.n_samples, <span class="hljs-number">1</span>))))<br><br>    <span class="hljs-comment"># 计算整体误差</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calSSE</span>(<span class="hljs-params">self, prey, y</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span> * (np.linalg.norm(prey - y)) ** <span class="hljs-number">2</span><br><br>    <span class="hljs-comment"># 求L2范数的平方</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">l2</span>(<span class="hljs-params">self, X, c</span>):</span><br>        m, n = np.shape(X)<br>        newX = np.zeros((m, <span class="hljs-built_in">len</span>(c)))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(c)):<br>            newX[:, i] = np.linalg.norm((X - c[i]), axis = <span class="hljs-number">1</span>) ** <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> newX<br><br>    <span class="hljs-comment"># 训练</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span>(<span class="hljs-params">self, X, y, iters, draw = <span class="hljs-number">0</span></span>):</span><br>        self.X = X<br>        self.y = y.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        self.n_samples, self.n_features = X.shape<br>        sigma, c, w = self.init()  <span class="hljs-comment"># 初始化参数</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(iters):<br>            <span class="hljs-comment">## 正向计算过程</span><br>            hi_output = self.change(sigma, X, c)  <span class="hljs-comment"># 隐含层输出(m,h)，即通过径向基函数的转换</span><br>            yi_input = self.addIntercept(hi_output)  <span class="hljs-comment"># 输出层输入(m,h+1)，因为是线性加权，故将偏置加入</span><br>            yi_output = np.dot(yi_input, w)  <span class="hljs-comment"># 输出预测值(m,1)</span><br>            error = self.calSSE(yi_output, y)  <span class="hljs-comment"># 计算误差</span><br>            <span class="hljs-keyword">if</span> error &lt; self.tol:<br>                <span class="hljs-keyword">break</span><br>            self.errList.append(error)  <span class="hljs-comment"># 保存误差</span><br>            <span class="hljs-comment">## 误差反向传播过程</span><br>            deltaw = np.dot(yi_input.T, (yi_output - y))  <span class="hljs-comment"># (h+1,m)x(m,1)</span><br>            w -= self.r[<span class="hljs-string">&#x27;w&#x27;</span>] * deltaw / self.n_samples<br>            deltasigma = np.divide(<br>                np.multiply(np.dot(np.multiply(hi_output, self.l2(X, c)).T, (yi_output - y)), w[:-<span class="hljs-number">1</span>]),<br>                sigma ** <span class="hljs-number">3</span>)  <span class="hljs-comment"># (h,m)x(m,1)</span><br>            sigma -= self.r[<span class="hljs-string">&#x27;sigma&#x27;</span>] * deltasigma / self.n_samples<br>            deltac1 = np.divide(w[:-<span class="hljs-number">1</span>], sigma ** <span class="hljs-number">2</span>)  <span class="hljs-comment"># (h,1)</span><br>            deltac2 = np.zeros((<span class="hljs-number">1</span>, self.n_features))  <span class="hljs-comment"># (1,n)</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.n_samples):<br>                deltac2 += (yi_output - y)[j] * np.dot(hi_output[j], X[j] - c)<br>            deltac = np.dot(deltac1, deltac2)  <span class="hljs-comment"># (h,1)x(1,n)</span><br>            c -= self.r[<span class="hljs-string">&#x27;c&#x27;</span>] * deltac / self.n_samples<br>            <span class="hljs-comment"># 拟合过程画图</span><br>            <span class="hljs-keyword">if</span> (draw != <span class="hljs-number">0</span>) <span class="hljs-keyword">and</span> ((i + <span class="hljs-number">1</span>) % draw == <span class="hljs-number">0</span>):<br>                self.draw_process(X, y, yi_output)<br><br>        self.c = c<br>        self.w = w<br>        self.sigma = sigma<br>        self.n_iters = i<br><br>    <span class="hljs-comment"># 画图</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw_process</span>(<span class="hljs-params">self, X, y, y_prediction</span>):</span><br>        plt.scatter(X, y)<br>        plt.plot(X, y_prediction, c = <span class="hljs-string">&#x27;r&#x27;</span>)<br>        plt.show()<br><br>    <span class="hljs-comment"># 预测</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span>(<span class="hljs-params">self, X</span>):</span><br>        hi_output = self.change(self.sigma, X, self.c)  <span class="hljs-comment"># 隐含层输出(m,h)，即通过径向基函数的转换</span><br>        yi_input = self.addIntercept(hi_output)  <span class="hljs-comment"># 输出层输入(m,h+1)，因为是线性加权，故将偏置加入</span><br>        yi_output = np.dot(yi_input, self.w)  <span class="hljs-comment"># 输出预测值(m,1)</span><br>        <span class="hljs-keyword">return</span> yi_output<br></code></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">hidden_nums, iters = <span class="hljs-number">20</span>, <span class="hljs-number">20000</span><br>X = np.linspace(-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">400</span>)[:, np.newaxis]<br>y = np.multiply(<span class="hljs-number">1.1</span> * (<span class="hljs-number">1</span> - X + <span class="hljs-number">2</span> * X ** <span class="hljs-number">2</span>), np.exp(-<span class="hljs-number">0.5</span> * X ** <span class="hljs-number">2</span>))<br><span class="hljs-comment"># y = np.sin(np.pi * X / 2) + np.cos(np.pi * X / 3)</span><br><span class="hljs-comment"># set y and add random noise</span><br><span class="hljs-comment"># y += np.random.normal(0, 0.1, y.shape)</span><br>rbf = RBFnetwork(hidden_nums, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.1</span>)<br>rbf.train(X, y, iters, draw = <span class="hljs-number">50</span>)<br><span class="hljs-comment"># 预测</span><br>plt.plot(X, y, <span class="hljs-string">&#x27;r:&#x27;</span>)<br>plt.plot(X, rbf.predict(X), <span class="hljs-string">&#x27;k&#x27;</span>)<br><span class="hljs-built_in">print</span>(rbf.c)<br><span class="hljs-comment"># plt.scatter(list(rbf.c), [0 for i in range(len(rbf.c))])</span><br><span class="hljs-comment"># plt.plot(rbf.errList)</span><br>plt.show()<br></code></pre></td></tr></table></figure><h2 id="测试结果分析和总结"><a href="#测试结果分析和总结" class="headerlink" title="测试结果分析和总结"></a>测试结果分析和总结</h2><ul><li><p><strong>超参数设置</strong></p><p>在BP（误差反向传播）训练中，学习率和隐层单元数等超参数的设置对训练过程及结果非常重要。较低的学习率会导致loss收敛缓慢，训练时间变长；较高的学习率则会导致loss振荡，甚至梯度爆炸。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/v2-c47ebd3d42b9ef2041d84ed5e075a2f4_b.jpg" alt="查看源图像"></p><p>对于隐层单元数的设置，数量过少会导致无法拟合复杂样本；数量过多会导致隐层输出矩阵尺寸变大，计算量增大。因此，合理的超参数设置很重要。在本测试代码中，可以通过观察误差曲线变化来增减学习率。后面，可以考虑使用粒子群算法等寻优算法对超参数选取进行优化。</p></li><li><p><strong>参数初始化</strong></p><p>对于方差和权值，均采用[0,1)随机值初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sigma = np.random.random((self.h, <span class="hljs-number">1</span>))  <span class="hljs-comment"># (h,1)</span><br>w = np.random.random((self.h + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>))  <span class="hljs-comment"># (h+1,1)</span><br></code></pre></td></tr></table></figure><p>对于隐层中心，参照随机选取和聚类选用的思想，整个样本范围内的点作为中心的概率应当差不多。如果仍然采用[0,1)随机值，那么初始中心呈聚集状，学习率较低的情况下，需要多次迭代才能分散遍布样本空间。可以尝试在 $[x_{min},x_{max}]$ 区间内均匀随机初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">c = np.random.uniform(-<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, (self.h, self.n_features))  <span class="hljs-comment"># (h,n)</span><br></code></pre></td></tr></table></figure><p>当然，也可以尝试k-means聚类初始化中心。</p></li><li><p><strong>bias偏置单元</strong></p><p>在测试代码中，bias体现在给输入层的输入添加了一列截距项（全是1的一列）。与线性方程 $y=wx+b$ 中的 $b$ 的意义是一致的。在 $y=wx+b$ 中，$b$表示函数在y轴上的截距，控制着函数偏离原点的距离，在神经网络中的偏置单元也是类似的作用$^{[2]}$。作用是使函数不过原点，让模型更加灵活。详见<a href="(https://www.cnblogs.com/jiading/p/11620999.html)">参考文章2</a>。</p></li><li><p><strong>输入数据噪声敏感性</strong></p><p>从完全内插法的角度去理解RBF插值，即表面必须通过每一个测得的采样值。存在的问题就是当样本中包含噪声时，神经网络将拟合出一个错误的曲面，从而使泛化能力下降。但对于有监督训练的RBF神经网络，从测试结果可以看出，模型对输入噪声的敏感性不高。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/Figure_1111.png" alt="Figure_1"></p></li><li><p><strong>多元线性回归矩阵求导</strong></p><p>当确定神经网络表达式后，即可确定相应的误差函数。使用梯度下降算法最小化误差函数中，求解参数迭代公式的重点便是矩阵求导。优化的参数不止一个，又是线性回归问题，故属于多元线性回归矩阵求导。相关学习资料详见<a href="https://zhuanlan.zhihu.com/p/24709748">参考3</a>和<a href="https://zhuanlan.zhihu.com/p/24863977">参考4</a>。</p></li><li><p><strong>基函数中心不取自训练样本</strong></p><p>相比于随机和聚类选取后便固定不变的中心，有监督学习的RBF网络中基函数中心是BP修正参数，故在迭代过程中会不断变化，最终得到的中心参数可能不在训练样本范围内。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/159199147">机器学习算法推导&amp;手写实现06——RBF网络 - 知乎 (zhihu.com)</a></p><p>[2] [<a href="https://www.cnblogs.com/jiading/p/11620999.html">转载]神经网络偏置项(bias)的设置及作用 - 别再闹了 - 博客园 (cnblogs.com)</a></p><p>[3] <a href="https://zhuanlan.zhihu.com/p/24709748">矩阵求导术（上） - 知乎 (zhihu.com)</a></p><p>[4] <a href="https://zhuanlan.zhihu.com/p/24863977">矩阵求导术（下） - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RBF神经网络</title>
    <link href="/2022/11/06/RBF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2022/11/06/RBF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="RBF神经网络"><a href="#RBF神经网络" class="headerlink" title="RBF神经网络"></a>RBF神经网络</h2><p>在学习RBF神经网络之前，最好先了解径向基函数的相关知识，参见<a href="https://blog.csdn.net/qq_39784672/article/details/127656592">径向基函数（RBF）插值</a>。</p><p>RBF神经网络模型是1988年由Moody和Darken提出的一种神经网络结构，属于前向神经网络类型，能够以任意精度逼近任意连续函数，特别适合于解决分类问题。RBF网络是一种三层前向网络，第一层为由信号源节点组成的<strong>输入层</strong>，第二层为<strong>隐层</strong>，隐单元数视问题需要而定，隐单元的变换函数为非负<strong>非线性</strong>的函数RBF（径向基函数），第三层为<strong>输出层</strong>，输出层是对隐层神经元输出的<strong>线性</strong>组合$^{[1]}$。网络结构大致如下图所示。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/729758-20180722122344255-429345489.png" alt="img"></p><p>其中，输入向量 $x$ 的维度为 $p$ , 隐层大小为 $h$（神经元/中心点数量），$p&lt;h$ 。<strong>隐含层的作用是把向量从低维度p映射到高维度h，这样低维度线性不可分的情况到高维度就变得线性可分了，实际上是核函数的思想</strong>。这样，网络由输入到输出的映射是非线性的，而网络输出对可调参数而言却又是线性的。网络的权就可由线性方程组直接解出，从而大大加快学习速度并避免局部极小问题。</p><p>径向基神经网络的激活函数可表示为:<br>$$<br>R\left(x_p-c_i\right)=\exp \left(-\frac{1}{2 \sigma^2}\left|x_p-c_i\right|^2\right)<br>$$<br>根据径向基神经网络的结构，可得到网络的输出为:<br>$$<br>y_j=\sum_{i=1}^h w_{i j} \exp \left(-\frac{1}{2 \sigma^2}\left|x_p-c_i\right|^2\right) j=1,2, \cdots, n<br>$$<br>采用最小二乘的损失函数表示$^{[2]}$ :<br>$$<br>\sigma=\frac{1}{P} \sum_j^m\left|d_j-y_j c_i\right|^2<br>$$</p><h2 id="网络学习方法"><a href="#网络学习方法" class="headerlink" title="网络学习方法"></a>网络学习方法</h2><p>RBF神经网络求解的参数有3个：</p><ol><li>基函数的中心；</li><li>方差；</li><li>隐含层到输出层的权值。</li></ol><p>求解上述参数，目前有如下三种学习方法：</p><ol><li><p><strong>自组织选取中心学习法</strong></p><p>第一步：无监督学习过程，求解隐含层基函数的中心与方差</p><p>第二步：有监督学习过程，求解隐含层到输出层之间的权值</p><p>首先，选取h个中心做k-means聚类，对于高斯核函数的径向基，方差由公式求解：</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/729758-20180722115608332-1409419168.png"></p><p>其中 $cmax$ 为所选取中心点之间的最大距离。</p><p>　　隐含层至输出层之间的神经元的连接权值可以用最小二乘法直接计算得到，即对损失函数求解关于 $w$ 的偏导数，使其等于0，可以化简得到计算公式为：</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/729758-20180722120427494-1614136621.png" alt="729758-20180722120427494-1614136621"></p></li><li><p><strong>直接计算法</strong></p></li></ol><p>　　隐含层神经元的中心是随机地在输入样本中选取，且中心固定。一旦中心固定下来，隐含层神经元的输出便是已知的，这样的神经网络的连接权就可以通过求解线性方程组来确定。适用于样本数据的分布具有明显代表性。</p><ol start="3"><li><strong>有监督学习算法</strong></li></ol><p>　　通过训练样本集来获得满足监督要求的网络中心和其他权重参数，经历一个误差修正学习的过程，与BP网络的学习原理一样，同样采用梯度下降法。因此RBF同样可以被当作BP神经网络的一种$^{[2]}$。</p><h2 id="RBF神经网络特点"><a href="#RBF神经网络特点" class="headerlink" title="RBF神经网络特点"></a>RBF神经网络特点</h2><ul><li><p><strong>局部逼近</strong></p><p>RBF神经网络的隐神经元采用输入向量与中心向量的距离（如欧式距离）作为函数的自变量，并使用径向基函数（如Gaussian函数）作为激活函数。神经元的输入离径向基函数中心越远，神经元的激活程度就越低（高斯函数）。RBF网络的输出与部分调参数有关，譬如，一个$w_{ij}$值只影响一个$y_i$的输出，RBF神经网络因此具有<strong>“局部逼近”</strong>特性。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/OIP-C.GLdM4EpbPJngYMAZ_LAiGgHaFe" alt="查看源图像"></p><p>所谓局部逼近是指目标函数的逼近仅仅根据查询点附近的数据。而事实上，对于径向基网络，通常使用的是高斯径向基函数，函数图像是两边衰减且径向对称的，当选取的中心与查询点（即输入数据）很接近的时候才对输入有真正的映射作用，若中心与查询点很远的时候，欧式距离太大的情况下，输出的结果趋于0，所以真正起作用的点还是与查询点很近的点，所以是局部逼近。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/729758-20180722132644008-293319563.png" alt="img"></p></li><li><p><strong>训练速度快</strong></p><p>使用RBF的训练速度快，一方面是因为隐含层较少，另一方面，局部逼近可以简化计算量。对于一个输入x，只有部分神经元会有响应，其他的都近似为0，对应的w就不用调参了。</p></li></ul><h2 id="完全内插法及其不足"><a href="#完全内插法及其不足" class="headerlink" title="完全内插法及其不足"></a>完全内插法及其不足</h2><p>之所以RBF能够拟合任意函数，可以从内插法的角度去理解。要拟合一个曲线，我们可以通过内插法获得这个曲线的表达函数，譬如：多项式插值、拉格朗日插值等。RBF 插值是一系列精确插值方法的组合；即表面必须通过每一个测得的采样值。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/729758-20180722165318904-829097154.png" alt="img"></p><p>　　对于RBF插值，其特点即为，在输入数据集中，与中心点距离近的点对映射函数的贡献最大。　　</p><p>　　完全内插法即要求所有插值点都经过曲面，由于RBF内插对于每个x都有用到，所以是一种完全内插的形式，存在的问题就是当样本中包含噪声时，神经网络将拟合出一个错误的曲面，从而使泛化能力下降。另外，若样本x的数据远大于非线性函数φ，该求解变得不稳定，即为解超定方程。因此需要引入正则化方法，正则化的方法即通常加上正则化项。</p><p><img src="https://pic1.zhimg.com/80/v2-2c2b60a77f39b0b607039b5fcc090e2a_1440w.webp?source=1940ef5c" alt="img"></p><h2 id="两类径向基神经网络-4"><a href="#两类径向基神经网络-4" class="headerlink" title="两类径向基神经网络$^{[4]}$"></a>两类径向基神经网络$^{[4]}$</h2><h3 id="正则化网络"><a href="#正则化网络" class="headerlink" title="正则化网络"></a>正则化网络</h3><p>性质：<br>• 正则化网络是一个通用逼近器，意味着，只要有足够多的隐含节点，它就可以以任意精度逼近任意多远连续函数。<br>• 给定一个未知的非线性函数f,总可以选择一组系数，使得网络对f 的逼近是最优的。<br>特点：　<br>• 隐含节点的个数等于输入训练样本的个数，因此如果训练样本的个数Ｎ过大，网络的计算量将是惊人的，从而导致过低的效率甚至根本不可能实现。计算权值wij时，需要计算Ｎ×Ｎ矩阵的逆，其复杂度大约是O(N3)，随着Ｎ的增长，计算的复杂度迅速增大。<br>• 矩阵过大，病态矩阵的可能性越高。矩阵Ａ的病态是指，求解线性方程组Ａｘ = b时，Ａ中数据的微小扰动会对结果产生很大影响。病态成都往往用矩阵条件数来衡量，条件数等于矩阵最大特征值与最小特征值的比值。</p><h3 id="广义网络"><a href="#广义网络" class="headerlink" title="广义网络"></a>广义网络</h3><p>区别于正则化网络：正则化网络隐含节点数I等于输入训练样本的个数M，即是I=M。但广义网络隐含层I个节点个数小于M个输入节点，I&lt;M。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下文代码中RBF神经网络采用<strong>直接计算法</strong>进行学习。代码框架参考文章$^{[3]}$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> scipy.linalg <span class="hljs-keyword">import</span> norm, pinv<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RBFN</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, indim, numCenters, outdim</span>):</span><br>        self.indim = indim  <span class="hljs-comment"># 输入层维度</span><br>        self.outdim = outdim  <span class="hljs-comment"># 输出层维度</span><br>        self.numCenters = numCenters  <span class="hljs-comment"># 中心（隐层神经元）数量</span><br>        self.centers = [np.random.uniform(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, indim) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(numCenters)]  <span class="hljs-comment"># 初始化中心</span><br>        self.beta = <span class="hljs-number">8</span>  <span class="hljs-comment"># 方差初始化</span><br>        self.W = np.random.random((self.numCenters, self.outdim))  <span class="hljs-comment"># 初始化权值</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_basisfunc</span>(<span class="hljs-params">self, c, d</span>):</span>  <span class="hljs-comment"># 激活函数定义</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(d) == self.indim<br>        <span class="hljs-keyword">return</span> np.exp(-(norm(c - d) ** <span class="hljs-number">2</span>) / (<span class="hljs-number">2</span> * self.beta ** <span class="hljs-number">2</span>))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_calcAct</span>(<span class="hljs-params">self, X</span>):</span>  <span class="hljs-comment"># 计算激活函数</span><br>        <span class="hljs-comment"># calculate activations of RBFs</span><br>        G = np.zeros((X.shape[<span class="hljs-number">0</span>], self.numCenters), <span class="hljs-built_in">float</span>)<br>        <span class="hljs-keyword">for</span> ci, c <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.centers):<br>            <span class="hljs-keyword">for</span> xi, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(X):<br>                G[xi, ci] = self._basisfunc(c, x)<br>        <span class="hljs-keyword">return</span> G<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_calcbeta</span>(<span class="hljs-params">self</span>):</span>  <span class="hljs-comment"># 找到选取中心点最大值——及求解σ的值</span><br>        bate_temp = np.zeros((self.numCenters, self.numCenters))  <span class="hljs-comment"># 定义一个矩阵 隐藏层中心值确定的</span><br>        <span class="hljs-keyword">for</span> iindex, ivalue <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.centers):<br>            <span class="hljs-keyword">for</span> jindex, jvalue <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.centers):<br>                bate_temp[iindex, jindex] = norm(ivalue - jvalue)  <span class="hljs-comment"># 依次求解各中心层的值</span><br>        <span class="hljs-keyword">return</span> np.<span class="hljs-built_in">max</span>(bate_temp) / np.sqrt(<span class="hljs-number">2</span> * self.numCenters)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span>(<span class="hljs-params">self, X, Y</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :param X: 样本数*输入变量数</span><br><span class="hljs-string">        :param Y:样本数*输出变量数</span><br><span class="hljs-string">        :return:无</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># choose random center vectors from training set</span><br>        rnd_idx = np.random.permutation(X.shape[<span class="hljs-number">0</span>])[:self.numCenters]<br>        self.centers = [X[i, :] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> rnd_idx]<br>        <span class="hljs-comment"># print(&quot;center&quot;, self.centers)</span><br>        self.beta = self._calcbeta()  <span class="hljs-comment"># 根据样本中心计算σ值</span><br>        <span class="hljs-comment"># print(self.beta)</span><br>        <span class="hljs-comment"># calculate activations of RBFs</span><br>        G = self._calcAct(X)<br>        <span class="hljs-comment"># print(G)</span><br>        <span class="hljs-comment"># calculate output weights (pseudoinverse)</span><br>        self.W = np.dot(pinv(G), Y)  <span class="hljs-comment"># 伪逆法直接计算得到权值</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self, X</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot; X: matrix of dimensions n x indim &quot;&quot;&quot;</span><br>        G = self._calcAct(X)<br>        Y = np.dot(G, self.W)<br>        <span class="hljs-keyword">return</span> Y<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_data</span>(<span class="hljs-params">x1, x2</span>):</span><br>    y_all = np.sin(np.pi * x2 / <span class="hljs-number">2</span>) + np.cos(np.pi * x2 / <span class="hljs-number">3</span>)<br>    y_sample = np.sin(np.pi * x1 / <span class="hljs-number">2</span>) + np.cos(np.pi * x1 / <span class="hljs-number">3</span>)<br>    <span class="hljs-comment"># set y and add random noise</span><br>    <span class="hljs-comment"># y_sample += np.random.normal(0, 0.1, y_sample.shape)</span><br>    <span class="hljs-keyword">return</span> y_sample, y_all<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    num_sample = <span class="hljs-number">30</span><br>    <span class="hljs-comment"># 数据生成</span><br>    x1 = np.linspace(-<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, num_sample).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    x2 = np.linspace(-<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, (num_sample - <span class="hljs-number">1</span>) * <span class="hljs-number">20</span> + <span class="hljs-number">1</span>).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    y_sample, y_all = gen_data(x1, x2)<br><br>    <span class="hljs-comment"># Enable interactive mode.</span><br>    plt.ion()<br>    <span class="hljs-comment"># Create a figure and a set of subplots.</span><br>    figure, ax = plt.subplots()<br>    <span class="hljs-comment"># plot original data</span><br>    plt.plot(x2, y_all, <span class="hljs-string">&#x27;r:&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    <span class="hljs-comment"># plot input samples</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x1)):<br>        plt.plot(x1[i], y_sample[i], <span class="hljs-string">&#x27;go&#x27;</span>, markerfacecolor = <span class="hljs-string">&#x27;none&#x27;</span>)<br>    <span class="hljs-comment"># return AxesImage object for using.</span><br>    pre_lines, = ax.plot([], [])<br>    pre_lines.set_color(<span class="hljs-string">&#x27;k&#x27;</span>)<br>    center_points, = ax.plot([], [])<br>    center_points.set_color(<span class="hljs-string">&#x27;gray&#x27;</span>)<br>    center_points.set_marker(<span class="hljs-string">&#x27;s&#x27;</span>)<br>    ax.set_autoscaley_on(<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># ax.set_xlim(min_x, max_x)</span><br>    ax.grid()<br>    <span class="hljs-comment"># plot learned model dynamically</span><br>    <span class="hljs-keyword">for</span> n_center <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, num_sample):<br>        <span class="hljs-comment"># RBF神经网络训练预测</span><br>        rbf = RBFN(<span class="hljs-number">1</span>, n_center, <span class="hljs-number">1</span>)<br>        rbf.train(x1, y_sample)<br>        y_rec = rbf.test(x2)<br>        <span class="hljs-comment"># update x, y data</span><br>        pre_lines.set_xdata(x2)<br>        pre_lines.set_ydata(y_rec)<br>        plt.title(<span class="hljs-string">&#x27;RBFN interpolation:$y=sin(\pi x/2)+cos(\pi x/3)$ with &#x27;</span> + <span class="hljs-built_in">str</span>(n_center) + <span class="hljs-string">&#x27; centers&#x27;</span>)<br>        <span class="hljs-comment"># update centers</span><br>        center_points.set_xdata(rbf.centers)<br>        center_points.set_ydata(np.zeros(rbf.numCenters))<br>        <span class="hljs-comment"># Need both of these in order to rescale</span><br>        ax.relim()<br>        ax.autoscale_view()<br>        <span class="hljs-comment"># draw and flush the figure .</span><br>        figure.canvas.draw()<br>        figure.canvas.flush_events()<br>        time.sleep(<span class="hljs-number">1</span>)<br>    plt.figure(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>代码中，方差 $\sigma$ 计算公式如下：<br>$$<br>\sigma=\frac{d_{\max }}{\sqrt{2 n}}<br>$$<br>这里 $\mathrm{d}_{\max }$ 是选取中心的之间的最大距离。 $\mathrm{n}$ 为隐函数节点的个数。防止径向基函数出现过尖或过平的情况。</p><p>对于隐层神经元的选取，代码中通过迭代寻找最优隐函数节点个数。</p><p><img src="D:\mstifiynotes\TestRBFN.gif"></p><blockquote><p>上图中，绿色空心圆点为输入的训练样本，红色虚线为实际值，黑色曲线为RBF神经网络预测结果，其中x轴上的灰色方点为中心点。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://zhuanlan.zhihu.com/p/539947241">一文带你了解RBF神经网络</a></p><p>[2] <a href="https://www.cnblogs.com/pinking/p/9349695.html">RBF（径向基）神经网络</a></p><p>[3] <a href="https://blog.csdn.net/qq_36305492/article/details/111402927">python编写自己的RBF径向基神经网络</a></p><p>[4] <a href="https://blog.csdn.net/weixin_43935696/article/details/109474495">所有神经网络的特点及优缺点分析总结</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RBF三维应力插值</title>
    <link href="/2022/11/03/RBF%E4%B8%89%E7%BB%B4%E5%BA%94%E5%8A%9B%E6%8F%92%E5%80%BC/"/>
    <url>/2022/11/03/RBF%E4%B8%89%E7%BB%B4%E5%BA%94%E5%8A%9B%E6%8F%92%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>参见上一篇：<a href="https://blog.csdn.net/qq_39784672/article/details/127656592">径向基函数（RBF）插值</a></p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>下文简单测试了三维下的RBF函数插值。</p><p>测试代码如下：</p><p><strong><code>Test_RBF_interp3d.py</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier  <span class="hljs-comment"># KNN</span><br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br><span class="hljs-keyword">from</span> scipy.interpolate <span class="hljs-keyword">import</span> Rbf<br><br><span class="hljs-keyword">import</span> RBF<br><span class="hljs-keyword">import</span> visualization<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    data = pd.read_csv(<span class="hljs-string">&quot;procast导出应力数据/ES_result.csv&quot;</span>).values<br>    all_points, all_stress = data[-<span class="hljs-number">1000</span>:, :<span class="hljs-number">3</span>], data[-<span class="hljs-number">1000</span>:, <span class="hljs-number">3</span>]  <span class="hljs-comment"># 共计1000个节点</span><br>    knn = KNeighborsClassifier(n_neighbors = <span class="hljs-number">1</span>, algorithm = <span class="hljs-string">&#x27;ball_tree&#x27;</span>)<br>    knn.fit(all_points, [<span class="hljs-number">1</span>] * <span class="hljs-built_in">len</span>(all_points))  <span class="hljs-comment"># 构建KNN</span><br>    indexes = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(all_points)))<br>    sample_points = []<br>    distance, n_points = knn.kneighbors(all_points, n_neighbors = <span class="hljs-number">2</span>, return_distance = <span class="hljs-literal">True</span>)  <span class="hljs-comment"># 寻找邻近的15个点</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(indexes) &gt;= <span class="hljs-number">15</span>:<br>        sample_index = choice(indexes)<br>        sample_points.append(np.mean(all_points[[n_points[sample_index]], :].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), axis = <span class="hljs-number">0</span>))  <span class="hljs-comment"># 按列求平均值构造采样点</span><br>        indexes = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> indexes <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> n_points[sample_index]]<br>    sample_points = np.array(sample_points)<br>    <span class="hljs-comment"># print(sample_points.shape)</span><br>    <span class="hljs-comment"># visualization.viz_nodes(sample_points)</span><br>    w = RBF.rbf_coefficient(all_points, all_stress, <span class="hljs-string">&quot;linear&quot;</span>)<br>    pre_stress = RBF.rbf_interpolation(all_points, w, sample_points, <span class="hljs-string">&quot;linear&quot;</span>)<br>    <span class="hljs-comment"># funs = Rbf(all_points[:, 0], all_points[:, 1], all_points[:, 2], all_stress, function = &#x27;gaussian&#x27;)</span><br>    <span class="hljs-comment"># pre_stress = funs(sample_points[:, 0], sample_points[:, 1], sample_points[:, 2])</span><br>    <span class="hljs-comment"># print(pre_stress)</span><br>    visualization.viz_nodes(np.vstack((all_points, sample_points)),<br>                            np.vstack((all_stress.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), pre_stress.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))))<br></code></pre></td></tr></table></figure><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>结果中，小点点为控制节点坐标，小叉叉为插值节点坐标。节点颜色的深浅与应力大小相映射。</p><ul><li><p><strong>gaussian基函数</strong></p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221103125805809.png" alt="image-20221103125805809"></p></li><li><p><strong>cubic基函数</strong></p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221103125948450.png" alt="image-20221103125948450"></p></li><li><p>linear基函数</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221103130039374.png" alt="image-20221103130039374"></p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><strong>高斯核宽度取值影响插值结果</strong></p><p>当基函数为高斯基函数时，其核函数如下：<br>$$<br>\quad \varphi(r)=\exp \left(-\frac{r^2}{2 \sigma^2}\right)<br>$$<br>其中 $r$ 为欧式距离，$\sigma$ 为核函数宽度。</p><p>根据测试可知，$\sigma$ 取值不同将得到不同的插值结果。鉴于scipy库中已实现RBF插值函数的封装，打开其函数定义，我们可以发现，在scipy中，高斯基函数定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_h_gaussian</span>(<span class="hljs-params">self, r</span>):</span><br>    <span class="hljs-keyword">return</span> np.exp(-(<span class="hljs-number">1.0</span>/self.epsilon*r)**<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>即<br>$$<br>\quad \varphi(r)=\exp \left(-\frac{r^2}{\epsilon^2}\right)<br>$$<br>scipy插值库中<code>self.epsilon</code>默认取基于边界超立方体的“节点之间的平均距离”，计算代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> self.epsilon <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br><span class="hljs-comment"># default epsilon is the &quot;the average distance between nodes&quot; based on a bounding hypercube</span><br>ximax = np.amax(self.xi, axis=<span class="hljs-number">1</span>)<br>ximin = np.amin(self.xi, axis=<span class="hljs-number">1</span>)<br>edges = ximax - ximin<br>edges = edges[np.nonzero(edges)]<br>self.epsilon = np.power(np.prod(edges)/self.N, <span class="hljs-number">1.0</span>/edges.size)<br></code></pre></td></tr></table></figure><p>在本三维插值测试中，$\epsilon$ 的计算公式为<br>$$<br>\epsilon =     \sqrt[3]{\frac{V}{N}}<br>$$<br>其中 $V$ 为所有节点包围盒的体积，$N$ 为节点总数。</p><p>仿照scipy源码，我们可以如下计算得到高斯核宽度<br>$$<br>\sigma = \frac{\sqrt{2}}{2}\sqrt[3]{\frac{V}{N}}<br>$$</p><blockquote><p>对于Multiquadrics基函数中的 $\sigma$ 也应当合理取值。 </p></blockquote></li><li></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>径向基函数（RBF）插值</title>
    <link href="/2022/11/02/%E5%BE%84%E5%90%91%E5%9F%BA%E5%87%BD%E6%95%B0%EF%BC%88RBF%EF%BC%89%E6%8F%92%E5%80%BC/"/>
    <url>/2022/11/02/%E5%BE%84%E5%90%91%E5%9F%BA%E5%87%BD%E6%95%B0%EF%BC%88RBF%EF%BC%89%E6%8F%92%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="RBF函数插值"><a href="#RBF函数插值" class="headerlink" title="RBF函数插值"></a>RBF函数插值</h2><p>径向基函数（Radial Basis Function, RBF）插值的基本形式为<br>$$<br>F(\boldsymbol{r})=\sum_{i=1}^N w_i \varphi\left(\left|\boldsymbol{r}-\boldsymbol{r}_i\right|\right)<br>$$<br>式中， $F(\boldsymbol{r})$ 是插值函数， $N$ 为插值问题所使用的径向基函数总数目（控制点总数目）， $\varphi\left(\left|\boldsymbol{r}-\boldsymbol{r}_i\right|\right)$ 是采用的径向基函数的通用形式， $\left|\boldsymbol{r}-\boldsymbol{r}_i\right|$ 是两个位置矢量的欧氏距离， $\boldsymbol{r}_i$ 是第 $i$ 号径向基函数的控制点位置， $w_i$ 是第 $i$ 号径向基函数对应的权重系数。</p><p>径向基函数类型很多，总结有如下六种：</p><ol><li>Gaussian（高斯曲面函数）：$\quad \varphi(x)=\exp \left(-\frac{x^2}{2 \sigma^2}\right)$</li><li>Multiquadrics（多项式函数）：$\quad \varphi(x)=\sqrt{1+\frac{x^2}{\sigma^2}}$</li><li>Linear（线性函数）：$\varphi(x)=x$</li><li>Cubic（立方体曲面函数）：$\varphi(x)=x^3$</li><li>Thinplate（薄板曲面函数）：$\quad \varphi(x)=x^2 \ln (x+1)$</li><li>Wendland’s $C^2$ 函数（网格变形常用）：$\varphi(x)=(1-x)^4(4 x+1)$</li></ol><p>现有一系列控制（插值）节点 $\left.\left{r_j, F(\boldsymbol{r})<em>j\right}\right|</em>{j=1} ^N$（插值函数 $F(\boldsymbol{r})$ 必须经过控制节点），将其带入方程 $F(\boldsymbol{r})=\sum_{i=1}^N w_i \varphi\left(\left|\boldsymbol{r}-\boldsymbol{r}<em>i\right|\right)$ ，可得到:<br>$$<br>\underbrace{\left[\begin{array}{cccc}\varphi</em>{11} &amp; \varphi_{12} &amp; \cdots &amp; \varphi_{1 N} \ \varphi_{21} &amp; \varphi_{22} &amp; \cdots &amp; \varphi_{2 N} \ \vdots &amp; \vdots &amp; &amp; \vdots \ \varphi_{11} &amp; \varphi_{12} &amp; \cdots &amp; \varphi_{1 N}\end{array}\right]}<em>{\Phi} \underbrace{\left[\begin{array}{c}w_1 \ w_2 \ \vdots \ w_N\end{array}\right]}</em>{\mathbf{W}}=\underbrace{\left[\begin{array}{c}y_1 \ y_2 \ \vdots \ y_N\end{array}\right]}<em>{\mathbf{y}} ,其中  \varphi</em>{j i}=\varphi\left(\left|r_j-r_i\right|\right)<br>$$<br>上式中，$\Phi=\left[\varphi_{j i}\right]$ 为插值矩阵。将线性方程组记为 $\Phi \mathbf{W}=\mathbf{y}$ ，可求出 $\mathrm{RBF}$ 插值的权重系数为: $\mathbf{W}=\Phi^{-1} \mathbf{y}$ 。在得到每个控制点的权重系数后，就能求出定义域内任意插值点所对应的 $F(\boldsymbol{r})$ ，实现插值的功能。</p><h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><p>文章$^{[1]}$中代码主要实现的是一维下高斯基函数插值，文章$^{[2]}$中代码实现的主要是多维下的Wendland’s $C^2$基函数插值。借鉴上面篇代码，稍微修改精简一下。</p><p><strong><code>RBF.py</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy.linalg <span class="hljs-keyword">import</span> solve<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rbf_coefficient</span>(<span class="hljs-params">support_points, support_values, function_name = <span class="hljs-string">&#x27;C2&#x27;</span>, radius = <span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    计算并返回径向基(radical basis function, RBF)插值函数的插值系数</span><br><span class="hljs-string">    :param support_points: 径向基插值的支撑点</span><br><span class="hljs-string">    :param support_values: 支撑点上的物理量，如位移、压力等</span><br><span class="hljs-string">    :param function_name: 使用的径向基函数，默认为 Wendland C2 函数</span><br><span class="hljs-string">    :param radius: 径向基函数的作用半径，默认作用范围包含所有支撑点</span><br><span class="hljs-string">    :return: coefficient_mat, 径向基函数的插值系数矩阵</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    num_support_points, dim = np.shape(support_points)<br>    phi_mat = np.zeros((num_support_points, num_support_points), dtype = np.<span class="hljs-built_in">float</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_support_points):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_support_points):<br>            eta = np.linalg.norm(support_points[i] - support_points[j])<br>            <span class="hljs-keyword">if</span> radius <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                eta = eta / radius<br>                <span class="hljs-keyword">if</span> eta &gt; <span class="hljs-number">1</span>:<br>                    <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> function_name == <span class="hljs-string">&#x27;C2&#x27;</span>:<br>                phi_mat[i, j] = (<span class="hljs-number">1</span> - eta) ** <span class="hljs-number">4</span> * (<span class="hljs-number">4</span> * eta + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">elif</span> function_name == <span class="hljs-string">&#x27;cubic&#x27;</span>:<br>                phi_mat[i, j] = eta ** <span class="hljs-number">3</span><br>            <span class="hljs-keyword">elif</span> function_name == <span class="hljs-string">&#x27;linear&#x27;</span>:<br>                phi_mat[i, j] = eta<br>            <span class="hljs-keyword">elif</span> function_name == <span class="hljs-string">&#x27;gaussian&#x27;</span>:<br>                sig = <span class="hljs-number">1</span>  <span class="hljs-comment"># 高斯核宽度</span><br>                phi_mat[i, j] = np.exp(-<span class="hljs-number">1</span> * eta ** <span class="hljs-number">2</span> / (<span class="hljs-number">2</span> * (sig ** <span class="hljs-number">2</span>)))<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;暂不支持此插值函数&#x27;</span>)<br>                <span class="hljs-keyword">return</span><br>    coefficient_mat = solve(phi_mat, support_values)<br>    <span class="hljs-keyword">return</span> coefficient_mat<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rbf_interpolation</span>(<span class="hljs-params">support_points, coefficient_mat, interpolation_points, function_name = <span class="hljs-string">&#x27;C2&#x27;</span>, radius = <span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    计算并返回RBF插值的结果</span><br><span class="hljs-string">    :param support_points: 支撑点</span><br><span class="hljs-string">    :param coefficient_mat: 插值系数矩阵</span><br><span class="hljs-string">    :param interpolation_points: 插值点</span><br><span class="hljs-string">    :param function_name: 插值函数名，默认为 Wendland C2</span><br><span class="hljs-string">    :param radius: 插值函数作用半径，默认作用范围包含所有支撑点</span><br><span class="hljs-string">    :return: interpolation_values, 插值点的物理量</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    num_interpolation_points, dim = np.shape(interpolation_points)<br>    num_support_points = np.shape(support_points)[<span class="hljs-number">0</span>]<br>    interpolation_values = np.zeros((num_interpolation_points, dim), dtype = np.<span class="hljs-built_in">float</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_interpolation_points):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_support_points):<br>            eta = np.linalg.norm(interpolation_points[i] - support_points[j])<br>            <span class="hljs-keyword">try</span>:<br>                eta = eta / radius<br>                <span class="hljs-keyword">if</span> eta &gt; <span class="hljs-number">1</span>:<br>                    interpolation_values[i] += coefficient_mat[j] * <span class="hljs-number">0</span>  <span class="hljs-comment"># phi = 0</span><br>                    <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">except</span> TypeError:<br>                <span class="hljs-keyword">pass</span><br>            <span class="hljs-keyword">finally</span>:<br>                <span class="hljs-keyword">if</span> function_name == <span class="hljs-string">&#x27;C2&#x27;</span>:<br>                    phi = (<span class="hljs-number">1</span> - eta) ** <span class="hljs-number">4</span> * (<span class="hljs-number">4</span> * eta + <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">elif</span> function_name == <span class="hljs-string">&#x27;cubic&#x27;</span>:<br>                    phi = eta ** <span class="hljs-number">3</span><br>                <span class="hljs-keyword">elif</span> function_name == <span class="hljs-string">&#x27;linear&#x27;</span>:<br>                    phi = eta<br>                <span class="hljs-keyword">elif</span> function_name == <span class="hljs-string">&#x27;gaussian&#x27;</span>:<br>                    sig = <span class="hljs-number">1</span>  <span class="hljs-comment"># 高斯核宽度</span><br>                    phi = np.exp(-<span class="hljs-number">1</span> * eta ** <span class="hljs-number">2</span> / (<span class="hljs-number">2</span> * (sig ** <span class="hljs-number">2</span>)))<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;暂不支持此插值函数&#x27;</span>)<br>                    <span class="hljs-keyword">return</span><br>            interpolation_values[i] += coefficient_mat[j] * phi<br>    <span class="hljs-keyword">return</span> interpolation_values<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculation_rmse</span>(<span class="hljs-params">y_hat, y</span>):</span><br>    rmse = np.sqrt(np.mean(np.square(y - y_hat)))<br>    <span class="hljs-keyword">return</span> rmse<br></code></pre></td></tr></table></figure><p>测试代码如下：</p><p><strong><code>test.py</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> RBF<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_data</span>(<span class="hljs-params">x1, x2</span>):</span><br>    y_sample = np.sin(np.pi * x1 / <span class="hljs-number">2</span>) + np.cos(np.pi * x1 / <span class="hljs-number">3</span>)<br>    y_all = np.sin(np.pi * x2 / <span class="hljs-number">2</span>) + np.cos(np.pi * x2 / <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">return</span> y_sample, y_all<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    function_name = <span class="hljs-string">&quot;gaussian&quot;</span><br>    snum = <span class="hljs-number">20</span>  <span class="hljs-comment"># control point数量</span><br>    ratio = <span class="hljs-number">20</span>  <span class="hljs-comment"># 总数据点数量：snum*ratio</span><br>    xs = -<span class="hljs-number">8</span><br>    xe = <span class="hljs-number">8</span><br>    x1 = np.linspace(xs, xe, snum).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    x2 = np.linspace(xs, xe, (snum - <span class="hljs-number">1</span>) * ratio + <span class="hljs-number">1</span>).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    y_sample, y_all = gen_data(x1, x2)<br>    plt.figure(<span class="hljs-number">1</span>)<br>    w = RBF.rbf_coefficient(x1, y_sample, function_name)<br>    y_rec = RBF.rbf_interpolation(x1, w, x2, function_name)<br>    rmse = RBF.calculation_rmse(y_rec, y_all)<br>    <span class="hljs-built_in">print</span>(rmse)<br>    plt.plot(x2, y_rec, <span class="hljs-string">&#x27;k&#x27;</span>)<br>    plt.plot(x2, y_all, <span class="hljs-string">&#x27;r:&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x1)):<br>        plt.plot(x1[i], y_sample[i], <span class="hljs-string">&#x27;go&#x27;</span>, markerfacecolor = <span class="hljs-string">&#x27;none&#x27;</span>)<br>    plt.legend(labels = [<span class="hljs-string">&#x27;reconstruction&#x27;</span>, <span class="hljs-string">&#x27;original&#x27;</span>, <span class="hljs-string">&#x27;control point&#x27;</span>], loc = <span class="hljs-string">&#x27;lower left&#x27;</span>)<br>    plt.title(function_name + <span class="hljs-string">&#x27; kernel interpolation:$y=sin(\pi x/2)+cos(\pi x/3)$&#x27;</span>)<br>    plt.show()<br></code></pre></td></tr></table></figure><p>测试结果如下（一维插值）：</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/Figure_1.png" alt="Figure_1"></p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/Figure_2.png" alt="Figure_2"></p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/Figure_3.png" alt="Figure_3"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于rbf插值中，一般控制点数量越多越密集，插值精度也就越高，但是随之而来的插值矩阵 $\Phi$ 增大，计算量增大，模型训练（权值系数计算）效率变低，正所谓“No Free Lunch”。其次，不同的基函数在同样的数据上插值的表现也有所差异，因此需要选择最优的基函数进行插值计算。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://blog.csdn.net/xfijun/article/details/105670892">https://blog.csdn.net/xfijun/article/details/105670892</a></p><p>[2] <a href="https://zhuanlan.zhihu.com/p/339854179">https://zhuanlan.zhihu.com/p/339854179</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas快速笔记</title>
    <link href="/2022/11/02/Pandas%E5%BF%AB%E9%80%9F%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/02/Pandas%E5%BF%AB%E9%80%9F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Pandas-1"><a href="#1-Pandas-1" class="headerlink" title="1 Pandas$^{[1]}$"></a>1 Pandas$^{[1]}$</h2><p>python下数据分析库。</p><h3 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h3><h4 id="1-1-1-Series"><a href="#1-1-1-Series" class="headerlink" title="1.1.1 Series"></a>1.1.1 <strong>Series</strong></h4><p>Pandas Series 类似表格中的一个<strong>列</strong>（column），类似于一维数组，可以保存任何数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pandas.Series( data, index, dtype, name, copy)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>data</strong>：一组数据(ndarray 类型)。</li><li><strong>index</strong>：数据索引标签，如果不指定，默认从 0 开始。</li><li><strong>dtype</strong>：数据类型，默认会自己判断。</li><li><strong>name</strong>：设置名称。</li><li><strong>copy</strong>：拷贝数据，默认为 False。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(pd.Series([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;数据3&quot;</span>], [<span class="hljs-string">&quot;数据1&quot;</span>, <span class="hljs-string">&quot;数据2&quot;</span>, <span class="hljs-number">3</span>]))<span class="hljs-comment">#data,index构造</span><br><span class="hljs-built_in">print</span>(pd.Series(&#123;<span class="hljs-string">&quot;数据1&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;数据2&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-number">3</span>: <span class="hljs-string">&quot;数据3&quot;</span>&#125;))<span class="hljs-comment">#字典key:value构造</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">数据<span class="hljs-number">1</span>      <span class="hljs-number">1</span><br>数据<span class="hljs-number">2</span>      <span class="hljs-number">2</span><br><span class="hljs-number">3</span>      数据<span class="hljs-number">3</span><br>dtype: <span class="hljs-built_in">object</span><br>数据<span class="hljs-number">1</span>      <span class="hljs-number">1</span><br>数据<span class="hljs-number">2</span>      <span class="hljs-number">2</span><br><span class="hljs-number">3</span>      数据<span class="hljs-number">3</span><br>dtype: <span class="hljs-built_in">object</span><br></code></pre></td></tr></table></figure><blockquote><p>左侧一列是索引，右侧一列是数据，一一对应。</p></blockquote><h4 id="1-1-2-DataFrame"><a href="#1-1-2-DataFrame" class="headerlink" title="1.1.2 DataFrame"></a>1.1.2 <strong>DataFrame</strong></h4><p>DataFrame 是一个<strong>表格型</strong>的数据结构）。DataFrame 既有行索引也有列索引，它可以被看做由 Series 组成的字典（共同用一个索引）。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/df-dp.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pandas.DataFrame( data, index, columns, dtype, copy)<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>data</strong>：一组数据(ndarray、series, map, lists, dict 等类型)。</li><li><strong>index</strong>：索引值，或者可以称为行标签。</li><li><strong>columns</strong>：列标签，默认为 RangeIndex (0, 1, 2, …, n) 。</li><li><strong>dtype</strong>：数据类型。</li><li><strong>copy</strong>：拷贝数据，默认为 False。</li></ul><h5 id="loc属性"><a href="#loc属性" class="headerlink" title=".loc属性"></a>.loc属性</h5><p>返回指定行的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[<span class="hljs-number">0</span>]<span class="hljs-comment">#返回第一行（单行），返回一个Series</span><br>df.loc[[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]<span class="hljs-comment">#返回第一行和第二行（多行），返回一个DataFrame</span><br>df.loc[<span class="hljs-string">&quot;行索引&quot;</span>]<br></code></pre></td></tr></table></figure><h4 id="1-1-3-CSV文件"><a href="#1-1-3-CSV文件" class="headerlink" title="1.1.3 CSV文件"></a>1.1.3 <strong>CSV文件</strong></h4><p>CSV（Comma-Separated Values，逗号分隔值，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">&quot;xxx.csv&quot;</span>)<span class="hljs-comment">#读取csv文件并返回一个DataFrame</span><br>df.to_csv(<span class="hljs-string">&quot;xxx.csv&quot;</span>)<span class="hljs-comment">#将DataFrame保存为csv文件</span><br>df.head(n)<span class="hljs-comment">#返回前n行，默认为5</span><br>df.tail(n)<span class="hljs-comment">#返回最后n行，默认为5</span><br>df.info()<span class="hljs-comment">#返回表格的一些基本信息</span><br></code></pre></td></tr></table></figure><h4 id="1-1-4-数据操作"><a href="#1-1-4-数据操作" class="headerlink" title="1.1.4 数据操作"></a>1.1.4 <strong>数据操作</strong></h4><ul><li><p>**<code>dropna()</code>**删除包含空字段的行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">DataFrame.dropna(axis=<span class="hljs-number">0</span>, how=<span class="hljs-string">&#x27;any&#x27;</span>, thresh=<span class="hljs-literal">None</span>, subset=<span class="hljs-literal">None</span>, inplace=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li>axis：默认为 <strong>0</strong>，表示逢空值剔除整行，如果设置参数 <strong>axis＝1</strong> 表示逢空值去掉整列。</li><li>how：默认为 <strong>‘any’</strong> 如果一行（或一列）里任何一个数据有出现 NA 就去掉整行，如果设置 <strong>how=’all’</strong> 一行（或列）都是 NA 才去掉这整行。</li><li>thresh：设置需要多少非空值的数据才可以保留下来的。</li><li>subset：设置想要检查的列。如果是多个列，可以使用列名的 list 作为参数。</li><li>inplace：如果设置 True，将计算得到的值直接覆盖之前的值并返回 None，修改的是源数据。</li></ul></li><li><p>**<code>isnull()</code>**判断各个单元格是否为空。</p></li><li><p>**<code>fillna()</code>**替换空字段。</p></li><li><p>**<code>duplicated()</code>**判断对应数据是否重复。</p></li><li><p><strong><code>drop_duplicates()</code></strong> 删除重复数据。</p></li><li><p>**<code>merge</code>**合并表格（DataFrame）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">newData = pd.merge(left, right, how: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;inner&quot;</span>, on=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li>left和right均为DataFrame类型</li><li>how指定合并方式：<ul><li>inner（缺省）：求交</li><li>left：以左表格为主进行合并</li><li>right：以右表格为主进行合并</li><li>outer：求并</li></ul></li><li>on指定按某一列进行合并</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://www.runoob.com/pandas/pandas-tutorial.html">Pandas 教程 | 菜鸟教程 (runoob.com)</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ProCast导出节点应力数据并格式化</title>
    <link href="/2022/10/31/ProCast%E5%AF%BC%E5%87%BA%E8%8A%82%E7%82%B9%E5%BA%94%E5%8A%9B%E6%95%B0%E6%8D%AE%E5%B9%B6%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
    <url>/2022/10/31/ProCast%E5%AF%BC%E5%87%BA%E8%8A%82%E7%82%B9%E5%BA%94%E5%8A%9B%E6%95%B0%E6%8D%AE%E5%B9%B6%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="ProCast导出ci-data-csv"><a href="#ProCast导出ci-data-csv" class="headerlink" title="ProCast导出ci_data.csv"></a>ProCast导出ci_data.csv</h2><p>打开visual-viewer，加载计算结果文件。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221031180111886.png"></p><p>注意导出的数据是当前步数下的计算数据，可以改变步数实现不同步数下数据的导出。</p><p>在工具栏右键打开Selection工具条，切换到Node模式。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221031180315074.png" alt="image-20221031180315074"></p><p>将导出模型的所有节点选上。节点选中无误后，在视图窗口右键选择<code>Properties</code>，<code>Ctrl+A</code>选中弹出窗口左侧的所有节点后，点击保存图标，将默认的<code>ci_data.txt</code>文件名改为<code>ci_data.csv</code>方便后续操作。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221031180809860.png"></p><p>用记事本打开导出的数据，如下所示，</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221031181331668.png"></p><p>可以看出此时数据很冗余，并不能供我们分析，接下来需要将其format成我们需要的格式。</p><blockquote><p>注意，这种方法每次只能导出10000个节点数据，超过单次上限的情况需要使用<code>Filter</code>分批导出。</p></blockquote><h2 id="Excel格式化"><a href="#Excel格式化" class="headerlink" title="Excel格式化"></a>Excel格式化</h2><p>用Excel打开我们导出的ci_data.csv文件，参考格式化思路如下：</p><ul><li><p>选中第一列，数据/分列-&gt;分隔符号-&gt;空格。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221031182001997.png"></p></li><li><p>全选后，数据/删除重复值。</p></li><li><p>选中如下所示行列（第1、4行、第1列），删除。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221031182258778.png"></p></li><li><p>新建一列，命名为<code>Effective Stress</code>，当列使用公式进行快捷赋值填充。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221031182557960.png"></p></li><li><p>将生成的列进行复制，只保留值，再删除公式生成的那一列。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221031182946438.png">选中第一列，数据/筛选，将单元内容为<code>Effective</code>的行筛选出来后，全选，右键删除行。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221031183411239.png"></p></li><li><p>删除完成后，将其他数据显示出来，退出筛选。</p></li><li><p>至此，单个文件格式化完成，内容如下：</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221031183803088.png"></p></li></ul><blockquote><p>如果导出多个文件的话，在完成格式化后，还需将文件进行合并。或者先合并再格式化。</p></blockquote><h2 id="Python脚本格式化"><a href="#Python脚本格式化" class="headerlink" title="Python脚本格式化"></a>Python脚本格式化</h2><p>相较于使用Excel表格进行格式化操作，写脚本进行格式化更方便快捷。</p><p><strong><code>procast_ES_format.py</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>filesPath = <span class="hljs-string">r&quot;./procast导出应力数据/&quot;</span><br>nodeNum = <span class="hljs-number">24154</span><br>ESTable = pd.DataFrame(columns = [<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;Mpa&#x27;</span>], index = <span class="hljs-built_in">range</span>(nodeNum))<br><br><span class="hljs-keyword">for</span> fname <span class="hljs-keyword">in</span> os.listdir(filesPath):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filesPath + fname) <span class="hljs-keyword">as</span> f:<br>        content = f.read()<br>        data_txt = re.findall(<span class="hljs-string">r&#x27;[-+]?\d+(?:\.\d+(?:E[-+]?\d+)?)?&#x27;</span>, content)<br>        data_list = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">float</span>, data_txt))<br>        <span class="hljs-keyword">for</span> i, d <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_list):<br>            <span class="hljs-keyword">if</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">if</span> d % <span class="hljs-number">1</span> != <span class="hljs-number">0</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Invalid data in Node <span class="hljs-subst">&#123;<span class="hljs-built_in">int</span>(d)&#125;</span> !&quot;</span>)<br>                ESTable.iloc[<span class="hljs-built_in">int</span>(d) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>] = data_list[i + <span class="hljs-number">1</span>]<br>                ESTable.iloc[<span class="hljs-built_in">int</span>(d) - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>] = data_list[i + <span class="hljs-number">2</span>]<br>                ESTable.iloc[<span class="hljs-built_in">int</span>(d) - <span class="hljs-number">1</span>, <span class="hljs-number">2</span>] = data_list[i + <span class="hljs-number">3</span>]<br>                ESTable.iloc[<span class="hljs-built_in">int</span>(d) - <span class="hljs-number">1</span>, <span class="hljs-number">3</span>] = data_list[i + <span class="hljs-number">4</span>]<br>ESTable.to_csv(filesPath + <span class="hljs-string">&quot;ES_result.csv&quot;</span>)<br></code></pre></td></tr></table></figure><p>文件目录结构如下：</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221031184638793.png"></p><p>导出结果如下：</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221031184840198.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ProCAST使用心得</title>
    <link href="/2022/10/27/ProCAST%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/"/>
    <url>/2022/10/27/ProCAST%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="HyperMesh网格导入"><a href="#HyperMesh网格导入" class="headerlink" title="HyperMesh网格导入"></a>HyperMesh网格导入</h2><p>相较于Visual-Mesh，HyperMesh绘制网格更加方便实用。特别是复杂铸件模型，一般先在HyperMesh中将网格绘制好，然后导入procast中。参考操作步骤如下：</p><h3 id="1-HyperMes网格文件导出"><a href="#1-HyperMes网格文件导出" class="headerlink" title="1 HyperMes网格文件导出"></a>1 HyperMes网格文件导出</h3><p>首先将在HyperMesh中绘制好的面网格导出为<code>.out</code>文件。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221027122931308.png" alt="image-20221027122931308"></p><ul><li>File type选择<code>Custom</code>。</li><li>Template选择<code>..\feoutput\patran\general</code>。</li><li>File文件名后缀为<code>.out</code>。</li></ul><h3 id="2-out-gt-sm"><a href="#2-out-gt-sm" class="headerlink" title="2 .out-&gt;.sm"></a>2 .out-&gt;.sm</h3><p>导出的.out文件是无法直接导入Visual-Mesh的，需要先使用Visual-Cast打开然后保存为.sm格式才行。</p><h3 id="3-导入网格并装配"><a href="#3-导入网格并装配" class="headerlink" title="3 导入网格并装配"></a>3 导入网格并装配</h3><p>一般我们除了铸件网格，还会有冷铁、浇道等模型的网格，所以.sm网格文件不只一个。我们一般先在Visual-Mesh中打开铸件网格，然后通过Flie/Append的方式将其他.sm文件加进来。完成上述操作后，我们会发现在网格之间会出现重叠的情况，但是实际仿真中其实一层网格就够了。这时我们需要通过网格装配去除重叠的网格。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221027124239549.png" alt="image-20221027124239549"></p><p>点击<code>Check</code>，会将重叠的网格显示出来。没有问题后，点击<code>Assemble</code>完成装配。</p><h3 id="4-网格检查"><a href="#4-网格检查" class="headerlink" title="4 网格检查"></a>4 网格检查</h3><p>在装配完成后，可能会产生一些不合格的网格。这时我们需要进行网格检查。点击<code>Check Surface Mesh</code>完成检查和自动修复。直到控制台打印————–Surface mesh is OK————-就OK了。</p><h2 id="一些报错"><a href="#一些报错" class="headerlink" title="一些报错"></a>一些报错</h2><ul><li><p><code>Data Check</code>报错如下：</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221027231605383.png" alt="image-20221027231605383"></p><p>该错误不影响仿真计算，直接进行仿真即可。</p></li><li><p>正常运行到一定步数后控制台窗口报错，错误信息如下：</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221027231854182.png" alt="image-20221027231854182"></p><p>这种报错因素有很多，一般是参数设置不合理导致的。</p><p>对于上图报错，进入viewer找到最后一步的图像如下:</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221027232136203.png" alt="image-20221027232136203"></p><p>本例是叶片的熔模铸造定向凝固仿真，铸件和炉体在凝固过程中有一个相对位移。如图所示，在距离报错最近的一步中，铸件已经位移到炉体低温区最下缘，但铸件温度还未下降到预定温度（计算未停止），因此会出现找不到face的情况。</p><p><strong>解决方案</strong>：</p><ul><li>延长炉体低温区长度；</li><li>更改铸件材料参数；</li><li>提高计算截止温度;</li><li>降低位移速度。</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>procast2021学习笔记</title>
    <link href="/2022/10/26/procast2021%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/26/procast2021%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Visual-Mesh"><a href="#1-Visual-Mesh" class="headerlink" title="1 Visual-Mesh"></a>1 Visual-Mesh</h2><ul><li>首先通过File/Open和File/Append将CAD模型（IGS格式）加载进软件中。</li></ul><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025155719294.png" alt="image-20221025155719294" style="zoom:50%;" /><p>在软件左边有一个下图所示的树状管理视图：</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025155917282.png" alt="image-20221025155917282"></p><table><thead><tr><th>名称</th><th></th></tr></thead><tbody><tr><td>CAD</td><td>收集模型的点（Points）、线（Curves）、面（Surfaces）的信息</td></tr><tr><td>Parts</td><td>一个文件一个Part，数量为导入文件数量</td></tr><tr><td>Collectors</td><td>收集器，用于收集保存网格处理过程中的一些信息</td></tr><tr><td>Elements</td><td>网格，收集二维和三维网格</td></tr><tr><td>Regions</td><td>模型的区域</td></tr><tr><td>Calculation Zone</td><td>针对于晶粒模块，求解区域的定义</td></tr><tr><td>Volumes</td><td>模型中封闭的空间</td></tr><tr><td>Enclosure</td><td>扣箱（炉体），用于计算辐射换热</td></tr><tr><td>Interfaces HTC</td><td>界面换热系数</td></tr><tr><td>Process Conditions</td><td>边界条件</td></tr><tr><td>Simulation Parameters</td><td>仿真模拟参数</td></tr></tbody></table><ul><li><p>使用Repair<img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025161257088.png" alt="image-20221025161257088">工具，检查模型是否完好。点击Check后，若在最下方的信息提示栏中显示<code>No problems identified</code>则模型没有问题，可进行下一步操作。</p></li><li><p>使用Assembly<img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025161654346.png" alt="image-20221025161654346">工具装配，去除重复的面，避免之后画网格重复。点击Check通过蓝色线条显示出装配的面，确认无误后，点击<code>Assembly All</code>进行装配。如果有问题，可以通过<code>Next</code>，再点击旁边的<code>Assembly</code>进行分部分装配。</p></li><li><p>绘制铸件。通过几何工具中的平面创建工具<img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025162646478.png" alt="image-20221025162646478">，选择通过<code>Curves</code>进行创建。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025162900631.png" alt="image-20221025162900631"></p><p>创建两个平面后，会自动创建一个Volume，也就是铸件。可以看到管理树中Volumes数量变为3。</p><blockquote><p>Volume重命名方法：在管理树视图中左键选中Volumes，右键选择<code>Volume elementsize Manager</code>，双击name即可重新命名，同时也能更改网格尺寸等参数。</p></blockquote><blockquote><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025185723993.png" alt="image-20221025185723993"></p><p>在Volumes右键<code>Compute Volumes</code>重新计算体积，这里有两种计算方式：CAD（CAD模型）和FE（网格）。</p></blockquote></li><li><p>面网格划分。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025165337155.png" alt="image-20221025165337155"></p></li><li><p>面网格检查。使用Check Surface Mesh工具<img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025170020666.png" alt="image-20221025170020666">进行网格检查，点击Check。当控制台打印————–Surface mesh is OK————-信息时，表示网格合格。如果不合格，可以进行<code>Auto Correct</code>或者手动修改。</p></li><li><p>体网格生成。点击<img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025170313419.png" alt="image-20221025170313419">工具即可自动生成体网格。</p></li><li><p>网格导出。File/Export。</p><p>可导出ProCAST面网格.sm文件和ProCAST体网格.mesh文件。如果要继续进行procast仿真前处理，可直接另存为.vdb文件。</p></li></ul><h3 id="熔模精铸"><a href="#熔模精铸" class="headerlink" title="熔模精铸"></a>熔模精铸</h3><ul><li><p>模壳生成。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025190255912.png" alt="image-20221025190255912"></p></li></ul><h2 id="Visual-Cast"><a href="#Visual-Cast" class="headerlink" title="Visual-Cast"></a>Visual-Cast</h2><ul><li><p>重力方向设置。visual-cast2021版本是当模型导入时自动会弹出重力方向设置窗口。如果没有，去点击Cast工具栏中的第一个图标设置即可。<img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025191805175.png" alt="image-20221025191805175"></p></li><li><p>材料赋值。点击Cast工具栏中的第二个图标<code>Volume Manager</code>，此时，主要看Database能不能选择，且控制台有没有打印如下类似信息：</p><p><code>SQLITE_CANTOPEN[14]: unable to open database file D:\OneDrive\文档\VE\17_\VisualCast\companydata.mtxdb</code>，这里原因是检测如下位置</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025193655545.png" alt="image-20221025193655545"></p><p>查看是否勾选了某个路径下不存在的数据库，图中USER数据库所指定的路径是错误的，故会报错，这里取消勾选，采用PUBLIC数据库。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025194210263.png" alt="image-20221025194210263"></p><p>要点如下：</p><ul><li>Type中模型一般选择<code>Mold</code>，铸件选择<code>Alloy</code>。</li><li>材料模型选用树脂砂，铸件选择合金。</li><li>Fill表示初始状态，一般铸型是实体，为100%，铸件开始时是型腔，故为0%。</li><li>Initial Temp初始温度，按照实际赋值。</li><li>Stress Type应力类型，和应力计算有关。一般砂子选用线弹性模型，铸件选用弹塑性模型。</li></ul></li><li><p>换热系数设置。Cast工具栏第三图标（或者右键编辑管理树视图中的Interfaces HTC）。其中相同的部分，如die1和die2的类型选择<code>EQUIV</code>，其他选择<code>COINC</code>。注意需要将Name中铸件和铸型的先后顺序改为<code>铸件_铸型</code>。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025195317975.png" alt="image-20221025195317975"></p><p>换热系数一列中，因为示例是砂子和金属，选择<code>h=500</code>（300~1000）。冷铁和铸件换热系数<code>h=2000</code>（1000~5000），高压铸造选择3000~3500。</p></li><li><p>仿真运行条件设置。</p><p>首先是边界换热<code>Heat Exchange</code>，右键选择新建，选择区域。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025200411224.png" alt="image-20221025200411224"></p><p>按照上图步骤，选中名称为<code>EXT_*</code>的区域（外表面），点击OK之后在点击Region旁边的绿色小箭头即可完成<code>Entity</code>的添加。Boundary Cond.根据示例情况选择空冷。</p></li><li><p>浇铸条件。新建Inlet，选择浇铸金属面截面。因为在Region中无法直接找出，使用铅笔图标手动进行选择。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025201320291.png" alt="image-20221025201320291"></p><p>选择完成后点击Apply。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025202325624.png" alt="image-20221025202325624"></p><p>使用计算器，计算出BC并创建到边界条件一栏中。这里有个坑，因为user数据库会默认放到模型同目录下，路径包含中文可能会报错，导致创建的BC不能写入到用户数据库中，无法保存并应用。因此同样需要把该用户数据库文件路径改了才行。</p></li><li><p>添加Displacement约束。如果需要应力计算，应当设置约束。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221025205713213.png" alt="image-20221025205713213"></p><p>选择模型的两个侧面，BC选择PUBLIC数据库中的Displacement_Z0，表示Z轴方向约束。</p></li><li><p> 模拟参数设置。点击Cast工具栏第五个图标<code>Simulation Parameters</code>（或者在管理树中右键编辑）。首先选择预定义参数为重力充型。</p></li></ul><p>  <img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221026000841725.png" alt="image-20221026000841725"></p><p>  这部分参数的具体解释可以参见：<a href="https://blog.csdn.net/qq_39784672/article/details/127494041?spm=1001.2014.3001.5501">【ProCAST】铸件定向凝固仿真流程学习总结</a></p><p>  如果需要进行应力计算，需要添加Stress菜单，并将其激活。</p><ul><li><p>数据检查。点击<code>Data Check</code>，没有错误后即可进行下一步操作。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221026002334027.png" alt="image-20221026002334027"></p></li><li><p>开始仿真模拟。点击<code>Start Simulation</code>选择求解器后进行计算。</p><blockquote><p>虽然procast软件保存路径能包含中文，但好像其他路径包含中文都会出错。。这里建议把工作路径也就是文件的路径改到不包含中文的路径下。</p></blockquote></li></ul><h2 id="Visual-Viewer"><a href="#Visual-Viewer" class="headerlink" title="Visual-Viewer"></a>Visual-Viewer</h2><p>在虚拟环境中将应用切换为viewer，即可对仿真结果进行后处理工作。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221026134959050.png" alt="image-20221026134959050"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>路径问题</p><blockquote><p>建议所有路径中都不要包含中文，避免不必要的报错。</p></blockquote></li><li><p>应力计算Stress未实现</p><blockquote><p>按照B站教程，在模拟参数设置时，如果将应力计算激活，仿真过程总会报错中断。最后只能将其关掉，才算仿真成功。目前这个问题还未解决。</p></blockquote></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1Lf4y1m7tn">https://www.bilibili.com/video/BV1Lf4y1m7tn</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora+PicGo+Gitee+坚果云搭建云笔记教程</title>
    <link href="/2022/10/24/Typora+PicGo+Gitee+%E5%9D%9A%E6%9E%9C%E4%BA%91%E6%90%AD%E5%BB%BA%E4%BA%91%E7%AC%94%E8%AE%B0%E6%95%99%E7%A8%8B/"/>
    <url>/2022/10/24/Typora+PicGo+Gitee+%E5%9D%9A%E6%9E%9C%E4%BA%91%E6%90%AD%E5%BB%BA%E4%BA%91%E7%AC%94%E8%AE%B0%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前用过一段时间Typora+PicGo+SM.MS，但后来某一天发现图片上传不了了，一查原来是SM图床挂掉了，也就没再去捣鼓了。最近，发多图博客又觉得不用图床的话，Typora在本地写的文章直接导入CSDN会出现图片失效的问题，需要一张张重新上传才行。于是，又重新来搭一搭图床吧，顺便把文章也同步到坚果云上去，这篇文章也就有了。</p></blockquote><h2 id="1-Typora下载和安装"><a href="#1-Typora下载和安装" class="headerlink" title="1 Typora下载和安装"></a>1 Typora下载和安装</h2><p>下载地址：<a href="https://typora.io/releases/all">https://typora.io/</a>，下载后无脑安装就行。</p><blockquote><p>目前新版Typora试用期到后需要收费了，嫌贵可以去找Typora快乐版。</p></blockquote><h2 id="2-PicGo下载和安装"><a href="#2-PicGo下载和安装" class="headerlink" title="2 PicGo下载和安装"></a>2 PicGo下载和安装</h2><p>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases/download/v2.3.0/PicGo-Setup-2.3.0-x64.exe">PicGo-Setup-2.3.0-x64.exe</a></p><h2 id="3-Node-js下载和安装"><a href="#3-Node-js下载和安装" class="headerlink" title="3 Node.js下载和安装"></a>3 Node.js下载和安装</h2><p>PicGo的插件依赖于node.js环境，而在PicGo中使用Gitee图床需要安装相应的插件（没有自带的Gitee图床接口）。</p><p>下载地址：<a href="http://nodejs.cn/download/current/">下载 | Node.js 中文网</a></p><h2 id="4-坚果云下载与安装"><a href="#4-坚果云下载与安装" class="headerlink" title="4 坚果云下载与安装"></a>4 坚果云下载与安装</h2><p>下载地址：<a href="https://www.jianguoyun.com/s/downloads">坚果云网盘下载|云盘下载|免费网盘云盘试用 (jianguoyun.com)</a></p><h2 id="5-Gitee配置"><a href="#5-Gitee配置" class="headerlink" title="5 Gitee配置"></a>5 Gitee配置</h2><h3 id="5-1-新建仓库"><a href="#5-1-新建仓库" class="headerlink" title="5.1 新建仓库"></a>5.1 新建仓库</h3><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221024175105317.png" alt="image-20221024175105317"></p><p>创建完成后，需进入在仓库设置中将其设置为开源。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221024175250651.png" alt="image-20221024175250651"></p><h3 id="5-2-生成私人令牌"><a href="#5-2-生成私人令牌" class="headerlink" title="5.2 生成私人令牌"></a>5.2 生成私人令牌</h3><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221024175413452.png" alt="image-20221024175413452"></p><p>记住并保存生成的令牌，后面需要在PicGo配置中用到。</p><h2 id="6-PicGo配置"><a href="#6-PicGo配置" class="headerlink" title="6 PicGo配置"></a>6 PicGo配置</h2><h3 id="6-1-安装github-plus插件"><a href="#6-1-安装github-plus插件" class="headerlink" title="6.1 安装github-plus插件"></a>6.1 安装github-plus插件</h3><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221024175642031.png" alt="image-20221024175642031"></p><p>至于为什么不安装gitee插件，因为笔者第一次安装gitee插件并配置完成后，发现无法上传图片。检查日志文件<code>C:\Users\用户名\AppData\Roaming\picgo\picgo.log</code>，打印信息如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-number">2022</span><span class="hljs-operator">-</span><span class="hljs-number">10</span><span class="hljs-operator">-</span><span class="hljs-number">24</span> <span class="hljs-number">15</span>:<span class="hljs-number">10</span>:<span class="hljs-number">24</span> [<span class="hljs-type">PicGo</span> <span class="hljs-type">INFO</span>] <span class="hljs-type">Uploading</span>... <span class="hljs-type">Current</span> uploader <span class="hljs-keyword">is</span> [gitee] <br><span class="hljs-number">2022</span><span class="hljs-operator">-</span><span class="hljs-number">10</span><span class="hljs-operator">-</span><span class="hljs-number">24</span> <span class="hljs-number">15</span>:<span class="hljs-number">10</span>:<span class="hljs-number">25</span> [<span class="hljs-type">PicGo</span> <span class="hljs-type">INFO</span>] [上传操作]异常：<span class="hljs-number">403</span> <span class="hljs-operator">-</span> <span class="hljs-string">&quot;&lt;html&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&lt;body&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&lt;/body&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&lt;/html&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span> <br><span class="hljs-number">2022</span><span class="hljs-operator">-</span><span class="hljs-number">10</span><span class="hljs-operator">-</span><span class="hljs-number">24</span> <span class="hljs-number">15</span>:<span class="hljs-number">10</span>:<span class="hljs-number">25</span> [<span class="hljs-type">PicGo</span> <span class="hljs-type">INFO</span>] [上传操作]异常：<span class="hljs-number">403</span> <span class="hljs-operator">-</span> <span class="hljs-string">&quot;&lt;html&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&lt;body&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&lt;/body&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&lt;/html&gt;<span class="hljs-subst">\r</span><span class="hljs-subst">\n</span>&quot;</span> <br><span class="hljs-number">2022</span><span class="hljs-operator">-</span><span class="hljs-number">10</span><span class="hljs-operator">-</span><span class="hljs-number">24</span> <span class="hljs-number">15</span>:<span class="hljs-number">10</span>:<span class="hljs-number">25</span> [<span class="hljs-type">PicGo</span> <span class="hljs-type">SUCCESS</span>] <br></code></pre></td></tr></table></figure><p>关键词<code>403 Forbidden</code>，上网一搜，发现原来是 gitee 封禁了 PicGo 的上传服务，导致 PicGo 无法上传，并且原有的外链图片均无法访问。通过这篇博客</p><p><a href="https://blog.csdn.net/qq_32355021/article/details/124143547?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-124143547-blog-123754008.pc_relevant_aa_2&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-124143547-blog-123754008.pc_relevant_aa_2&utm_relevant_index=1">【Gitee+PicGo上传图片报错403 Forbidden】_拽拽就是我的博客-CSDN博客_picgo上传gitee图片失败</a>，我该用了github-plus插件，最终成功上传gitee图床，在此感谢博主！</p><h3 id="6-2-配置Gitee图床"><a href="#6-2-配置Gitee图床" class="headerlink" title="6.2 配置Gitee图床"></a>6.2 配置Gitee图床</h3><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221024180921394.png" alt="image-20221024180921394"></p><p>第一个repo其实就是Gitee仓库url链接去除前面<code>https://gitee.com/</code>后的剩余部分。</p><p>配置完成点击确定，然后点击设为默认图床。</p><h2 id="7-Typora配置"><a href="#7-Typora配置" class="headerlink" title="7 Typora配置"></a>7 Typora配置</h2><p>typora-&gt;文件-&gt;偏好设置-&gt;图像。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221024181258968.png" alt="image-20221024181258968"></p><p>配置完成后，验证图片上传选项，验证成功即可。</p><p>到此为止，通过本地写好文章并上传图片后，在CSDN中即可直接导入md文件，图片大部分都能显示出来，对于一些失效的外链进行url上传即可。</p><h2 id="8-坚果云配置"><a href="#8-坚果云配置" class="headerlink" title="8 坚果云配置"></a>8 坚果云配置</h2><p>如果要上传坚果云的话，只需在坚果云中新建同步文件夹，同步到本地即可。</p><blockquote><p>如果同步到本地的文件夹路径中包含中文貌似会同步失败，建议路径最好不要包含中文。</p></blockquote><p>至此，云笔记环境搭建完成，Enjoy yourself~</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ProCAST铸件定向凝固仿真流程学习总结</title>
    <link href="/2022/10/24/ProCAST%E9%93%B8%E4%BB%B6%E5%AE%9A%E5%90%91%E5%87%9D%E5%9B%BA%E4%BB%BF%E7%9C%9F%E6%B5%81%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2022/10/24/ProCAST%E9%93%B8%E4%BB%B6%E5%AE%9A%E5%90%91%E5%87%9D%E5%9B%BA%E4%BB%BF%E7%9C%9F%E6%B5%81%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Visual-Mesh"><a href="#Visual-Mesh" class="headerlink" title="Visual-Mesh"></a>Visual-Mesh</h2><ul><li>显示模式</li></ul><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221021161647982.png" alt="image-20221021161647982"></p><ul><li><p>快捷键</p><ul><li>shift+左键：取消选择</li><li>ctrl+A：选择所有</li><li>ctrl+D：放弃选择所有</li><li>选中+H：隐藏</li><li>选中+L：定位</li><li>F：显示适应全屏</li><li>ctrl+U：删除列表（回收站）</li></ul></li><li><p>文件导出</p><p>File-&gt;Export-&gt;.sm</p><blockquote><p>导出路径可以包含中文。</p></blockquote></li><li><p>设置单位</p><p>Tool-&gt;Change/Convert Length Units</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221021172305017.png" alt="image-20221021172305017"></p></li><li><p>检查面网格</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221021172605993.png" alt="image-20221021172605993"></p></li></ul><p>​    <img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221021173236712.png" alt="image-20221021173236712" style="zoom:50%;" /></p><p>​    检查的参数进行调整，或者点击自动修正。直到控制台输出</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck">--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">Surface</span> <span class="hljs-comment">mesh</span> <span class="hljs-comment">is</span> <span class="hljs-comment">OK</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><br></code></pre></td></tr></table></figure><blockquote><p>其其中<code>Intersection :    No problems found</code>，无自相交的网格存在。</p></blockquote><ul><li><p>网格模型装配</p><p>File-&gt;Append</p><blockquote><p>注意模型的坐标系和单位必须统一才能正确装配。</p></blockquote><p>Cast-&gt;Detect and merge overlaps between volumes，进行装配。</p><blockquote><p>装配的目的在于：导入两个网格模型后，再其接触的面上会有网格重复的现象，但是实际铸造仿真过程中，其实一层网格就能将两个模型分开，故需要进行装配处理。</p></blockquote></li></ul><h2 id="MeshCAST"><a href="#MeshCAST" class="headerlink" title="MeshCAST"></a>MeshCAST</h2><ul><li><p>模型装配</p><p>File-&gt;Assemble</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221022150256713.png" alt="image-20221022150256713"></p><p>点击<code>Show Features</code>以红色显示重叠的边界，对于简单的边界，我们直接点击<code>Continue Assembly</code>进行装配。</p></li><li><p>网格和交错面检查</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221022150738662.png" alt="image-20221022150738662"></p><p>消息窗口打印如下内容时，表示网格合格。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">The</span> Surface mesh seems OK.<br><span class="hljs-attribute">Number</span> of edges (in the model) present in more than <span class="hljs-number">2</span> Triangles are: <span class="hljs-number">39</span><br><span class="hljs-attribute">Total</span> # of possible intersections are: <span class="hljs-number">0</span>.<br></code></pre></td></tr></table></figure></li><li><p>模壳生成</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221022151333937.png" alt="image-20221022151333937"></p><p>一般熔模铸造都是成组进行，故在做仿真分析的时候，我们只需对单个或一部分零件有限元仿真和分析。因此建模中我们只建一部分模型，在生成模壳时有些面是不生成的。因此在生成模壳之前需要先提取无模壳面（no shell faces）和对称面（symmetry faces）。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221022151409741.png" alt="image-20221022151409741"></p><p>在这里，我们将使用上图的单元选择工具进行select，从左到右依次是：选择一个单元，选择全部单元，取消一个单元的选择，取消所有单元的选择，选择一个表面。需要注意的是，第一个图标激活状态下（被点击后），首先在要选择的单元上将光标停留，然后鼠标左键被按下的状态将光标进行拖动后才会被选中（选中后颜色变红）。同时使用第五个面选操作的前提需要使用单选操作，保证至少有一个单元被选中，然后在下面的输入窗口输入一个angle参数（0-20）后，再点击面选才会选中单元所在的surface。</p><blockquote><p>在输入窗口输入angle值后不能习惯性的点回车，否则软件无法读取参数。然后，当选完一个面后需要选下一个面时，我们会习惯性得使用鼠标左键拖动旋转模型窗口，这时切记要关闭单元选择图标！！！非常的银杏啊！</p><p>单选时，网格数量多的话会很卡，需要等好一会儿才能选中。</p></blockquote><p>选完后点击Store就行。</p><p>然后设置模壳厚度，点击<code>Gen. shell</code>按钮就可生成模壳。</p></li><li><p>体网格生成</p><p>对模壳网格质量和自相交进行检查，若有问题可以点击<code>Fix Bad Triangles</code>进行修复，直到网格合格。在Tet菜单下单击Generate Tet Mesh按钮，即可生成体网格。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221022155328301.png" alt="image-20221022155328301"></p></li></ul><blockquote><p>一般体网格生成只要超过50%就意味着该网格可用。</p></blockquote><h2 id="PreCAST"><a href="#PreCAST" class="headerlink" title="PreCAST"></a>PreCAST</h2><ul><li><p>通过File-&gt;Multiple Meshe载入铸造炉体与装配体的体网格。</p><blockquote><p>载入后可能只能看到.mesh格式的体网格，.sm格式的炉体网格看不见。可以通过点击如下图标进行显示。<img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221022202526318.png" alt="image-20221022202526318"></p></blockquote></li></ul><h3 id="Geometry"><a href="#Geometry" class="headerlink" title="Geometry/"></a>Geometry/</h3><ul><li><p>设置对称面</p><p>Geometry/Symmetry，设置对称面。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221022204648657.png" alt="image-20221022204648657"></p><p>此处为镜像对称，且为两个面，每个对称平面都应该由三个点的坐标定义（不共线）。故勾选<code>Mirror-1</code>和<code>Mirror-2</code>（如要禁用，取消勾选），注意此处应保证这两个平面正交。<code>Get Co-ord</code>按钮允许拾取网格的节点（Node），以交互定义镜像平面。要使用它，首先单击即将选择点的X坐标框（出现闪烁的编辑光标即可），然后单击<code>Get Co-ord</code>，最后单击几何体上对应的节点。相应的坐标将自动填充。</p><p>最后点击<code>Apply</code>验证完成对称面定义。</p><blockquote><p>选择镜像面构造点时应该落在节点上，否则会报错！</p></blockquote></li><li><p>检查网格雅克比</p><p>Geometry/Check Geom/Neg-Jac，检查网格的雅可比以确定几何体上是否存在负的雅克比网格。如下结果显示为无。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221022205852855.png" alt="image-20221022205852855"></p></li></ul><h3 id="Materials"><a href="#Materials" class="headerlink" title="Materials/"></a>Materials/</h3><ul><li><p>材料分配</p><p>Materials/Assign，分配各部分的材料。</p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221023101733160.png" alt="image-20221023101733160" style="zoom:50%;" /><p>当用到某种未在当前数据库中的材料时，需要自行配制添加。点击<code>Add</code>。</p><p>上图中的<code>Type</code>也需要指定，铸件部分选择<code>CASTING</code>。</p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221023102026880.png" alt="image-20221023102026880" style="zoom:50%;" /><p>输入组成材料的基和各元素及其百分比，点击<code>Apply</code>选择不同的应力特性计算方式后，可得到材料的相关特性曲线，满足要求后，点击<code>Store</code>进行添加，之后便能在材料列表中选择自定义的材料了。</p></li><li><p>力学性能设置</p><p>Materials/Stress，设置各部分材料的力学性能。</p><p>设置过程和材料设置类似。</p></li><li><p>设置界面相关参数</p><p>Interface，指定界面类型和换热系数。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221023103539236.png" alt="image-20221023103539236"></p><blockquote><p>每当Type设置完成后，<code>Apply</code>按键会变色，需点击。</p></blockquote></li><li><p>设置边界条件</p><p>Boundary conditions/Assign Surface，设置表面边界条件。</p><p>依次设置如下四种类型的参数：</p><table><thead><tr><th>名称</th><th>解释</th><th>设置方式</th></tr></thead><tbody><tr><td>Heat</td><td>模壳与外界的热交换</td><td>Heat设定时需要选择整个模壳，选择方法可通过<img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221023155106859.png" alt="image-20221023155106859" style="zoom: 50%;" />这个菜单栏的按键隐藏其他的材料，只保留模壳，在单击选择全部。然后在参数库中选择刚刚设定的交换系数。</td></tr><tr><td>Symmetry</td><td>对称面(仿真模型不完整时设定)</td><td>Symmetry设定只需要选择整个对称面保存，不用设定参数。</td></tr><tr><td>Temperature</td><td>冷铜的温度(一般取20)</td><td>Temperature选择整个冷铜所有面，然后设定为一常数值。</td></tr><tr><td>Displacement</td><td>各组件的相对位置约束(设置4个)</td><td>Displacement设定需要设定三个定位，分别是模壳底部，铸件与冷铜接触部分，冷铜底部。在参数库中选定设置好的约束。</td></tr></tbody></table><p>Boundary conditions/Assign Enclosure，设置炉体的辐射及温度。需要设置三部分（高温区、中温区、低温区）的辐射方向和辐射温度。</p><p>依次设置如下两种类型的参数：</p><table><thead><tr><th>名称</th><th>设置方式</th></tr></thead><tbody><tr><td>辐射的方向</td><td>通过面选区域，设置所选网格法向方向向里。</td></tr><tr><td>辐射区域的初始温度</td><td>高温区辐射系数0.9，温度1550℃；中温区辐射系数0.6，温度900℃；低温区辐射系数0.5，温度20℃。</td></tr></tbody></table><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221023163812967.png" alt="image-20221023163812967" style="zoom:50%;" /><blockquote><p>第一次设置时，如果温度和辐射系数不在数据库时，需点击<code>Add</code>进行手动添加。</p><p>注意，enclosure set会根据导入的炉体网格文件个数自动生成。这里因为笔者导入的炉体网格文件只有一个（也可以将三个部分以三个网格文件的形式导入），会自动有一个Set#1在表中，且其Area为炉体所有网格，并且无法删除和更改。但是只要继续添加Set，并选择部分网格后，Set#1的Area则会变小（减去其他Set的面积），当重新划分完Set后，其Area将变为0，此时，便可以将其Del。</p></blockquote></li><li><p>设置过程（Process）参数</p><p>Process/Assign Enclosure，设置炉体移动速度。</p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221023165854561.png" alt="image-20221023165854561" style="zoom:50%;" /><p>Process/Gravity，设置重力加速度。</p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221023170036086.png" alt="image-20221023170036086" style="zoom:50%;" /><blockquote><p>这里的炉体移动速度矢量和重力加速度方向都是Z轴方向，且二者方向相反。这里由于炉体的+Z轴方向朝下，故重力加速度为正，炉体的速度为负。</p></blockquote></li><li><p>设置初始条件的设定（Initial conditions）</p><p>Initial conditions/Constant，设定三种材料的初始温度。注意与前面设置的保持一致。</p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221023170626611.png" alt="image-20221023170626611" style="zoom:50%;" /></li><li><p>设定运行参数（Run Parametres）</p><p>Run Parametres，在叶片的定向凝固仿真中，只需设定下面表格中菜单名称加粗中的参数。</p><table><thead><tr><th>菜单名称</th><th>作用</th></tr></thead><tbody><tr><td><strong>General</strong></td><td>主要用于设定运算停止的条件</td></tr><tr><td><strong>Thermal</strong></td><td>计算温度场(一般只需要将其激活)</td></tr><tr><td>Cycles</td><td>热平衡计算</td></tr><tr><td>Radiation</td><td>辐射运行参数</td></tr><tr><td>Flow</td><td>流动运行参数</td></tr><tr><td>Turbulence</td><td>紊流运行参数</td></tr><tr><td><strong>Stress</strong></td><td>应力运行参数(将其激活。0关闭，1开启)</td></tr><tr><td>Micro</td><td>微观组织模拟运行参数</td></tr></tbody></table><p><strong>General菜单</strong></p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221023172630756.png" alt="image-20221023172630756"></p><p>这里我们最大步数设置20000，最低温度设置500，结束时间设为0，其余保持默认值。</p><p><strong>Thermal菜单</strong></p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221023173235604.png" alt="image-20221023173235604"></p><p>这里我们将第一个参数设为1，激活传热分析，主变量为温度，其余保持默认值。</p><p><strong>Radiation菜单</strong></p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221023173952623.png" alt="image-20221023173952623"></p><p><strong>Flow菜单</strong></p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221023174132309.png" alt="image-20221023174132309"></p><p><strong>Stress菜单</strong></p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221023174553099.png" alt="image-20221023174553099"></p></li></ul><h2 id="ProCAST"><a href="#ProCAST" class="headerlink" title="ProCAST"></a>ProCAST</h2><p>使用PreCAST完成仿真参数设定后，保存退出，点击ProCAST，勾选<code>Execute DataCAST first</code>，点击<code>Run</code>进行仿真计算。</p><p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20221023175947409.png" alt="image-20221023175947409"></p><p>使用<code>Status</code>可查看仿真进度。</p><h2 id="Visual-Viewer"><a href="#Visual-Viewer" class="headerlink" title="Visual-Viewer"></a>Visual-Viewer</h2><p>仿真后处理。主要查看温度场，应力场，位移场等。用于仿真分析和总结。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在做定向凝固仿真时，一般需要先在CAD软件（UG）中建好铸件模型（IGS），然后进行网格划分（可以使用hypermesh进行划分导出.out格式，也可以直接在Visual-Mesh中进行划分），划分完成后进行模型装配，模壳生成，体网格生成。然后进行仿真参数设定，最后进行<code>Data Check</code>，无误后，进行仿真。仿真完成后，可以在Visual-Viewer中进行一系列的后处理分析。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2021/10/29/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2021/10/29/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="西洲曲"><a href="#西洲曲" class="headerlink" title="西洲曲"></a>西洲曲</h3><h6 id="【作者】佚名-【朝代】南北朝"><a href="#【作者】佚名-【朝代】南北朝" class="headerlink" title="【作者】佚名 【朝代】南北朝"></a>【作者】佚名 【朝代】南北朝</h6><p>忆梅下西洲，折梅寄江北。</p><p>单衫杏子红，双鬓鸦雏色。</p><p>西洲在何处？两桨桥头渡。</p><p>日暮伯劳飞，风吹乌臼树。</p><p>树下即门前，门中露翠钿。</p><p>开门郎不至，出门采红莲。</p><p>采莲南塘秋，莲花过人头。</p><p>低头弄莲子，莲子清如水。</p><p>置莲怀袖中，莲心彻底红。</p><p>忆郎郎不至，仰首望飞鸿。</p><p>鸿飞满西洲，望郎上青楼。</p><p>楼高望不见，尽日栏杆头。</p><p>栏杆十二曲，垂手明如玉。</p><p>卷帘天自高，海水摇空绿。</p><p>海水梦悠悠，君愁我亦愁。</p><p>南风知我意，吹梦到西洲。</p>]]></content>
    
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
