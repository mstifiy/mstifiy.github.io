

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="MSTIFIY">
  <meta name="keywords" content="">
  <meta name="referrer" content="no-referrer" />
  <meta name="description" content="[TOC] 1 $\text{Voronoi}$图 在理解Delaunay三角剖分之前，先引入$\text{Voronoi}$图。  1.1 定义与性质定义 设由任意$n$个互异平面点（也称基点）组成的点集$P&#x3D;{p_i|i&#x3D;1,…,n}$。$P$对应的$\text{Voronoi}$图可以理解为对平面的一个区域（单元）划分。对于划分得到的每个区域（也称$\text{Voronoi}$多边形），都">
<meta property="og:type" content="article">
<meta property="og:title" content="Delaunay三角剖分">
<meta property="og:url" content="http://example.com/2023/06/06/Delaunay%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/index.html">
<meta property="og:site_name" content="MSTIFIY&#39;S BLOG">
<meta property="og:description" content="[TOC] 1 $\text{Voronoi}$图 在理解Delaunay三角剖分之前，先引入$\text{Voronoi}$图。  1.1 定义与性质定义 设由任意$n$个互异平面点（也称基点）组成的点集$P&#x3D;{p_i|i&#x3D;1,…,n}$。$P$对应的$\text{Voronoi}$图可以理解为对平面的一个区域（单元）划分。对于划分得到的每个区域（也称$\text{Voronoi}$多边形），都">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230522154118839.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230523011544467.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230524001225163.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525011734005.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/5.GIF">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525133130002.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525135633264.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525140915264.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525141540743.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142157546.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142614560.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142914270.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525143023480.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160836087924338.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160838043703195.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525231438652.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160718101043903.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525232322324.png">
<meta property="og:image" content="c:/Users/MSTIFIY/AppData/Roaming/Typora/typora-user-images/image-20230527102334838.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205450735.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205916411.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205904484.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230529004839957.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/edge.jpeg">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230606140652092.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/GIF%202023-6-6%2014-11-07.gif">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230522154118839.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230523011544467.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230524001225163.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525011734005.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/5.GIF">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525133130002.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525135633264.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525140915264.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525141540743.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142157546.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142614560.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142914270.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525143023480.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160836087924338.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160838043703195.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525231438652.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160718101043903.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525232322324.png">
<meta property="og:image" content="c:/Users/MSTIFIY/AppData/Roaming/Typora/typora-user-images/image-20230527102334838.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205450735.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205916411.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205904484.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230529004839957.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/edge.jpeg">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230606140652092.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/GIF%202023-6-6%2014-11-07.gif">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230522154118839.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230523011544467.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230524001225163.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525011734005.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/5.GIF">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525133130002.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525135633264.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525140915264.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525141540743.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142157546.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142614560.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142914270.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525143023480.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160836087924338.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160838043703195.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525231438652.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160718101043903.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525232322324.png">
<meta property="og:image" content="c:/Users/MSTIFIY/AppData/Roaming/Typora/typora-user-images/image-20230527102334838.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205450735.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205916411.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205904484.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230529004839957.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/edge.jpeg">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230606140652092.png">
<meta property="og:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/GIF%202023-6-6%2014-11-07.gif">
<meta property="article:published_time" content="2023-06-06T06:36:39.000Z">
<meta property="article:modified_time" content="2023-08-18T02:30:53.672Z">
<meta property="article:author" content="MSTIFIY">
<meta property="article:tag" content="学习记录">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230522154118839.png">
  
  <title>Delaunay三角剖分 - MSTIFIY&#39;S BLOG</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>MSTIFIY</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Delaunay三角剖分">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-06-06 14:36" pubdate>
        2023年6月6日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      71k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      221 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Delaunay三角剖分</h1>
            
            <div class="markdown-body">
              <p>[TOC]</p>
<h2 id="1-text-Voronoi-图"><a href="#1-text-Voronoi-图" class="headerlink" title="1 $\text{Voronoi}$图"></a>1 $\text{Voronoi}$图</h2><blockquote>
<p>在理解Delaunay三角剖分之前，先引入$\text{Voronoi}$图。</p>
</blockquote>
<h3 id="1-1-定义与性质"><a href="#1-1-定义与性质" class="headerlink" title="1.1 定义与性质"></a>1.1 定义与性质</h3><p><strong>定义</strong></p>
<p>设由任意$n$个互异平面点（也称基点）组成的点集$P={p_i|i=1,…,n}$。$P$对应的$\text{Voronoi}$图可以理解为对平面的一个区域（单元）划分。对于划分得到的每个区域（也称$\text{Voronoi}$多边形），都应当满足：在基点$p_i$对应的单元中任取一点，该点到$p_i$的（欧式）距离一定小于到$p_j，p_j\in{P},j\ne{i}$的（欧式）距离。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230522154118839.png" srcset="/img/loading.gif" lazyload alt="image-20230522154118839"></p>
<blockquote>
<p>$\text{Voronoi}$又称泰森多边形或$\text{Dirichlet}$图。</p>
<p>平面上的 V-图可以看作是数据点集合 P 中的每个点作为生长点，以相同的速率向 外扩散，直到彼此相遇为止在平面上所形成的图形。除最外层的点形成开放的区域外， 其余的每个点都形成一个凸多边形。</p>
</blockquote>
<p><strong>一些性质</strong></p>
<ul>
<li>每个$\text{Voronoi}$多边形内仅包含一个基点；</li>
<li>$\text{Voronoi}$多边形内的任一点到相应基点的（欧式）距离最近；</li>
<li>位于$\text{Voronoi}$多边形边上的点到其两边的离散点的距离相等；</li>
<li>$n$个点的集合$P$的$\text{Voronoi}$图最多有$2n-5$个顶点和$3n-6$条边；</li>
<li>假如任意四个基点都不共圆，则每个$\text{Voronoi}$顶点恰好是三条$\text{Voronoi}$边的交点，即由$P$中的三点所形成三角形外接圆的圆心。</li>
</ul>
<blockquote>
<p>参考：</p>
<p>[1] 高莉. 改进的Delaunay三角剖分算法研究[D]. 兰州交通大学, 2015.</p>
<p>[2] <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B3%B0%E6%A3%AE%E5%A4%9A%E8%BE%B9%E5%BD%A2?fr=aladdin">泰森多边形_百度百科 (baidu.com)</a></p>
</blockquote>
<h2 id="2-三角剖分"><a href="#2-三角剖分" class="headerlink" title="2 三角剖分"></a>2 三角剖分</h2><h3 id="2-1-定义与性质"><a href="#2-1-定义与性质" class="headerlink" title="2.1 定义与性质"></a>2.1 定义与性质</h3><p>设由任意$n$个平面点组成的点集$P={p_i|i=1,…,n}$。三角剖分是指用<strong>互不相交</strong>的直线段连接$P_i$与$P_j$，$1≤i，j≤n，i≠j$，并且使其凸包中的每个划分区域都是一个三角形。</p>
<p>由于三角剖分是一个平面图，故满足以下几个条件：</p>
<ul>
<li>图中不存在相交的边（除线段端点外，不存在重叠的边）；</li>
<li>图中的边不包含集合$P$中的其他任何点，端点除外；</li>
<li>图中所有的面片都是三角形，并且所有三角形的集合构成$P$的凸包。</li>
</ul>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230523011544467.png" srcset="/img/loading.gif" lazyload alt="image-20230523011544467"></p>
<h3 id="2-2-质量-quality-评定标准"><a href="#2-2-质量-quality-评定标准" class="headerlink" title="2.2 质量(quality)评定标准"></a>2.2 质量(quality)评定标准</h3><p>由于对给定点集的三角剖分不唯一，对于不同的三角剖分我们有如下质量评定标准：</p>
<table>
<thead>
<tr>
<th>质量评定标准</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>最小角(minimum angle)</td>
<td>所有三角形的内角当中最小的角</td>
</tr>
<tr>
<td>纵横比(aspect ratio)</td>
<td>三角形最短边与最长边的比例</td>
</tr>
<tr>
<td>半径比(radius ratio)</td>
<td>三角形内接圆半径的两倍与外接圆半径的比例</td>
</tr>
</tbody></table>
<blockquote>
<p>参考：</p>
<p>[1] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/459884570">技术分享：Delaunay三角剖分算法介绍 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h2 id="3-Delaunay三角剖分"><a href="#3-Delaunay三角剖分" class="headerlink" title="3 Delaunay三角剖分"></a>3 Delaunay三角剖分</h2><blockquote>
<p>Delaunay剖分是一种三角剖分的标准。</p>
</blockquote>
<h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p><strong>Delaunay边</strong>：假设$E$（$E$为点集的三角剖分的边集）中的一条边$e$（两个端点分别为$a,b$），$e$为Delaunay边的条件为：存在一个圆经过$a,b$两点，圆内(最多三点共圆)不含点集$P$中任何其他的点，这一特性又称<strong>空圆特性</strong>。</p>
<p><strong>Delaunay三角剖分</strong>：如果点集$P$的一个三角剖分$T$只包含Delaunay边，那么该三角剖分称为Delaunay三角剖分。</p>
<p><strong>Delaunay三角剖分的另一种定义</strong>：因为Delaunay三角剖分与$\text{Voronoi}$图是对偶关系，Delaunay三角剖分是$\text{Voronoi}$图的伴生图形，两者可以相互转化。作$\text{Voronoi}$图的对偶图，即对每条$\text{Voronoi}$边(限有限长线段)作通过点集中某两点的中垂线，得到的即为Delaunay三角剖分。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230524001225163.png" srcset="/img/loading.gif" lazyload alt="image-20230524001225163"></p>
<h3 id="3-2-准则与性质"><a href="#3-2-准则与性质" class="headerlink" title="3.2 准则与性质"></a>3.2 准则与性质</h3><p>一个三角剖分必须符合以下两条重要准则，才可称之为Delaunay三角剖分。</p>
<ul>
<li><p><strong>空圆特性</strong></p>
<blockquote>
<p>Delaunay三角剖分是唯一的（任意四点不能共圆），在Delaunay三角剖分中任一三角形的外接圆内不会存在其它点。即满足Delaunay边的定义。</p>
</blockquote>
</li>
<li><p><strong>最大化最小角特性</strong></p>
<blockquote>
<p>在点集$P$的所有可能的三角剖分中，Delaunay三角剖分所形成的三角形<strong>最小角</strong>最大。</p>
</blockquote>
</li>
</ul>
<p>Delaunay三角剖分具备以下几点重要的性质：</p>
<p>(1)<strong>唯一性</strong>：无论从点集的任何位置开始建网，最终得到的Delaunay三角剖分都是唯一的。</p>
<p>(2)<strong>最接近</strong>：三角形是以最邻近的三点组成的，并且所形成的三角形的各边都不会相交。 </p>
<p>(3)<strong>最规则</strong>：假如将三角剖分中每个三角形的最小角度按升序进行排列，那么Delaunay三角剖分排列得到的数值最大。</p>
<p>(4)<strong>最优性</strong>：如果任意两个相邻三角形所组成的凸四边形的对角线相互交换，那么交换后两个三角形的六个内角中最小角角度不再增大。 </p>
<p>(5)<strong>区域性</strong>：移动、新增、删除三角剖分中某个顶点时只会影响相邻的三角形。 </p>
<p>(6)<strong>具有凸多边形的外壳</strong>：在所构建的三角剖分中，最外层的边界构成了点集的凸多边形“外壳”（即点集的凸包）。</p>
<h2 id="4-Delaunay三角剖分算法"><a href="#4-Delaunay三角剖分算法" class="headerlink" title="4 Delaunay三角剖分算法"></a>4 Delaunay三角剖分算法</h2><blockquote>
<p>Delaunay三角剖分的算法可以分为逐点插入法、三角网生长法，分治算法等。分治算法的效率最高，逐点插人法实现简单高效，占用内存较小，但它的时间复杂度差。三角网生长法由于效率相对较低，目前采用较少。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525011734005.png" srcset="/img/loading.gif" lazyload alt="image-20230525011734005"></p>
</blockquote>
<h3 id="4-1-Bowyer-Watson算法"><a href="#4-1-Bowyer-Watson算法" class="headerlink" title="4.1 Bowyer-Watson算法"></a>4.1 Bowyer-Watson算法</h3><p>Bowyer-Watson算法属于逐点插入法的一种，易于理解和实现。</p>
<h4 id="4-1-1-算法步骤："><a href="#4-1-1-算法步骤：" class="headerlink" title="4.1.1 算法步骤："></a>4.1.1 算法步骤：</h4><p>Step1：构造一个包含点集中的所有点的超级三角形（super-triangle），放入三角形列表中；</p>
<blockquote>
<p>这个三角形列表可以理解为一个三角剖分，目前只包含一个三角形，即超级三角形。</p>
</blockquote>
<p>Step2：将点集中的点逐一插入现有的三角剖分中，并进行如下调整：</p>
<ul>
<li><p>在三角形列表中，找出所有外接圆包含该插入点的三角形（称为该点的影响三角形），所有影响三角形的合集构成一个“星形多边形”(star shaped polygon)。星形多边形的含义是多边形的任何一个顶点到插入点的连线都在多边形内部。</p>
</li>
<li><p>对于上述星形多边形，将其内部的三角形全部删除，形成一个“空穴”。将空穴边界的顶点与新插入的点连接得到新的三角形，替代剖分中被删除的三角形，从而完成一个点在Delaunay三角形列表中的插入，得到一个包含插入点的新Delaunay三角剖分。</p>
</li>
</ul>
<blockquote>
<p>还有一种说法是：在三角形列表中，找出其外接圆包含插入点的三角形（称为该点的影响三角形），删除影响三角形的公共边，将插入点同影响三角形的全部顶点连接起来，从而完成一个点在Delaunay三角形列表中的插入。该步骤的图示如下：</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/5.GIF" srcset="/img/loading.gif" lazyload alt="img"></p>
</blockquote>
<p>Step3：循环执行Step2，直到所有点插入完毕。</p>
<p>Step4：最后从三角形列表中删除与超级三角形关联的三角形，得到点集的Delaunay三角剖分。</p>
<h4 id="4-1-2-算法伪代码"><a href="#4-1-2-算法伪代码" class="headerlink" title="4.1.2 算法伪代码"></a>4.1.2 算法伪代码</h4><p><strong>版本一</strong></p>
<blockquote>
<p> from <a target="_blank" rel="noopener" href="http://paulbourke.net/papers/triangulate/">Triangulate: Pan Pacific Computer Conference, Beijing, China (paulbourke.net)</a></p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab">input : vertex list<br>output : triangle list<br>   initialize the triangle list<br>   determine the supertriangle<br>   add supertriangle vertices to the <span class="hljs-keyword">end</span> of the vertex list<br>   add the supertriangle to the triangle list<br>   <span class="hljs-keyword">for</span> each sample point in the vertex list<br>      initialize the edge buffer<br>      <span class="hljs-keyword">for</span> each triangle currently in the triangle list<br>         calculate the triangle circumcircle center and radius<br>         <span class="hljs-keyword">if</span> the point lies in the triangle circumcircle then<br>            add the three triangle edges to the edge buffer<br>            remove the triangle from the triangle list<br>         endif<br>      endfor<br>      delete all doubly specified edges from the edge buffer<br>         this leaves the edges of the enclosing polygon only<br>      add to the triangle list all triangles formed between the point <br>         and the edges of the enclosing polygon<br>   endfor<br>   remove any triangles from the triangle list that use the supertriangle vertices<br>   remove the supertriangle vertices from the vertex list<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p><strong>版本二</strong></p>
<blockquote>
<p>from <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bowyer%E2%80%93Watson_algorithm">Bowyer–Watson algorithm - Wikipedia</a>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BowyerWatson</span> (<span class="hljs-params">pointList</span>)</span><br><span class="hljs-function">    // <span class="hljs-title">pointList</span> <span class="hljs-title">is</span> <span class="hljs-title">a</span> <span class="hljs-title">set</span> <span class="hljs-title">of</span> <span class="hljs-title">coordinates</span> <span class="hljs-title">defining</span> <span class="hljs-title">the</span> <span class="hljs-title">points</span> <span class="hljs-title">to</span> <span class="hljs-title">be</span> <span class="hljs-title">triangulated</span></span><br><span class="hljs-function">    <span class="hljs-title">triangulation</span> := <span class="hljs-title">empty</span> <span class="hljs-title">triangle</span> <span class="hljs-title">mesh</span> <span class="hljs-title">data</span> <span class="hljs-title">structure</span></span><br><span class="hljs-function">    <span class="hljs-title">add</span> <span class="hljs-title">super</span>-<span class="hljs-title">triangle</span> <span class="hljs-title">to</span> <span class="hljs-title">triangulation</span> // <span class="hljs-title">must</span> <span class="hljs-title">be</span> <span class="hljs-title">large</span> <span class="hljs-title">enough</span> <span class="hljs-title">to</span> <span class="hljs-title">completely</span> <span class="hljs-title">contain</span> <span class="hljs-title">all</span> <span class="hljs-title">the</span> <span class="hljs-title">points</span> <span class="hljs-title">in</span> <span class="hljs-title">pointList</span></span><br><span class="hljs-function">    <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">point</span> <span class="hljs-title">in</span> <span class="hljs-title">pointList</span> <span class="hljs-title">do</span> // <span class="hljs-title">add</span> <span class="hljs-title">all</span> <span class="hljs-title">the</span> <span class="hljs-title">points</span> <span class="hljs-title">one</span> <span class="hljs-title">at</span> <span class="hljs-title">a</span> <span class="hljs-title">time</span> <span class="hljs-title">to</span> <span class="hljs-title">the</span> <span class="hljs-title">triangulation</span></span><br><span class="hljs-function">        <span class="hljs-title">badTriangles</span> := <span class="hljs-title">empty</span> <span class="hljs-title">set</span></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">triangle</span> <span class="hljs-title">in</span> <span class="hljs-title">triangulation</span> <span class="hljs-title">do</span> // <span class="hljs-title">first</span> <span class="hljs-title">find</span> <span class="hljs-title">all</span> <span class="hljs-title">the</span> <span class="hljs-title">triangles</span> <span class="hljs-title">that</span> <span class="hljs-title">are</span> <span class="hljs-title">no</span> <span class="hljs-title">longer</span> <span class="hljs-title">valid</span> <span class="hljs-title">due</span> <span class="hljs-title">to</span> <span class="hljs-title">the</span> <span class="hljs-title">insertion</span></span><br><span class="hljs-function">            <span class="hljs-title">if</span> <span class="hljs-title">point</span> <span class="hljs-title">is</span> <span class="hljs-title">inside</span> <span class="hljs-title">circumcircle</span> <span class="hljs-title">of</span> <span class="hljs-title">triangle</span></span><br><span class="hljs-function">                <span class="hljs-title">add</span> <span class="hljs-title">triangle</span> <span class="hljs-title">to</span> <span class="hljs-title">badTriangles</span></span><br><span class="hljs-function">        <span class="hljs-title">polygon</span> := <span class="hljs-title">empty</span> <span class="hljs-title">set</span></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">triangle</span> <span class="hljs-title">in</span> <span class="hljs-title">badTriangles</span> <span class="hljs-title">do</span> // <span class="hljs-title">find</span> <span class="hljs-title">the</span> <span class="hljs-title">boundary</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">polygonal</span> <span class="hljs-title">hole</span></span><br><span class="hljs-function">            <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">edge</span> <span class="hljs-title">in</span> <span class="hljs-title">triangle</span> <span class="hljs-title">do</span></span><br><span class="hljs-function">                <span class="hljs-title">if</span> <span class="hljs-title">edge</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">shared</span> <span class="hljs-title">by</span> <span class="hljs-title">any</span> <span class="hljs-title">other</span> <span class="hljs-title">triangles</span> <span class="hljs-title">in</span> <span class="hljs-title">badTriangles</span></span><br><span class="hljs-function">                    <span class="hljs-title">add</span> <span class="hljs-title">edge</span> <span class="hljs-title">to</span> <span class="hljs-title">polygon</span></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">triangle</span> <span class="hljs-title">in</span> <span class="hljs-title">badTriangles</span> <span class="hljs-title">do</span> // <span class="hljs-title">remove</span> <span class="hljs-title">them</span> <span class="hljs-title">from</span> <span class="hljs-title">the</span> <span class="hljs-title">data</span> <span class="hljs-title">structure</span></span><br><span class="hljs-function">            <span class="hljs-title">remove</span> <span class="hljs-title">triangle</span> <span class="hljs-title">from</span> <span class="hljs-title">triangulation</span></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">edge</span> <span class="hljs-title">in</span> <span class="hljs-title">polygon</span> <span class="hljs-title">do</span> // <span class="hljs-title">re</span>-<span class="hljs-title">triangulate</span> <span class="hljs-title">the</span> <span class="hljs-title">polygonal</span> <span class="hljs-title">hole</span></span><br><span class="hljs-function">            <span class="hljs-title">newTri</span> := <span class="hljs-title">form</span> <span class="hljs-title">a</span> <span class="hljs-title">triangle</span> <span class="hljs-title">from</span> <span class="hljs-title">edge</span> <span class="hljs-title">to</span> <span class="hljs-title">point</span></span><br><span class="hljs-function">            <span class="hljs-title">add</span> <span class="hljs-title">newTri</span> <span class="hljs-title">to</span> <span class="hljs-title">triangulation</span></span><br><span class="hljs-function">    <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">triangle</span> <span class="hljs-title">in</span> <span class="hljs-title">triangulation</span> // <span class="hljs-title">done</span> <span class="hljs-title">inserting</span> <span class="hljs-title">points</span>, <span class="hljs-title">now</span> <span class="hljs-title">clean</span> <span class="hljs-title">up</span></span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-title">triangle</span> <span class="hljs-title">contains</span> <span class="hljs-title">a</span> <span class="hljs-title">vertex</span> <span class="hljs-title">from</span> <span class="hljs-title">original</span> <span class="hljs-title">super</span>-<span class="hljs-title">triangle</span></span><br><span class="hljs-function">            <span class="hljs-title">remove</span> <span class="hljs-title">triangle</span> <span class="hljs-title">from</span> <span class="hljs-title">triangulation</span></span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">triangulation</span></span><br></code></pre></td></tr></table></figure>

<h4 id="4-1-3-算法解释示例"><a href="#4-1-3-算法解释示例" class="headerlink" title="4.1.3 算法解释示例"></a>4.1.3 算法解释示例</h4><p>这里我们以A,B,C,D四个点为例，画图说明整个Bowyer-Watson算法的流程。</p>
<ul>
<li><p>首先建立一个超级三角形（p1,p2,p3），这个三角形要把点集中所有的点都包含进去。将这个超级三角形加入三角形列表。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525133130002.png" srcset="/img/loading.gif" lazyload alt="image-20230525133130002"></p>
<blockquote>
<p>关于如何构建超级三角形，详见[4.1.5 实现细节](#4.1.5 实现细节)。</p>
</blockquote>
</li>
<li><p>我们先插入点A，因为原来的三角形列表中唯一的超级三角形外接圆必定包含点A，所以我们可以将三角形▲(p1,p2,p3)看作一个星形多边形，其内部没有三角形，所以我们直接将点A与其顶点相连，将原来的三角形拆分为三个三角形（▲(p1,A,p2），▲(p2,A,p3)，▲(p3,A,p1)）。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525135633264.png" srcset="/img/loading.gif" lazyload alt="image-20230525135633264"></p>
</li>
<li><p>再插入点B，做三角形列表中各个三角形的外接圆，我们找到了点B的影响三角形，即▲(p1,A,p3），▲(p2,A,p3)。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525140915264.png" srcset="/img/loading.gif" lazyload alt="image-20230525140915264"></p>
</li>
<li><p>删除影响三角形组成的星形多边形内部的三角形（公共边，这里即边(A,p3))。然后将点B同影响三角形的全部顶点连接起来。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525141540743.png" srcset="/img/loading.gif" lazyload alt="image-20230525141540743"></p>
</li>
<li><p>接下来再插入点C，同上面插入点B的流程一样，找到影响三角形，删除公共边，连接影响三角形的各个顶点。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142157546.png" srcset="/img/loading.gif" lazyload alt="image-20230525142157546"></p>
</li>
<li><p>然后相同的方法插入点D。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142614560.png" srcset="/img/loading.gif" lazyload alt="image-20230525142614560"></p>
</li>
<li><p>最后删除与超级三角形顶点（p1,p2,p3）相关联的三角形。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142914270.png" srcset="/img/loading.gif" lazyload alt="image-20230525142914270"></p>
</li>
<li><p>最终点A,B,C,D的三角剖分结果如下图。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525143023480.png" srcset="/img/loading.gif" lazyload alt="image-20230525143023480"></p>
</li>
</ul>
<h4 id="4-1-4-算法的优化"><a href="#4-1-4-算法的优化" class="headerlink" title="4.1.4 算法的优化"></a>4.1.4 算法的优化</h4><p>Bowyer-Watson算法比较耗时的一步是关于新插入点的定位。在上文中，我们通过遍历三角形列表中的所有三角形，然后分别判断插入点是否落在其外接圆内。随着点集规模增大，三角形列表在Delaunay三角剖分的构造过程中会逐渐增大，插入点定位的耗时也会随之增加。因此针对点定位问题，有很多优化的改进算法。</p>
<h5 id="（1）排序优化"><a href="#（1）排序优化" class="headerlink" title="（1）排序优化"></a>（1）排序优化</h5><p>该算法优化的思路如下：首先将原始点集中的点按x坐标从小到大进行排序。在插入时，不再是随机插入，而是按照排序顺序进行。保证了新插入的点不会出现在之前插入点的左侧。还有一点不同，该算法中除了点集的列表外，还有已确定的三角形列表和未确定的三角形列表。每次对插入点进行定位时，只需要在未确定的三角形列表中对新插入点进行定位计算，而不再对所有生成的三角形进行查询。如个插入点在查询三角形外接圆的右侧，则说明查询三角形为合法的Delaunay三角形，移存到已确定的三角形列表中；若在外接圆外且不在右侧，则说明该查询三角形仍是一个未确定三角形，不进行任何操作；如在外接圆内，则说明该查询三角形不为Delaunay三角形，从未确定三角形列表中移除。</p>
<p><strong>伪代码：</strong></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs glsl">input: 顶点列表(<span class="hljs-keyword">vertices</span>)                                      <span class="hljs-comment">//vertices为外部生成的随机或乱序顶点列表</span><br>output:已确定的三角形列表(<span class="hljs-keyword">triangles</span>)<br>　　　　初始化顶点列表<br>　　　　创建索引列表(indices = new Array(<span class="hljs-keyword">vertices</span>.<span class="hljs-built_in">length</span>))　　　　<span class="hljs-comment">//indices数组中的值为0,1,2,3,......,vertices.length-1</span><br>　　　　基于<span class="hljs-keyword">vertices</span>中的顶点x坐标对indices进行sort　　  　　　　　  <span class="hljs-comment">//sort后的indices值顺序为顶点坐标x从小到大排序（也可对y坐标，本例中针对x坐标）</span><br>　　　　确定超级三角形<br>　　　　将超级三角形保存至未确定三角形列表（temp <span class="hljs-keyword">triangles</span>）<br>　　　　将超级三角形push到<span class="hljs-keyword">triangles</span>列表<br>　　　　遍历基于indices顺序的<span class="hljs-keyword">vertices</span>中每一个点　　　　　　　　　  　<span class="hljs-comment">//基于indices后，则顶点则是由x从小到大出现</span><br>　　　　　　初始化边缓存数组（edge <span class="hljs-keyword">buffer</span>）<br>　　　　　　遍历temp <span class="hljs-keyword">triangles</span>中的每一个三角形<br>　　　　　　　　计算该三角形的圆心和半径<br>　　　　　　　　如果该点在外接圆的右侧<br>　　　　　　　　　　则该三角形为Delaunay三角形，保存到<span class="hljs-keyword">triangles</span><br>　　　　　　　　　　并在temp里去除掉<br>　　　　　　　　　　跳过<br>　　　　　　　　如果该点在外接圆外（即也不是外接圆右侧）<br>　　　　　　　　　　则该三角形为不确定        　　　　　　　　　     <span class="hljs-comment">//后面会在问题中讨论</span><br>　　　　　　　　　　跳过<br>　　　　　　　　如果该点在外接圆内<br>　　　　　　　　　　则该三角形不为Delaunay三角形<br>　　　　　　　　　　将三边保存至edge <span class="hljs-keyword">buffer</span><br>　　　　　　　　　　在temp中去除掉该三角形<br>　　　　　　对edge <span class="hljs-keyword">buffer</span>进行去重<br>　　　　　　将edge <span class="hljs-keyword">buffer</span>中的边与当前的点进行组合成若干三角形并保存至temp <span class="hljs-keyword">triangles</span>中<br>　　　　将<span class="hljs-keyword">triangles</span>与temp <span class="hljs-keyword">triangles</span>进行合并<br>　　　　除去与超级三角形有关的三角形<br>end<br></code></pre></td></tr></table></figure>

<p><strong>细节：</strong></p>
<p>当插入点在查询三角形外接圆右侧时。由于插入点按照x坐标大小从左往右依次插入，所以剩余的其他点都必然在该外接圆的右侧，即该查询三角形满足<strong>空圆特性</strong>，为Delaunay三角形。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160836087924338.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在查询三角形的外接圆中，插入点1时，符合在外侧的条件，但是不能保证后面所有的点都保持在外接圆外侧。如图中的点2及后面可能出现的点很有可能出现在圆内，而使该三角形被按边分解。所以在该优化算法中，如果碰到在点在外侧且非右侧的话，会跳过，该三角形一直在temp triangles中被检验，直到碰到下一个点在圆内或圆右才会从未确定三角形列表中去除，进行后面的操作。</p>
<p>而当点在圆上时，也是根据在圆内的方法对其进行操作，实际情况中会出现这种情况，该现象称为“退化”。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160838043703195.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>参考：</p>
<p>[1] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhiyishou/p/4430017.html">三角剖分算法(delaunay) - 纸异兽 - 博客园 (cnblogs.com)</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://github.com/darkskyapp/delaunay-fast">darkskyapp/delaunay-fast: Fast Delaunay Triangulation in JavaScript. (github.com)</a></p>
</blockquote>
<h5 id="（2）快速点定位"><a href="#（2）快速点定位" class="headerlink" title="（2）快速点定位"></a>（2）快速点定位</h5><p><font color=orange size=4><b>TODO:</b></font></p>
<blockquote>
<p>参考：</p>
<p>[1] <a target="_blank" rel="noopener" href="https://blog.csdn.net/whb12345678feng/article/details/108110918">计算几何学习——点定位_Mathematic_feng的博客-CSDN博客</a></p>
<p>[2] 刘琴琴.平面域Delaunay三角网点定位算法研究综述[J].电子设计工程,2017,25(01):47-51.DOI:10.14022/j.cnki.dzsjgc.2017.01.012.</p>
<p>[3] 伯格 著, 邓俊辉. 计算几何:算法与应用(第3版)[M]. 清华大学出版社, 2009.</p>
</blockquote>
<h4 id="4-1-5-实现细节"><a href="#4-1-5-实现细节" class="headerlink" title="4.1.5 实现细节"></a>4.1.5 实现细节</h4><h5 id="（1）构造超级三角形"><a href="#（1）构造超级三角形" class="headerlink" title="（1）构造超级三角形"></a>（1）构造超级三角形</h5><p><strong>方法一：</strong></p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525231438652.png" srcset="/img/loading.gif" lazyload alt="image-20230525231438652"></p>
<blockquote>
<p>其中绿色四边形为点集的包围盒。</p>
</blockquote>
<p><strong>方法二：</strong></p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160718101043903.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>根据相似三角形定理求得与矩形一半的小矩形的对角三角形，扩大一倍后则扩大后的直角三角形斜边经过点(Xmax,Ymin)。为了将所有的点包含在超级三角形内，在右下角对该三角形的顶点进行了横和高的扩展，并要保证这个扩展三角形底大于高。</p>
<blockquote>
<p>参考自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhiyishou/p/4430017.html">三角剖分算法(delaunay) - 纸异兽 - 博客园 (cnblogs.com)</a></p>
</blockquote>
<p><strong>其他方法：</strong></p>
<p>上面两种方法的初始化图形都是一个三角形。除此之外，还有学者提出使用一个包含所有点的初始矩形，然后将矩形的任意一条对角线连接，划分为两个三角形加入初始三角剖分列表中。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525232322324.png" srcset="/img/loading.gif" lazyload alt="image-20230525232322324"></p>
<p>上图中，$\text{K}$为一个正位移值。</p>
<h5 id="（2）计算三角形外接圆圆心和半径"><a href="#（2）计算三角形外接圆圆心和半径" class="headerlink" title="（2）计算三角形外接圆圆心和半径"></a>（2）计算三角形外接圆圆心和半径</h5><blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Circumscribed_circle#Circumcircle_equations">https://en.wikipedia.org/wiki/Circumscribed_circle#Circumcircle_equations</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Circumscribed_circle#Circumcenter_coordinates">https://en.wikipedia.org/wiki/Circumscribed_circle#Circumcenter_coordinates</a></p>
</blockquote>
<p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20230527102334838.png" srcset="/img/loading.gif" lazyload alt="image-20230527102334838"></p>
<p>求出外接圆圆心坐标后，圆心与三角形任一顶点的距离即是外接圆半径。</p>
<blockquote>
<p>如果三点共线，那么其外接圆圆心将在无穷远处。</p>
</blockquote>
<h4 id="4-1-6-代码实现"><a href="#4-1-6-代码实现" class="headerlink" title="4.1.6 代码实现"></a>4.1.6 代码实现</h4><p>首先定义点、边、三角形的数据结构。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">float</span>, y: <span class="hljs-built_in">float</span></span>):</span><br>        self.x = x<br>        self.y = y<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__eq__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">return</span> self.x == other.x <span class="hljs-keyword">and</span> self.y == other.y<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dist2</span>(<span class="hljs-params">self, other</span>) -&gt; <span class="hljs-built_in">float</span>:</span><br>        <span class="hljs-keyword">return</span> (self.x - other.x) * (self.x - other.x) + (self.y - other.y) * (self.y - other.y)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isInCircumcircleOf</span>(<span class="hljs-params">self, t</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>        A, B, C = t.verticies[<span class="hljs-number">0</span>], t.verticies[<span class="hljs-number">1</span>], t.verticies[<span class="hljs-number">2</span>]<br>        a2 = A.x * A.x + A.y * A.y<br>        b2 = B.x * B.x + B.y * B.y<br>        c2 = C.x * C.x + C.y * C.y<br>        D = <span class="hljs-number">2.0</span> * (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y))<br>        center_x = (a2 * (B.y - C.y) + b2 * (C.y - A.y) + c2 * (A.y - B.y)) / D<br>        center_y = (a2 * (C.x - B.x) + b2 * (A.x - C.x) + c2 * (B.x - A.x)) / D<br>        center = Point(center_x, center_y)<br>        <span class="hljs-keyword">return</span> self.dist2(center) &lt;= A.dist2(center)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, begin: Point, end: Point</span>):</span><br>        self.begin = begin<br>        self.end = end<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__eq__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">return</span> (self.begin == other.begin <span class="hljs-keyword">and</span> self.end == other.end) <span class="hljs-keyword">or</span> (<br>                self.begin == other.end <span class="hljs-keyword">and</span> self.end == other.begin)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, A: Point, B: Point, C: Point</span>):</span><br>        self.verticies = [A, B, C]<br>        self.edges = [Edge(A, B), Edge(B, C), Edge(C, A)]<br></code></pre></td></tr></table></figure>

<p>然后定义一个用于delaunay三角剖分的类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Delaunay_Triangulation</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Bowyer Watson Algorithm&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[Point]</span>):</span><br>        self.points: <span class="hljs-type">List</span>[Point] = points<br>        self.super_triangle = self.getSuperTriangle()<br>        self.triangles: <span class="hljs-type">List</span>[Triangle] = [self.super_triangle]  <span class="hljs-comment"># add super-triangle to triangulation</span><br>        <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> points:  <span class="hljs-comment"># add all the initial points one at a time to the triangulation</span><br>            self.addPoint(point)<br>        self.removeSuperTriangle()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getSuperTriangle</span>(<span class="hljs-params">self</span>) -&gt; Triangle:</span><br>        sorted_x = <span class="hljs-built_in">sorted</span>(self.points, key = <span class="hljs-keyword">lambda</span> p: p.x)<br>        sorted_y = <span class="hljs-built_in">sorted</span>(self.points, key = <span class="hljs-keyword">lambda</span> p: p.y)<br>        xmin, xmax = sorted_x[<span class="hljs-number">0</span>].x, sorted_x[-<span class="hljs-number">1</span>].x<br>        ymin, ymax = sorted_y[<span class="hljs-number">0</span>].y, sorted_y[-<span class="hljs-number">1</span>].y<br>        dx, dy = xmax - xmin, ymax - ymin<br>        dmax = <span class="hljs-built_in">max</span>(dx, dy)<br>        xmid = xmin + dx * <span class="hljs-number">0.5</span><br>        ymid = ymin + dy * <span class="hljs-number">0.5</span><br><br>        <span class="hljs-keyword">return</span> Triangle(Point(xmid - <span class="hljs-number">20</span> * dmax, ymid - dmax),<br>                        Point(xmid, ymid + <span class="hljs-number">20</span> * dmax),<br>                        Point(xmid + <span class="hljs-number">20</span> * dmax, ymid - dmax))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addPoint</span>(<span class="hljs-params">self, point: Point</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        bad_triangles: <span class="hljs-type">List</span>[Triangle] = []<br>        <span class="hljs-comment"># first find all the triangles that are no longer valid due to the insertion</span><br>        <span class="hljs-keyword">for</span> triangle <span class="hljs-keyword">in</span> self.triangles:<br>            <span class="hljs-keyword">if</span> point.isInCircumcircleOf(triangle):<br>                bad_triangles.append(triangle)<br><br>        polygon: <span class="hljs-type">List</span>[Edge] = []<br>        <span class="hljs-comment"># Find the boundary of the polygonal hole</span><br>        <span class="hljs-keyword">for</span> triangle1 <span class="hljs-keyword">in</span> bad_triangles:<br>            <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> triangle1.edges:<br>                edge_shared = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">for</span> triangle2 <span class="hljs-keyword">in</span> bad_triangles:<br>                    <span class="hljs-keyword">if</span> triangle1 == triangle2:<br>                        <span class="hljs-keyword">continue</span><br>                    <span class="hljs-keyword">if</span> edge <span class="hljs-keyword">in</span> triangle2.edges:<br>                        edge_shared = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> edge_shared:<br>                    polygon.append(edge)<br><br>        <span class="hljs-comment"># Remove broken triangles from the triangulation list</span><br>        <span class="hljs-keyword">for</span> triangle <span class="hljs-keyword">in</span> bad_triangles:<br>            self.triangles.remove(triangle)<br><br>        <span class="hljs-comment"># Create triangles with the newly created edges</span><br>        <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> polygon:<br>            new_triangle = Triangle(edge.begin, edge.end, point)<br>            self.triangles.append(new_triangle)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeSuperTriangle</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-comment"># Remove the triangles that has connection to the super-triangle</span><br>        super_verticies = self.super_triangle.verticies<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.triangles) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            triangle = self.triangles[i]<br>            has_common = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">for</span> vertex1 <span class="hljs-keyword">in</span> triangle.verticies:<br>                <span class="hljs-keyword">for</span> vertex2 <span class="hljs-keyword">in</span> super_verticies:<br>                    <span class="hljs-keyword">if</span> vertex1 == vertex2:<br>                        has_common = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> has_common:<br>                self.triangles.remove(triangle)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exportTriangles</span>(<span class="hljs-params">self</span>):</span><br>        ps = [p <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> self.triangles <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> t.verticies]<br>        xs = [p.x <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> ps]<br>        ys = [p.y <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> ps]<br>        ts = [(ps.index(t.verticies[<span class="hljs-number">0</span>]), ps.index(t.verticies[<span class="hljs-number">1</span>]), ps.index(t.verticies[<span class="hljs-number">2</span>])) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> self.triangles]<br>        <span class="hljs-keyword">return</span> xs, ys, ts<br></code></pre></td></tr></table></figure>

<p>其中<code>exportTriangles</code>函数用于导出matplotlib库绘制剖分结果所需的数据。算法测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint, seed<br><span class="hljs-keyword">from</span> Delaunay_Triangulation <span class="hljs-keyword">import</span> Delaunay_Triangulation, Point<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    seed(<span class="hljs-number">5</span>)<br>    n = <span class="hljs-number">10</span><br>    xs = [randint(<span class="hljs-number">1</span>, <span class="hljs-number">98</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    ys = [randint(<span class="hljs-number">1</span>, <span class="hljs-number">98</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    seted_points = <span class="hljs-built_in">set</span>(<span class="hljs-built_in">zip</span>(xs, ys))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The actual number of input points: &quot;</span>, <span class="hljs-built_in">len</span>(seted_points))<br>    points = [Point(x, y) <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> seted_points]<br>    start_time = time.time()<br>    dt = Delaunay_Triangulation(points)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Triangulating <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(seted_points)&#125;</span> points takes <span class="hljs-subst">&#123;time.time() - start_time&#125;</span> s&quot;</span>)<br>    <span class="hljs-comment"># number of DT triangles</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(dt.triangles), <span class="hljs-string">&quot;Delaunay triangles&quot;</span>)<br><br>    <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>    <span class="hljs-keyword">import</span> matplotlib.tri <span class="hljs-keyword">as</span> tri<br><br>    <span class="hljs-comment"># Plot the triangulation.</span><br>    fig, ax = plt.subplots()<br>    ax.margins(<span class="hljs-number">0.1</span>)<br>    ax.set_aspect(<span class="hljs-string">&#x27;equal&#x27;</span>)<br>    xs1, ys1, ts = dt.exportTriangles()<br>    ax.triplot(tri.Triangulation(xs1, ys1, ts), <span class="hljs-string">&#x27;bo-&#x27;</span>)<br>    triang = tri.Triangulation(xs, ys)<br>    ax.triplot(triang, <span class="hljs-string">&#x27;ro-&#x27;</span>)<br>    ax.set_title(<span class="hljs-string">&#x27;triplot of Delaunay triangulation&#x27;</span>)<br>    plt.show()<br></code></pre></td></tr></table></figure>

<p>其中<code>seted_points = set(zip(xs, ys))</code>用于去除随机生成点集中的重复点，满足输入点集的坐标互异要求。否则，若随机生成的两点坐标相同，在计算点外接圆时，如下代码中，D为0，会抛出<code>ZeroDivisionError: division by zero</code>异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">D = <span class="hljs-number">2.0</span> * (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y))<br>center_x = (a2 * (B.y - C.y) + b2 * (C.y - A.y) + c2 * (A.y - B.y)) / D<br>center_y = (a2 * (C.x - B.x) + b2 * (A.x - C.x) + c2 * (B.x - A.x)) / D<br></code></pre></td></tr></table></figure>

<p>如下两行代码的作用是，调用<code>matplotlib.tri.Triangulation</code>构建三角剖分。用两种不同的颜色分别绘制我们编写的代码和调用第三方库函数进行三角剖分的结果，可以验证算法的正确性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">triang = tri.Triangulation(xs, ys)<br>ax.triplot(triang, <span class="hljs-string">&#x27;ro-&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205450735.png" srcset="/img/loading.gif" lazyload alt="image-20230528205450735"></p>
<p>经过测试发现，<code>matplotlib.tri.Triangulation</code>函数得到的三角剖分在随机生成点集数量比较大时，会和本算法的剖分结果有差异。</p>
<p><code>matplotlib.tri.Triangulation</code>函数剖分结果：</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205916411.png" srcset="/img/loading.gif" lazyload alt="image-20230528205916411"></p>
<p>我们编写的<code>Delaunay_Triangulation</code>类的剖分结果：</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205904484.png" srcset="/img/loading.gif" lazyload alt="image-20230528205904484"></p>
<p>出现这种问题的原因，我猜测可能是因为某四点共圆了。</p>
<blockquote>
<p>在Delaunay三角剖分的性质中，若点集$P$中任意四点不共圆，则存在唯一的Delaunay三角剖分$T$。若点集$P$中四点$A,B,C,D$共圆，且△ABC,△BCD属于Delaunay三角剖分T，那么将边$BC$翻转后得到的三角剖分$T’$(包含△ABD,△ACD)同样是一个Delaunay三角剖分。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/459884570">技术分享：Delaunay三角剖分算法介绍 - 知乎 (zhihu.com)</a></p>
</blockquote>
<p>通过输入一系列共圆点，得到下图结果。两种都属于Delaunay三角剖分。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230529004839957.png" srcset="/img/loading.gif" lazyload alt="image-20230529004839957"></p>
<p>在效率上，测试了三组数据。结果如下：</p>
<table>
<thead>
<tr>
<th>点集规模/个</th>
<th>耗时/s</th>
</tr>
</thead>
<tbody><tr>
<td>1000</td>
<td>4</td>
</tr>
<tr>
<td>4000</td>
<td>60</td>
</tr>
<tr>
<td>6000</td>
<td>150</td>
</tr>
</tbody></table>
<p>时间复杂度大概为$O(n^2)$，$n$为点集大小。</p>
<h3 id="4-2-分治法"><a href="#4-2-分治法" class="headerlink" title="4.2 分治法"></a>4.2 分治法</h3><blockquote>
<p>参考文献：</p>
<p><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/282918.282923">[1] Guibas L, Stolfi J. Primitives for the manipulation of general subdivisions and the computation of Voronoi[J]. ACM Transactions on Graphics, 1985, 4(2): 74–123.</a></p>
<p>L. Guibas 和 J. Stolfi 提出了Quad-Edge数据结构，并使用其简化了1975年Shamos和Hoey提出的Delaunay三角剖分分治算法。在上述的参考文献中，作者专门用了一节对分治法三角剖分进行介绍，并附有详细的伪代码。</p>
</blockquote>
<h4 id="4-2-1-Quad-Edge"><a href="#4-2-1-Quad-Edge" class="headerlink" title="4.2.1 Quad-Edge"></a>4.2.1 Quad-Edge</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/afs/andrew/scs/cs/15-463/2001/pub/src/a2/quadedge.html#guibas">Quad-Edge Data Structure and Library (cmu.edu)</a></p>
</blockquote>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/edge.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vertex</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y, _id = <span class="hljs-literal">None</span></span>):</span><br>        self.<span class="hljs-built_in">id</span> = _<span class="hljs-built_in">id</span><br>        self.x = x<br>        self.y = y<br><br>        self.name = <span class="hljs-string">f&#x27;v_<span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>&#x27;</span>  <span class="hljs-comment"># for debugging</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quad_Edge</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;A directed edge: org -&gt; dest.</span><br><span class="hljs-string">    When traversing edge ring: Next is CCW, Prev is CW.&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, org, dest</span>):</span><br>        self.org = org  <span class="hljs-comment"># Origin</span><br>        self.dest = dest  <span class="hljs-comment"># Destination</span><br>        self.onext = <span class="hljs-literal">None</span>  <span class="hljs-comment"># next edge around origin,with same origin</span><br>        self.oprev = <span class="hljs-literal">None</span>  <span class="hljs-comment"># prev edge around origin,with same origin</span><br>        self.sym = <span class="hljs-literal">None</span>  <span class="hljs-comment"># edge pointing opposite dest this edge</span><br>        self.deleted = <span class="hljs-literal">False</span>  <span class="hljs-comment"># Deleted flag</span><br><br>        self.name = <span class="hljs-string">f&#x27;e_<span class="hljs-subst">&#123;self.org.<span class="hljs-built_in">id</span>&#125;</span>_<span class="hljs-subst">&#123;self.dest.<span class="hljs-built_in">id</span>&#125;</span>&#x27;</span>  <span class="hljs-comment"># for debugging</span><br></code></pre></td></tr></table></figure>

<p>分治法三角剖分中我们使用Quad-Edge作为边的数据结构。下面我们将介绍一些边的拓扑操作。</p>
<blockquote>
<p>Reference: <a target="_blank" rel="noopener" href="https://github.com/alexbaryzhikov/triangulation">https://github.com/alexbaryzhikov/triangulation</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_edge</span>(<span class="hljs-params">org, dest, edges</span>) -&gt; Quad_Edge:</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Creates an edge, add it dest edges, and return it.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    e = Quad_Edge(org, dest)<br>    es = Quad_Edge(dest, org)<br>    e.sym, es.sym = es, e  <span class="hljs-comment"># make edges mutually symmetrical</span><br>    e.onext, e.oprev = e, e<br>    es.onext, es.oprev = es, es<br>    edges.append(e)<br>    <span class="hljs-keyword">return</span> e<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_next_prev</span>(<span class="hljs-params">e1: Quad_Edge, e2: Quad_Edge</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Either combines e1 and e2 into a single edge, or seperates them.</span><br><span class="hljs-string">    Which one is determined by the orientation of e1 and e2.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> e1 == e2:<br>        <span class="hljs-keyword">return</span><br>    e1.onext.oprev = e2<br>    e2.onext.oprev = e1<br>    <span class="hljs-comment"># Swap a.onext and b.onext</span><br>    e1.onext, e2.onext = e2.onext, e1.onext<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connect</span>(<span class="hljs-params">e1: Quad_Edge, e2: Quad_Edge, edges</span>) -&gt; Quad_Edge:</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Connecting destination of e1 with the origin of e2 with an edge</span><br><span class="hljs-string">    O(1) time and O(1) space</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    e = create_edge(e1.dest, e2.org, edges)<br>    <span class="hljs-comment"># Maintain the onext and oprev values</span><br>    update_next_prev(e, e1.sym.oprev)<br>    update_next_prev(e.sym, e2)<br>    <span class="hljs-keyword">return</span> e<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mark_edge_deleted</span>(<span class="hljs-params">e: Quad_Edge</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Delete edge from the edge list</span><br><span class="hljs-string">    O(1) time and O(1) space</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># Update the e.onext&#x27; and e.oprev&#x27;s values</span><br>    update_next_prev(e, e.oprev)<br>    update_next_prev(e.sym, e.sym.oprev)<br>    <span class="hljs-comment"># Mark the edge dest be deleted</span><br>    e.deleted = <span class="hljs-literal">True</span><br>    e.sym.deleted = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>

<h5 id="（1）create-edge-org-dest-edges"><a href="#（1）create-edge-org-dest-edges" class="headerlink" title="（1）create_edge(org, dest, edges)"></a>（1）create_edge(org, dest, edges)</h5><p>该函数用于返回以<code>org</code>为起点，<code>dest</code>为终点的边（这里及[本节](#4.2.1 Quad-Edge)中提到的边都指Quad-Edge），同时将这条边放入<code>edges</code>列表中。我们在该函数中初始化了新生成边的对称边，并且正确初始化了新边及其对称边的<code>onext</code>和<code>oprev</code>属性，因为新边未与任何其他边建立拓扑联系，所以这两个属性都是这两条边自身。具体实现细节参见文章^[1]^中提出的<code>MakeEdge</code>操作。</p>
<h5 id="（2）update-next-prev-e1-e2"><a href="#（2）update-next-prev-e1-e2" class="headerlink" title="（2）update_next_prev(e1, e2)"></a>（2）update_next_prev(e1, e2)</h5><p>该函数用于<strong>拼接</strong>e1边和e2边，实质上是更新了两条边的<code>onext</code>和<code>oprev</code>属性。具体实现细节参见文章^[1]^中提出的<code>Splice</code>操作。</p>
<h5 id="（3）connect-e1-e2-edges"><a href="#（3）connect-e1-e2-edges" class="headerlink" title="（3）connect(e1, e2, edges)"></a>（3）connect(e1, e2, edges)</h5><p>该函数使用一条新边连接e1边和e2边，并更新三者的拓扑关系。具体实现细节参见文章^[1]^中提出的<code>Connect</code>操作。</p>
<h5 id="（4）mark-edge-deleted-e"><a href="#（4）mark-edge-deleted-e" class="headerlink" title="（4）mark_edge_deleted(e)"></a>（4）mark_edge_deleted(e)</h5><p>该函数用于删除一条边，本质上是改变删除边和其他边的拓扑关系。具体实现细节参见文章^[1]^中提出的<code>DeleteEdge</code>操作。</p>
<h4 id="4-2-2-DCEL"><a href="#4-2-2-DCEL" class="headerlink" title="4.2.2 DCEL"></a>4.2.2 DCEL</h4><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13o4y1Q7eH/">https://www.bilibili.com/video/BV13o4y1Q7eH/</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;A sample implementation of the DCEL structure in Python&quot;&quot;&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vertex</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y</span>):</span><br>        self.x = x<br>        self.y = y<br>        self.coordinates = [x, y]  <span class="hljs-comment"># 顶点坐标</span><br>        self.incidentEdge = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 以该顶点为起点的半边</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Face</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.outerComponent = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 外边界上的某一条半边</span><br>        self.innerComponents = []  <span class="hljs-comment"># 内部包含的孔洞列表，其中每个孔洞用一条半边代表</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HalfEdge</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, origin = <span class="hljs-literal">None</span>, incidentFace = <span class="hljs-literal">None</span></span>):</span><br>        self.origin = origin  <span class="hljs-comment"># 半边的起始顶点</span><br>        self.twin = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 孪生半边</span><br>        self.incidentFace = incidentFace  <span class="hljs-comment"># 该半边指向的平面</span><br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 下一条半边</span><br>        self.prev = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 前一条半边</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DCEL</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, vertices = <span class="hljs-literal">None</span>, faces = <span class="hljs-literal">None</span>, half_edges = <span class="hljs-literal">None</span></span>):</span><br>        self.vertices = vertices<br>        self.faces = faces<br>        self.halfEdges = half_edges<br></code></pre></td></tr></table></figure>

<h4 id="4-2-3-工具算法"><a href="#4-2-3-工具算法" class="headerlink" title="4.2.3 工具算法"></a>4.2.3 工具算法</h4><h5 id="（1）判断点是否在三角形外接圆内"><a href="#（1）判断点是否在三角形外接圆内" class="headerlink" title="（1）判断点是否在三角形外接圆内"></a>（1）判断点是否在三角形外接圆内</h5><p>点$d$在三角形$(a,b,c)$外接圆内满足如下不等式：<br>$$<br>ret =\begin{vmatrix}a_x&amp;a_y&amp;a_x^2+a_y^2&amp;1\[0.3em]b_x&amp;b_y&amp;b_x^2+b_y^2&amp;1\[0.3em]c_x&amp;c_y&amp;c_x^2+c_y^2&amp;1\[0.3em]d_x&amp;d_y&amp;d_x^2+d_y^2&amp;1\end{vmatrix}&gt;0\tag{4-1}<br>$$<br>行列式每行减去第四行，得：<br>$$<br>ret =\begin{vmatrix}a_x-d_x&amp;a_y-d_y&amp;a_x^2+a_y^2-(d_x^2+d_y^2)&amp;0\[0.3em]b_x-d_x&amp;b_y-d_y&amp;b_x^2+b_y^2-(d_x^2+d_y^2)&amp;0\[0.3em]c_x-d_x&amp;c_y-d_y&amp;c_x^2+c_y^2-(d_x^2+d_y^2)&amp;0\[0.3em]d_x&amp;d_y&amp;d_x^2+d_y^2&amp;1\end{vmatrix}&gt;0\tag{4-2}<br>$$<br>简化得到下式：<br>$$<br>ret =\begin{vmatrix}a_x-d_x&amp;a_y-d_y&amp;a_x^2+a_y^2-(d_x^2+d_y^2)\[0.3em]b_x-d_x&amp;b_y-d_y&amp;b_x^2+b_y^2-(d_x^2+d_y^2)\[0.3em]c_x-d_x&amp;c_y-d_y&amp;c_x^2+c_y^2-(d_x^2+d_y^2)\end{vmatrix}&gt;0\tag{4-3}<br>$$<br>接下来，将式（4-3）中行列式第三列加上第一列和第二列的$-2d_x$倍，然后将第三列元素整理化成平方差形式，得到下式：<br>$$<br>ret =\begin{vmatrix}a_x-d_x&amp;a_y-d_y&amp;(a_x-d_x)^2+(a_y-d_y)^2\[0.3em]b_x-d_x&amp;b_y-d_y&amp;(b_x-d_x)^2+(b_y-d_y)^2\[0.3em]c_x-d_x&amp;c_y-d_y&amp;(c_x-d_x)^2+(c_y-d_y)^2\end{vmatrix}&gt;0\tag{4-4}<br>$$<br>形如$ad_x=a_x-d_x$替换相同元，得到下式：<br>$$<br>ret =\begin{vmatrix}ad_x&amp;ad_y&amp;ad_x^2+ad_y^2\[0.3em]bd_x&amp;bd_y&amp;bd_x^2+bd_y^2\[0.3em]cd_x&amp;cd_y&amp;cd_x^2+cd_y^2\end{vmatrix}&gt;0\tag{4-5}<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inCircle</span>(<span class="hljs-params">a: Vertex, b: Vertex, c: Vertex, d: Vertex</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;判断点d是否在由a,b,c构成的三角形外接圆内&quot;&quot;&quot;</span><br>    adx = a.x - d.x<br>    ady = a.y - d.y<br>    bdx = b.x - d.x<br>    bdy = b.y - d.y<br>    cdx = c.x - d.x<br>    cdy = c.y - d.y<br><br>    alift = adx * adx + ady * ady<br>    blift = bdx * bdx + bdy * bdy<br>    clift = cdx * cdx + cdy * cdy<br>    <br>    <span class="hljs-keyword">return</span> alift * (bdx * cdy - cdx * bdy) + blift * (cdx * ady - adx * cdy) + clift * (adx * bdy - bdx * ady) &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h5 id="（2）判断点与边的相对位置"><a href="#（2）判断点与边的相对位置" class="headerlink" title="（2）判断点与边的相对位置"></a>（2）判断点与边的相对位置</h5><p>设边的起点$a$，终点$b$，输入点为$p$。<br>$$<br>det=\begin{vmatrix}a_x&amp;a_y&amp;1\[0.3em]b_x&amp;b_y&amp;1\[0.3em]p_x&amp;p_y&amp;1\end{vmatrix}\tag{4-6}<br>$$</p>
<p>$$<br>det=(a_x-p_x)(b_y-p_y)-(a_y-p_y)(b_x-p_x)\tag{4-7}<br>$$</p>
<ul>
<li>$det&gt;0$，$p$在边左边；</li>
<li>$det&lt;0$，$p$在边右边；</li>
<li>$det=0$，$p$在边共线。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">left_test</span>(<span class="hljs-params">p, e</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Left test for point p relative to the line of edge e.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    a, b = e.org, e.sym.org<br>    det1 = (a.x - p.x) * (b.y - p.y)<br>    det2 = (a.y - p.y) * (b.x - p.x)<br>    <span class="hljs-keyword">return</span> det1 - det2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toRight</span>(<span class="hljs-params">p, e</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Does point p lie to the right of the line of edge e?&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> left_test(p, e) &lt; <span class="hljs-number">0</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toLeft</span>(<span class="hljs-params">p, e</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Does point p lie to the left of the line of edge e?&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> left_test(p, e) &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h4 id="4-2-4-主要程序"><a href="#4-2-4-主要程序" class="headerlink" title="4.2.4 主要程序"></a>4.2.4 主要程序</h4><p><strong>算法伪代码：</strong></p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230606140652092.png" srcset="/img/loading.gif" lazyload alt="image-20230606140652092"></p>
<p><strong>主程序：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Divide_Delaunay</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Triangulate the points using the divide and conquer delaunay triangulation algorithm.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, points</span>):</span><br>        self.points = points<br>        self.verticies = []<br>        self.init_points()  <span class="hljs-comment"># 初始化点集</span><br>        self.edges = []<br>        self.div_and_conq_triangulate(self.verticies)  <span class="hljs-comment"># 分治法构造三角网</span><br><br>        <span class="hljs-comment"># Remove edges that are not part of the triangulation</span><br>        self.edges = [e <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> self.edges <span class="hljs-keyword">if</span> e.deleted <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_points</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># Validate the input size</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.points) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># Sort points by x coordinate, y is a tiebreaker</span><br>        self.points.sort(key = <span class="hljs-keyword">lambda</span> point: (point[<span class="hljs-number">0</span>], point[<span class="hljs-number">1</span>]))<br><br>        <span class="hljs-comment"># Remove duplicates</span><br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(self.points) - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> self.points[i] == self.points[i + <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">del</span> self.points[i]<br>            <span class="hljs-keyword">else</span>:<br>                i += <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># Vertex naming</span><br>        <span class="hljs-keyword">for</span> i, point <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.points):<br>            self.verticies.append(Vertex(point[<span class="hljs-number">0</span>], point[<span class="hljs-number">1</span>], i))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">div_and_conq_triangulate</span>(<span class="hljs-params">self, points</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Computes the Delaunay triangulation of self.points and returns two edges, le and re,</span><br><span class="hljs-string">        which are the counterclockwise convex hull edge out of the leftmost vertex and the clockwise</span><br><span class="hljs-string">        convex hull edge out of the rightmost vertex, respectively.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(points)<br>        <span class="hljs-comment"># Base case: 2 points</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:<br>            edge = create_edge(points[<span class="hljs-number">0</span>], points[<span class="hljs-number">1</span>], self.edges)<br>            <span class="hljs-keyword">return</span> edge, edge.sym<br><br>        <span class="hljs-comment"># Base case: 3 points</span><br>        <span class="hljs-keyword">elif</span> n == <span class="hljs-number">3</span>:<br>            <span class="hljs-comment"># Create edge S[0]-S[1] and edge S[1]-S[2]</span><br>            edge1 = create_edge(points[<span class="hljs-number">0</span>], points[<span class="hljs-number">1</span>], self.edges)<br>            edge2 = create_edge(points[<span class="hljs-number">1</span>], points[<span class="hljs-number">2</span>], self.edges)<br>            update_next_prev(edge1.sym, edge2)<br><br>            <span class="hljs-comment"># Create edge S[2]-S[0]</span><br>            <span class="hljs-keyword">if</span> toRight(points[<span class="hljs-number">2</span>], edge1):  <span class="hljs-comment"># Right</span><br>                connect(edge2, edge1, self.edges)<br>                <span class="hljs-keyword">return</span> edge1, edge2.sym<br>            <span class="hljs-keyword">elif</span> toLeft(points[<span class="hljs-number">2</span>], edge1):  <span class="hljs-comment"># Left</span><br>                edge3 = connect(edge2, edge1, self.edges)<br>                <span class="hljs-keyword">return</span> edge3.sym, edge3<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># Points are linear</span><br>                <span class="hljs-keyword">return</span> edge1, edge2.sym<br><br>        <span class="hljs-comment"># Recurively triangulate the left and right halves</span><br>        <span class="hljs-keyword">else</span>:<br>            m = n // <span class="hljs-number">2</span><br>            ldo, ldi = self.div_and_conq_triangulate(points[:m])<br>            rdi, rdo = self.div_and_conq_triangulate(points[m:])<br>            ldo_r, rdo_r = self.merge(ldo, ldi, rdi, rdo)<br><br>            <span class="hljs-keyword">return</span> ldo_r, rdo_r<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">self, ldo, ldi, rdi, rdo</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Takes 2 halves of the triangulation and merges them into a single triangulation.</span><br><span class="hljs-string">        While doing so it uses previosly calculated values of these halves.</span><br><span class="hljs-string">        Reference: https://github.com/alexbaryzhikov/triangulation</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># Compute the upper common tangent of L and R.</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> toRight(rdi.org, ldi):<br>                <span class="hljs-comment"># Advance dest the next edge on the convex hull of L.</span><br>                ldi = ldi.sym.onext<br>            <span class="hljs-keyword">elif</span> toLeft(ldi.org, rdi):<br>                <span class="hljs-comment"># Advance dest the next edge on the convex hull of R.</span><br>                rdi = rdi.sym.oprev<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br><br>        <span class="hljs-comment"># Create a first cross edge base.</span><br>        base = connect(ldi.sym, rdi, self.edges)<br><br>        <span class="hljs-comment"># Adjust ldo and rdo</span><br>        <span class="hljs-keyword">if</span> ldi.org.x == ldo.org.x <span class="hljs-keyword">and</span> ldi.org.y == ldo.org.y:<br>            ldo = base<br>        <span class="hljs-keyword">if</span> rdi.org.x == rdo.org.x <span class="hljs-keyword">and</span> rdi.org.y == rdo.org.y:<br>            rdo = base.sym<br><br>        <span class="hljs-comment"># Merge two halves</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># Locate the first R and L points dest be encountered by the diving bubble.</span><br>            rcand, lcand = base.sym.onext, base.oprev<br><br>            <span class="hljs-comment"># If both lcand and rcand are invalid, then base is the lower common tangent.</span><br>            v_rcand, v_lcand = toRight(rcand.dest, base), toRight(lcand.dest, base)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (v_rcand <span class="hljs-keyword">or</span> v_lcand):<br>                <span class="hljs-keyword">break</span><br><br>            <span class="hljs-comment"># Delete R edges out of base.dest that fail the circle test.</span><br>            <span class="hljs-keyword">if</span> v_rcand:<br>                <span class="hljs-keyword">while</span> toRight(rcand.onext.dest, base) <span class="hljs-keyword">and</span> inCircle(base.dest, base.org, rcand.dest, rcand.onext.dest):<br>                    t = rcand.onext<br>                    mark_edge_deleted(rcand)<br>                    rcand = t<br><br>            <span class="hljs-comment"># Symmetrically, delete L edges.</span><br>            <span class="hljs-keyword">if</span> v_lcand:<br>                <span class="hljs-keyword">while</span> toRight(lcand.oprev.dest, base) <span class="hljs-keyword">and</span> inCircle(base.dest, base.org, lcand.dest, lcand.oprev.dest):<br>                    t = lcand.oprev<br>                    mark_edge_deleted(lcand)<br>                    lcand = t<br><br>            <span class="hljs-comment"># The next cross edge is dest be connected dest either lcand.dest or rcand.dest.</span><br>            <span class="hljs-comment"># If both are valid, then choose the appropriate one using the in_circle test.</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> v_rcand <span class="hljs-keyword">or</span> (v_lcand <span class="hljs-keyword">and</span> inCircle(rcand.dest, rcand.org, lcand.org, lcand.dest)):<br>                <span class="hljs-comment"># Add cross edge base from rcand.dest dest base.dest.</span><br>                base = connect(lcand, base.sym, self.edges)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># Add cross edge base from base.org dest lcand.dest</span><br>                base = connect(base.sym, rcand.sym, self.edges)<br><br>        <span class="hljs-keyword">return</span> ldo, rdo<br></code></pre></td></tr></table></figure>

<p><strong>测试程序：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">from</span> divide_delaunay <span class="hljs-keyword">import</span> Divide_Delaunay<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    np.random.seed(<span class="hljs-number">16</span>)<br>    num = <span class="hljs-number">10</span><br>    fig = plt.figure()<br>    plt.ion()<br>    ax = fig.add_subplot(<span class="hljs-number">111</span>)<br>    xs = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, num)<br>    ys = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, num)<br>    <span class="hljs-comment"># xs = np.array([0, 1, 2, 3, 4, 5])</span><br>    <span class="hljs-comment"># ys = np.array([0, 2, 1, 1, 4, 3])</span><br><br>    start_time = time.time()<br>    dt = Divide_Delaunay(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(xs, ys)))<br>    end_time = time.time()<br>    verticies, edges = dt.verticies, dt.edges<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Triangulating <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(verticies)&#125;</span> points takes <span class="hljs-subst">&#123;end_time - start_time&#125;</span> s&quot;</span>)<br><br>    <span class="hljs-comment"># draw points</span><br>    <span class="hljs-keyword">for</span> vertex <span class="hljs-keyword">in</span> verticies:<br>        ax.scatter(vertex.x, vertex.y, c = <span class="hljs-string">&#x27;b&#x27;</span>)<br><br>    <span class="hljs-comment"># draw edges</span><br>    <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> edges:<br>        a, b = edge.org, edge.sym.org<br>        ax.plot([a.x, b.x], [a.y, b.y], <span class="hljs-string">&#x27;bo-&#x27;</span>)<br>        plt.pause(<span class="hljs-number">0.5</span>)<br><br>    <span class="hljs-keyword">import</span> matplotlib.tri <span class="hljs-keyword">as</span> tri<br><br>    <span class="hljs-comment"># Plot the triangulation.</span><br>    triang = tri.Triangulation([v.x <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> verticies], [v.y <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> verticies])<br>    ax.triplot(triang, <span class="hljs-string">&#x27;ro-&#x27;</span>)<br><br>    fig.show()<br>    plt.pause(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/GIF%202023-6-6%2014-11-07.gif" srcset="/img/loading.gif" lazyload alt="GIF 2023-6-6 14-11-07"></p>
<blockquote>
<p>在我们写的代码中，合并部分最开始寻找的是左右子剖分的上公切线，然后从上到下进行连接合并。当然，也可以寻找下公切线，然后从下向上进行连接合并，两种方式都是一样的效果，是不过判断逻辑相反。</p>
</blockquote>
<p>在效率上，测试了三组数据。结果如下：</p>
<table>
<thead>
<tr>
<th>点集规模/个</th>
<th>耗时/s</th>
</tr>
</thead>
<tbody><tr>
<td>1000</td>
<td>0.09</td>
</tr>
<tr>
<td>4000</td>
<td>0.33</td>
</tr>
<tr>
<td>6000</td>
<td>0.49</td>
</tr>
</tbody></table>
<p>时间复杂度大概为$O(nlogn)$，$n$为点集大小。</p>
<hr>
<h2 id="更多关于网格划分生成的细节和拓展参见：Lecture-Notes-on-Delaunay-Mesh-Generation"><a href="#更多关于网格划分生成的细节和拓展参见：Lecture-Notes-on-Delaunay-Mesh-Generation" class="headerlink" title="更多关于网格划分生成的细节和拓展参见：Lecture Notes on Delaunay Mesh Generation"></a>更多关于网格划分生成的细节和拓展参见：<a target="_blank" rel="noopener" href="https://people.eecs.berkeley.edu/~jrs/meshpapers/delnotes.pdf">Lecture Notes on Delaunay Mesh Generation</a></h2><p>title: Delaunay三角剖分<br>date: 2023-06-06 14:36:39<br>tags: 学习记录</p>
<hr>
<p>[TOC]</p>
<h2 id="1-text-Voronoi-图-1"><a href="#1-text-Voronoi-图-1" class="headerlink" title="1 $\text{Voronoi}$图"></a>1 $\text{Voronoi}$图</h2><blockquote>
<p>在理解Delaunay三角剖分之前，先引入$\text{Voronoi}$图。</p>
</blockquote>
<h3 id="1-1-定义与性质-1"><a href="#1-1-定义与性质-1" class="headerlink" title="1.1 定义与性质"></a>1.1 定义与性质</h3><p><strong>定义</strong></p>
<p>设由任意$n$个互异平面点（也称基点）组成的点集$P={p_i|i=1,…,n}$。$P$对应的$\text{Voronoi}$图可以理解为对平面的一个区域（单元）划分。对于划分得到的每个区域（也称$\text{Voronoi}$多边形），都应当满足：在基点$p_i$对应的单元中任取一点，该点到$p_i$的（欧式）距离一定小于到$p_j，p_j\in{P},j\ne{i}$的（欧式）距离。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230522154118839.png" srcset="/img/loading.gif" lazyload alt="image-20230522154118839"></p>
<blockquote>
<p>$\text{Voronoi}$又称泰森多边形或$\text{Dirichlet}$图。</p>
<p>平面上的 V-图可以看作是数据点集合 P 中的每个点作为生长点，以相同的速率向 外扩散，直到彼此相遇为止在平面上所形成的图形。除最外层的点形成开放的区域外， 其余的每个点都形成一个凸多边形。</p>
</blockquote>
<p><strong>一些性质</strong></p>
<ul>
<li>每个$\text{Voronoi}$多边形内仅包含一个基点；</li>
<li>$\text{Voronoi}$多边形内的任一点到相应基点的（欧式）距离最近；</li>
<li>位于$\text{Voronoi}$多边形边上的点到其两边的离散点的距离相等；</li>
<li>$n$个点的集合$P$的$\text{Voronoi}$图最多有$2n-5$个顶点和$3n-6$条边；</li>
<li>假如任意四个基点都不共圆，则每个$\text{Voronoi}$顶点恰好是三条$\text{Voronoi}$边的交点，即由$P$中的三点所形成三角形外接圆的圆心。</li>
</ul>
<blockquote>
<p>参考：</p>
<p>[1] 高莉. 改进的Delaunay三角剖分算法研究[D]. 兰州交通大学, 2015.</p>
<p>[2] <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B3%B0%E6%A3%AE%E5%A4%9A%E8%BE%B9%E5%BD%A2?fr=aladdin">泰森多边形_百度百科 (baidu.com)</a></p>
</blockquote>
<h2 id="2-三角剖分-1"><a href="#2-三角剖分-1" class="headerlink" title="2 三角剖分"></a>2 三角剖分</h2><h3 id="2-1-定义与性质-1"><a href="#2-1-定义与性质-1" class="headerlink" title="2.1 定义与性质"></a>2.1 定义与性质</h3><p>设由任意$n$个平面点组成的点集$P={p_i|i=1,…,n}$。三角剖分是指用<strong>互不相交</strong>的直线段连接$P_i$与$P_j$，$1≤i，j≤n，i≠j$，并且使其凸包中的每个划分区域都是一个三角形。</p>
<p>由于三角剖分是一个平面图，故满足以下几个条件：</p>
<ul>
<li>图中不存在相交的边（除线段端点外，不存在重叠的边）；</li>
<li>图中的边不包含集合$P$中的其他任何点，端点除外；</li>
<li>图中所有的面片都是三角形，并且所有三角形的集合构成$P$的凸包。</li>
</ul>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230523011544467.png" srcset="/img/loading.gif" lazyload alt="image-20230523011544467"></p>
<h3 id="2-2-质量-quality-评定标准-1"><a href="#2-2-质量-quality-评定标准-1" class="headerlink" title="2.2 质量(quality)评定标准"></a>2.2 质量(quality)评定标准</h3><p>由于对给定点集的三角剖分不唯一，对于不同的三角剖分我们有如下质量评定标准：</p>
<table>
<thead>
<tr>
<th>质量评定标准</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>最小角(minimum angle)</td>
<td>所有三角形的内角当中最小的角</td>
</tr>
<tr>
<td>纵横比(aspect ratio)</td>
<td>三角形最短边与最长边的比例</td>
</tr>
<tr>
<td>半径比(radius ratio)</td>
<td>三角形内接圆半径的两倍与外接圆半径的比例</td>
</tr>
</tbody></table>
<blockquote>
<p>参考：</p>
<p>[1] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/459884570">技术分享：Delaunay三角剖分算法介绍 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h2 id="3-Delaunay三角剖分-1"><a href="#3-Delaunay三角剖分-1" class="headerlink" title="3 Delaunay三角剖分"></a>3 Delaunay三角剖分</h2><blockquote>
<p>Delaunay剖分是一种三角剖分的标准。</p>
</blockquote>
<h3 id="3-1-定义-1"><a href="#3-1-定义-1" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p><strong>Delaunay边</strong>：假设$E$（$E$为点集的三角剖分的边集）中的一条边$e$（两个端点分别为$a,b$），$e$为Delaunay边的条件为：存在一个圆经过$a,b$两点，圆内(最多三点共圆)不含点集$P$中任何其他的点，这一特性又称<strong>空圆特性</strong>。</p>
<p><strong>Delaunay三角剖分</strong>：如果点集$P$的一个三角剖分$T$只包含Delaunay边，那么该三角剖分称为Delaunay三角剖分。</p>
<p><strong>Delaunay三角剖分的另一种定义</strong>：因为Delaunay三角剖分与$\text{Voronoi}$图是对偶关系，Delaunay三角剖分是$\text{Voronoi}$图的伴生图形，两者可以相互转化。作$\text{Voronoi}$图的对偶图，即对每条$\text{Voronoi}$边(限有限长线段)作通过点集中某两点的中垂线，得到的即为Delaunay三角剖分。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230524001225163.png" srcset="/img/loading.gif" lazyload alt="image-20230524001225163"></p>
<h3 id="3-2-准则与性质-1"><a href="#3-2-准则与性质-1" class="headerlink" title="3.2 准则与性质"></a>3.2 准则与性质</h3><p>一个三角剖分必须符合以下两条重要准则，才可称之为Delaunay三角剖分。</p>
<ul>
<li><p><strong>空圆特性</strong></p>
<blockquote>
<p>Delaunay三角剖分是唯一的（任意四点不能共圆），在Delaunay三角剖分中任一三角形的外接圆内不会存在其它点。即满足Delaunay边的定义。</p>
</blockquote>
</li>
<li><p><strong>最大化最小角特性</strong></p>
<blockquote>
<p>在点集$P$的所有可能的三角剖分中，Delaunay三角剖分所形成的三角形<strong>最小角</strong>最大。</p>
</blockquote>
</li>
</ul>
<p>Delaunay三角剖分具备以下几点重要的性质：</p>
<p>(1)<strong>唯一性</strong>：无论从点集的任何位置开始建网，最终得到的Delaunay三角剖分都是唯一的。</p>
<p>(2)<strong>最接近</strong>：三角形是以最邻近的三点组成的，并且所形成的三角形的各边都不会相交。 </p>
<p>(3)<strong>最规则</strong>：假如将三角剖分中每个三角形的最小角度按升序进行排列，那么Delaunay三角剖分排列得到的数值最大。</p>
<p>(4)<strong>最优性</strong>：如果任意两个相邻三角形所组成的凸四边形的对角线相互交换，那么交换后两个三角形的六个内角中最小角角度不再增大。 </p>
<p>(5)<strong>区域性</strong>：移动、新增、删除三角剖分中某个顶点时只会影响相邻的三角形。 </p>
<p>(6)<strong>具有凸多边形的外壳</strong>：在所构建的三角剖分中，最外层的边界构成了点集的凸多边形“外壳”（即点集的凸包）。</p>
<h2 id="4-Delaunay三角剖分算法-1"><a href="#4-Delaunay三角剖分算法-1" class="headerlink" title="4 Delaunay三角剖分算法"></a>4 Delaunay三角剖分算法</h2><blockquote>
<p>Delaunay三角剖分的算法可以分为逐点插入法、三角网生长法，分治算法等。分治算法的效率最高，逐点插人法实现简单高效，占用内存较小，但它的时间复杂度差。三角网生长法由于效率相对较低，目前采用较少。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525011734005.png" srcset="/img/loading.gif" lazyload alt="image-20230525011734005"></p>
</blockquote>
<h3 id="4-1-Bowyer-Watson算法-1"><a href="#4-1-Bowyer-Watson算法-1" class="headerlink" title="4.1 Bowyer-Watson算法"></a>4.1 Bowyer-Watson算法</h3><p>Bowyer-Watson算法属于逐点插入法的一种，易于理解和实现。</p>
<h4 id="4-1-1-算法步骤：-1"><a href="#4-1-1-算法步骤：-1" class="headerlink" title="4.1.1 算法步骤："></a>4.1.1 算法步骤：</h4><p>Step1：构造一个包含点集中的所有点的超级三角形（super-triangle），放入三角形列表中；</p>
<blockquote>
<p>这个三角形列表可以理解为一个三角剖分，目前只包含一个三角形，即超级三角形。</p>
</blockquote>
<p>Step2：将点集中的点逐一插入现有的三角剖分中，并进行如下调整：</p>
<ul>
<li><p>在三角形列表中，找出所有外接圆包含该插入点的三角形（称为该点的影响三角形），所有影响三角形的合集构成一个“星形多边形”(star shaped polygon)。星形多边形的含义是多边形的任何一个顶点到插入点的连线都在多边形内部。</p>
</li>
<li><p>对于上述星形多边形，将其内部的三角形全部删除，形成一个“空穴”。将空穴边界的顶点与新插入的点连接得到新的三角形，替代剖分中被删除的三角形，从而完成一个点在Delaunay三角形列表中的插入，得到一个包含插入点的新Delaunay三角剖分。</p>
</li>
</ul>
<blockquote>
<p>还有一种说法是：在三角形列表中，找出其外接圆包含插入点的三角形（称为该点的影响三角形），删除影响三角形的公共边，将插入点同影响三角形的全部顶点连接起来，从而完成一个点在Delaunay三角形列表中的插入。该步骤的图示如下：</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/5.GIF" srcset="/img/loading.gif" lazyload alt="img"></p>
</blockquote>
<p>Step3：循环执行Step2，直到所有点插入完毕。</p>
<p>Step4：最后从三角形列表中删除与超级三角形关联的三角形，得到点集的Delaunay三角剖分。</p>
<h4 id="4-1-2-算法伪代码-1"><a href="#4-1-2-算法伪代码-1" class="headerlink" title="4.1.2 算法伪代码"></a>4.1.2 算法伪代码</h4><p><strong>版本一</strong></p>
<blockquote>
<p> from <a target="_blank" rel="noopener" href="http://paulbourke.net/papers/triangulate/">Triangulate: Pan Pacific Computer Conference, Beijing, China (paulbourke.net)</a></p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab">input : vertex list<br>output : triangle list<br>   initialize the triangle list<br>   determine the supertriangle<br>   add supertriangle vertices to the <span class="hljs-keyword">end</span> of the vertex list<br>   add the supertriangle to the triangle list<br>   <span class="hljs-keyword">for</span> each sample point in the vertex list<br>      initialize the edge buffer<br>      <span class="hljs-keyword">for</span> each triangle currently in the triangle list<br>         calculate the triangle circumcircle center and radius<br>         <span class="hljs-keyword">if</span> the point lies in the triangle circumcircle then<br>            add the three triangle edges to the edge buffer<br>            remove the triangle from the triangle list<br>         endif<br>      endfor<br>      delete all doubly specified edges from the edge buffer<br>         this leaves the edges of the enclosing polygon only<br>      add to the triangle list all triangles formed between the point <br>         and the edges of the enclosing polygon<br>   endfor<br>   remove any triangles from the triangle list that use the supertriangle vertices<br>   remove the supertriangle vertices from the vertex list<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p><strong>版本二</strong></p>
<blockquote>
<p>from <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bowyer%E2%80%93Watson_algorithm">Bowyer–Watson algorithm - Wikipedia</a>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BowyerWatson</span> (<span class="hljs-params">pointList</span>)</span><br><span class="hljs-function">    // <span class="hljs-title">pointList</span> <span class="hljs-title">is</span> <span class="hljs-title">a</span> <span class="hljs-title">set</span> <span class="hljs-title">of</span> <span class="hljs-title">coordinates</span> <span class="hljs-title">defining</span> <span class="hljs-title">the</span> <span class="hljs-title">points</span> <span class="hljs-title">to</span> <span class="hljs-title">be</span> <span class="hljs-title">triangulated</span></span><br><span class="hljs-function">    <span class="hljs-title">triangulation</span> := <span class="hljs-title">empty</span> <span class="hljs-title">triangle</span> <span class="hljs-title">mesh</span> <span class="hljs-title">data</span> <span class="hljs-title">structure</span></span><br><span class="hljs-function">    <span class="hljs-title">add</span> <span class="hljs-title">super</span>-<span class="hljs-title">triangle</span> <span class="hljs-title">to</span> <span class="hljs-title">triangulation</span> // <span class="hljs-title">must</span> <span class="hljs-title">be</span> <span class="hljs-title">large</span> <span class="hljs-title">enough</span> <span class="hljs-title">to</span> <span class="hljs-title">completely</span> <span class="hljs-title">contain</span> <span class="hljs-title">all</span> <span class="hljs-title">the</span> <span class="hljs-title">points</span> <span class="hljs-title">in</span> <span class="hljs-title">pointList</span></span><br><span class="hljs-function">    <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">point</span> <span class="hljs-title">in</span> <span class="hljs-title">pointList</span> <span class="hljs-title">do</span> // <span class="hljs-title">add</span> <span class="hljs-title">all</span> <span class="hljs-title">the</span> <span class="hljs-title">points</span> <span class="hljs-title">one</span> <span class="hljs-title">at</span> <span class="hljs-title">a</span> <span class="hljs-title">time</span> <span class="hljs-title">to</span> <span class="hljs-title">the</span> <span class="hljs-title">triangulation</span></span><br><span class="hljs-function">        <span class="hljs-title">badTriangles</span> := <span class="hljs-title">empty</span> <span class="hljs-title">set</span></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">triangle</span> <span class="hljs-title">in</span> <span class="hljs-title">triangulation</span> <span class="hljs-title">do</span> // <span class="hljs-title">first</span> <span class="hljs-title">find</span> <span class="hljs-title">all</span> <span class="hljs-title">the</span> <span class="hljs-title">triangles</span> <span class="hljs-title">that</span> <span class="hljs-title">are</span> <span class="hljs-title">no</span> <span class="hljs-title">longer</span> <span class="hljs-title">valid</span> <span class="hljs-title">due</span> <span class="hljs-title">to</span> <span class="hljs-title">the</span> <span class="hljs-title">insertion</span></span><br><span class="hljs-function">            <span class="hljs-title">if</span> <span class="hljs-title">point</span> <span class="hljs-title">is</span> <span class="hljs-title">inside</span> <span class="hljs-title">circumcircle</span> <span class="hljs-title">of</span> <span class="hljs-title">triangle</span></span><br><span class="hljs-function">                <span class="hljs-title">add</span> <span class="hljs-title">triangle</span> <span class="hljs-title">to</span> <span class="hljs-title">badTriangles</span></span><br><span class="hljs-function">        <span class="hljs-title">polygon</span> := <span class="hljs-title">empty</span> <span class="hljs-title">set</span></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">triangle</span> <span class="hljs-title">in</span> <span class="hljs-title">badTriangles</span> <span class="hljs-title">do</span> // <span class="hljs-title">find</span> <span class="hljs-title">the</span> <span class="hljs-title">boundary</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">polygonal</span> <span class="hljs-title">hole</span></span><br><span class="hljs-function">            <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">edge</span> <span class="hljs-title">in</span> <span class="hljs-title">triangle</span> <span class="hljs-title">do</span></span><br><span class="hljs-function">                <span class="hljs-title">if</span> <span class="hljs-title">edge</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">shared</span> <span class="hljs-title">by</span> <span class="hljs-title">any</span> <span class="hljs-title">other</span> <span class="hljs-title">triangles</span> <span class="hljs-title">in</span> <span class="hljs-title">badTriangles</span></span><br><span class="hljs-function">                    <span class="hljs-title">add</span> <span class="hljs-title">edge</span> <span class="hljs-title">to</span> <span class="hljs-title">polygon</span></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">triangle</span> <span class="hljs-title">in</span> <span class="hljs-title">badTriangles</span> <span class="hljs-title">do</span> // <span class="hljs-title">remove</span> <span class="hljs-title">them</span> <span class="hljs-title">from</span> <span class="hljs-title">the</span> <span class="hljs-title">data</span> <span class="hljs-title">structure</span></span><br><span class="hljs-function">            <span class="hljs-title">remove</span> <span class="hljs-title">triangle</span> <span class="hljs-title">from</span> <span class="hljs-title">triangulation</span></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">edge</span> <span class="hljs-title">in</span> <span class="hljs-title">polygon</span> <span class="hljs-title">do</span> // <span class="hljs-title">re</span>-<span class="hljs-title">triangulate</span> <span class="hljs-title">the</span> <span class="hljs-title">polygonal</span> <span class="hljs-title">hole</span></span><br><span class="hljs-function">            <span class="hljs-title">newTri</span> := <span class="hljs-title">form</span> <span class="hljs-title">a</span> <span class="hljs-title">triangle</span> <span class="hljs-title">from</span> <span class="hljs-title">edge</span> <span class="hljs-title">to</span> <span class="hljs-title">point</span></span><br><span class="hljs-function">            <span class="hljs-title">add</span> <span class="hljs-title">newTri</span> <span class="hljs-title">to</span> <span class="hljs-title">triangulation</span></span><br><span class="hljs-function">    <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">triangle</span> <span class="hljs-title">in</span> <span class="hljs-title">triangulation</span> // <span class="hljs-title">done</span> <span class="hljs-title">inserting</span> <span class="hljs-title">points</span>, <span class="hljs-title">now</span> <span class="hljs-title">clean</span> <span class="hljs-title">up</span></span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-title">triangle</span> <span class="hljs-title">contains</span> <span class="hljs-title">a</span> <span class="hljs-title">vertex</span> <span class="hljs-title">from</span> <span class="hljs-title">original</span> <span class="hljs-title">super</span>-<span class="hljs-title">triangle</span></span><br><span class="hljs-function">            <span class="hljs-title">remove</span> <span class="hljs-title">triangle</span> <span class="hljs-title">from</span> <span class="hljs-title">triangulation</span></span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">triangulation</span></span><br></code></pre></td></tr></table></figure>

<h4 id="4-1-3-算法解释示例-1"><a href="#4-1-3-算法解释示例-1" class="headerlink" title="4.1.3 算法解释示例"></a>4.1.3 算法解释示例</h4><p>这里我们以A,B,C,D四个点为例，画图说明整个Bowyer-Watson算法的流程。</p>
<ul>
<li><p>首先建立一个超级三角形（p1,p2,p3），这个三角形要把点集中所有的点都包含进去。将这个超级三角形加入三角形列表。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525133130002.png" srcset="/img/loading.gif" lazyload alt="image-20230525133130002"></p>
<blockquote>
<p>关于如何构建超级三角形，详见[4.1.5 实现细节](#4.1.5 实现细节)。</p>
</blockquote>
</li>
<li><p>我们先插入点A，因为原来的三角形列表中唯一的超级三角形外接圆必定包含点A，所以我们可以将三角形▲(p1,p2,p3)看作一个星形多边形，其内部没有三角形，所以我们直接将点A与其顶点相连，将原来的三角形拆分为三个三角形（▲(p1,A,p2），▲(p2,A,p3)，▲(p3,A,p1)）。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525135633264.png" srcset="/img/loading.gif" lazyload alt="image-20230525135633264"></p>
</li>
<li><p>再插入点B，做三角形列表中各个三角形的外接圆，我们找到了点B的影响三角形，即▲(p1,A,p3），▲(p2,A,p3)。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525140915264.png" srcset="/img/loading.gif" lazyload alt="image-20230525140915264"></p>
</li>
<li><p>删除影响三角形组成的星形多边形内部的三角形（公共边，这里即边(A,p3))。然后将点B同影响三角形的全部顶点连接起来。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525141540743.png" srcset="/img/loading.gif" lazyload alt="image-20230525141540743"></p>
</li>
<li><p>接下来再插入点C，同上面插入点B的流程一样，找到影响三角形，删除公共边，连接影响三角形的各个顶点。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142157546.png" srcset="/img/loading.gif" lazyload alt="image-20230525142157546"></p>
</li>
<li><p>然后相同的方法插入点D。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142614560.png" srcset="/img/loading.gif" lazyload alt="image-20230525142614560"></p>
</li>
<li><p>最后删除与超级三角形顶点（p1,p2,p3）相关联的三角形。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142914270.png" srcset="/img/loading.gif" lazyload alt="image-20230525142914270"></p>
</li>
<li><p>最终点A,B,C,D的三角剖分结果如下图。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525143023480.png" srcset="/img/loading.gif" lazyload alt="image-20230525143023480"></p>
</li>
</ul>
<h4 id="4-1-4-算法的优化-1"><a href="#4-1-4-算法的优化-1" class="headerlink" title="4.1.4 算法的优化"></a>4.1.4 算法的优化</h4><p>Bowyer-Watson算法比较耗时的一步是关于新插入点的定位。在上文中，我们通过遍历三角形列表中的所有三角形，然后分别判断插入点是否落在其外接圆内。随着点集规模增大，三角形列表在Delaunay三角剖分的构造过程中会逐渐增大，插入点定位的耗时也会随之增加。因此针对点定位问题，有很多优化的改进算法。</p>
<h5 id="（1）排序优化-1"><a href="#（1）排序优化-1" class="headerlink" title="（1）排序优化"></a>（1）排序优化</h5><p>该算法优化的思路如下：首先将原始点集中的点按x坐标从小到大进行排序。在插入时，不再是随机插入，而是按照排序顺序进行。保证了新插入的点不会出现在之前插入点的左侧。还有一点不同，该算法中除了点集的列表外，还有已确定的三角形列表和未确定的三角形列表。每次对插入点进行定位时，只需要在未确定的三角形列表中对新插入点进行定位计算，而不再对所有生成的三角形进行查询。如个插入点在查询三角形外接圆的右侧，则说明查询三角形为合法的Delaunay三角形，移存到已确定的三角形列表中；若在外接圆外且不在右侧，则说明该查询三角形仍是一个未确定三角形，不进行任何操作；如在外接圆内，则说明该查询三角形不为Delaunay三角形，从未确定三角形列表中移除。</p>
<p><strong>伪代码：</strong></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs glsl">input: 顶点列表(<span class="hljs-keyword">vertices</span>)                                      <span class="hljs-comment">//vertices为外部生成的随机或乱序顶点列表</span><br>output:已确定的三角形列表(<span class="hljs-keyword">triangles</span>)<br>　　　　初始化顶点列表<br>　　　　创建索引列表(indices = new Array(<span class="hljs-keyword">vertices</span>.<span class="hljs-built_in">length</span>))　　　　<span class="hljs-comment">//indices数组中的值为0,1,2,3,......,vertices.length-1</span><br>　　　　基于<span class="hljs-keyword">vertices</span>中的顶点x坐标对indices进行sort　　  　　　　　  <span class="hljs-comment">//sort后的indices值顺序为顶点坐标x从小到大排序（也可对y坐标，本例中针对x坐标）</span><br>　　　　确定超级三角形<br>　　　　将超级三角形保存至未确定三角形列表（temp <span class="hljs-keyword">triangles</span>）<br>　　　　将超级三角形push到<span class="hljs-keyword">triangles</span>列表<br>　　　　遍历基于indices顺序的<span class="hljs-keyword">vertices</span>中每一个点　　　　　　　　　  　<span class="hljs-comment">//基于indices后，则顶点则是由x从小到大出现</span><br>　　　　　　初始化边缓存数组（edge <span class="hljs-keyword">buffer</span>）<br>　　　　　　遍历temp <span class="hljs-keyword">triangles</span>中的每一个三角形<br>　　　　　　　　计算该三角形的圆心和半径<br>　　　　　　　　如果该点在外接圆的右侧<br>　　　　　　　　　　则该三角形为Delaunay三角形，保存到<span class="hljs-keyword">triangles</span><br>　　　　　　　　　　并在temp里去除掉<br>　　　　　　　　　　跳过<br>　　　　　　　　如果该点在外接圆外（即也不是外接圆右侧）<br>　　　　　　　　　　则该三角形为不确定        　　　　　　　　　     <span class="hljs-comment">//后面会在问题中讨论</span><br>　　　　　　　　　　跳过<br>　　　　　　　　如果该点在外接圆内<br>　　　　　　　　　　则该三角形不为Delaunay三角形<br>　　　　　　　　　　将三边保存至edge <span class="hljs-keyword">buffer</span><br>　　　　　　　　　　在temp中去除掉该三角形<br>　　　　　　对edge <span class="hljs-keyword">buffer</span>进行去重<br>　　　　　　将edge <span class="hljs-keyword">buffer</span>中的边与当前的点进行组合成若干三角形并保存至temp <span class="hljs-keyword">triangles</span>中<br>　　　　将<span class="hljs-keyword">triangles</span>与temp <span class="hljs-keyword">triangles</span>进行合并<br>　　　　除去与超级三角形有关的三角形<br>end<br></code></pre></td></tr></table></figure>

<p><strong>细节：</strong></p>
<p>当插入点在查询三角形外接圆右侧时。由于插入点按照x坐标大小从左往右依次插入，所以剩余的其他点都必然在该外接圆的右侧，即该查询三角形满足<strong>空圆特性</strong>，为Delaunay三角形。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160836087924338.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在查询三角形的外接圆中，插入点1时，符合在外侧的条件，但是不能保证后面所有的点都保持在外接圆外侧。如图中的点2及后面可能出现的点很有可能出现在圆内，而使该三角形被按边分解。所以在该优化算法中，如果碰到在点在外侧且非右侧的话，会跳过，该三角形一直在temp triangles中被检验，直到碰到下一个点在圆内或圆右才会从未确定三角形列表中去除，进行后面的操作。</p>
<p>而当点在圆上时，也是根据在圆内的方法对其进行操作，实际情况中会出现这种情况，该现象称为“退化”。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160838043703195.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>参考：</p>
<p>[1] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhiyishou/p/4430017.html">三角剖分算法(delaunay) - 纸异兽 - 博客园 (cnblogs.com)</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://github.com/darkskyapp/delaunay-fast">darkskyapp/delaunay-fast: Fast Delaunay Triangulation in JavaScript. (github.com)</a></p>
</blockquote>
<h5 id="（2）快速点定位-1"><a href="#（2）快速点定位-1" class="headerlink" title="（2）快速点定位"></a>（2）快速点定位</h5><p><font color=orange size=4><b>TODO:</b></font></p>
<blockquote>
<p>参考：</p>
<p>[1] <a target="_blank" rel="noopener" href="https://blog.csdn.net/whb12345678feng/article/details/108110918">计算几何学习——点定位_Mathematic_feng的博客-CSDN博客</a></p>
<p>[2] 刘琴琴.平面域Delaunay三角网点定位算法研究综述[J].电子设计工程,2017,25(01):47-51.DOI:10.14022/j.cnki.dzsjgc.2017.01.012.</p>
<p>[3] 伯格 著, 邓俊辉. 计算几何:算法与应用(第3版)[M]. 清华大学出版社, 2009.</p>
</blockquote>
<h4 id="4-1-5-实现细节-1"><a href="#4-1-5-实现细节-1" class="headerlink" title="4.1.5 实现细节"></a>4.1.5 实现细节</h4><h5 id="（1）构造超级三角形-1"><a href="#（1）构造超级三角形-1" class="headerlink" title="（1）构造超级三角形"></a>（1）构造超级三角形</h5><p><strong>方法一：</strong></p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525231438652.png" srcset="/img/loading.gif" lazyload alt="image-20230525231438652"></p>
<blockquote>
<p>其中绿色四边形为点集的包围盒。</p>
</blockquote>
<p><strong>方法二：</strong></p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160718101043903.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>根据相似三角形定理求得与矩形一半的小矩形的对角三角形，扩大一倍后则扩大后的直角三角形斜边经过点(Xmax,Ymin)。为了将所有的点包含在超级三角形内，在右下角对该三角形的顶点进行了横和高的扩展，并要保证这个扩展三角形底大于高。</p>
<blockquote>
<p>参考自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhiyishou/p/4430017.html">三角剖分算法(delaunay) - 纸异兽 - 博客园 (cnblogs.com)</a></p>
</blockquote>
<p><strong>其他方法：</strong></p>
<p>上面两种方法的初始化图形都是一个三角形。除此之外，还有学者提出使用一个包含所有点的初始矩形，然后将矩形的任意一条对角线连接，划分为两个三角形加入初始三角剖分列表中。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525232322324.png" srcset="/img/loading.gif" lazyload alt="image-20230525232322324"></p>
<p>上图中，$\text{K}$为一个正位移值。</p>
<h5 id="（2）计算三角形外接圆圆心和半径-1"><a href="#（2）计算三角形外接圆圆心和半径-1" class="headerlink" title="（2）计算三角形外接圆圆心和半径"></a>（2）计算三角形外接圆圆心和半径</h5><blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Circumscribed_circle#Circumcircle_equations">https://en.wikipedia.org/wiki/Circumscribed_circle#Circumcircle_equations</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Circumscribed_circle#Circumcenter_coordinates">https://en.wikipedia.org/wiki/Circumscribed_circle#Circumcenter_coordinates</a></p>
</blockquote>
<p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20230527102334838.png" srcset="/img/loading.gif" lazyload alt="image-20230527102334838"></p>
<p>求出外接圆圆心坐标后，圆心与三角形任一顶点的距离即是外接圆半径。</p>
<blockquote>
<p>如果三点共线，那么其外接圆圆心将在无穷远处。</p>
</blockquote>
<h4 id="4-1-6-代码实现-1"><a href="#4-1-6-代码实现-1" class="headerlink" title="4.1.6 代码实现"></a>4.1.6 代码实现</h4><p>首先定义点、边、三角形的数据结构。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">float</span>, y: <span class="hljs-built_in">float</span></span>):</span><br>        self.x = x<br>        self.y = y<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__eq__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">return</span> self.x == other.x <span class="hljs-keyword">and</span> self.y == other.y<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dist2</span>(<span class="hljs-params">self, other</span>) -&gt; <span class="hljs-built_in">float</span>:</span><br>        <span class="hljs-keyword">return</span> (self.x - other.x) * (self.x - other.x) + (self.y - other.y) * (self.y - other.y)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isInCircumcircleOf</span>(<span class="hljs-params">self, t</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>        A, B, C = t.verticies[<span class="hljs-number">0</span>], t.verticies[<span class="hljs-number">1</span>], t.verticies[<span class="hljs-number">2</span>]<br>        a2 = A.x * A.x + A.y * A.y<br>        b2 = B.x * B.x + B.y * B.y<br>        c2 = C.x * C.x + C.y * C.y<br>        D = <span class="hljs-number">2.0</span> * (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y))<br>        center_x = (a2 * (B.y - C.y) + b2 * (C.y - A.y) + c2 * (A.y - B.y)) / D<br>        center_y = (a2 * (C.x - B.x) + b2 * (A.x - C.x) + c2 * (B.x - A.x)) / D<br>        center = Point(center_x, center_y)<br>        <span class="hljs-keyword">return</span> self.dist2(center) &lt;= A.dist2(center)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, begin: Point, end: Point</span>):</span><br>        self.begin = begin<br>        self.end = end<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__eq__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">return</span> (self.begin == other.begin <span class="hljs-keyword">and</span> self.end == other.end) <span class="hljs-keyword">or</span> (<br>                self.begin == other.end <span class="hljs-keyword">and</span> self.end == other.begin)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, A: Point, B: Point, C: Point</span>):</span><br>        self.verticies = [A, B, C]<br>        self.edges = [Edge(A, B), Edge(B, C), Edge(C, A)]<br></code></pre></td></tr></table></figure>

<p>然后定义一个用于delaunay三角剖分的类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Delaunay_Triangulation</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Bowyer Watson Algorithm&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[Point]</span>):</span><br>        self.points: <span class="hljs-type">List</span>[Point] = points<br>        self.super_triangle = self.getSuperTriangle()<br>        self.triangles: <span class="hljs-type">List</span>[Triangle] = [self.super_triangle]  <span class="hljs-comment"># add super-triangle to triangulation</span><br>        <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> points:  <span class="hljs-comment"># add all the initial points one at a time to the triangulation</span><br>            self.addPoint(point)<br>        self.removeSuperTriangle()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getSuperTriangle</span>(<span class="hljs-params">self</span>) -&gt; Triangle:</span><br>        sorted_x = <span class="hljs-built_in">sorted</span>(self.points, key = <span class="hljs-keyword">lambda</span> p: p.x)<br>        sorted_y = <span class="hljs-built_in">sorted</span>(self.points, key = <span class="hljs-keyword">lambda</span> p: p.y)<br>        xmin, xmax = sorted_x[<span class="hljs-number">0</span>].x, sorted_x[-<span class="hljs-number">1</span>].x<br>        ymin, ymax = sorted_y[<span class="hljs-number">0</span>].y, sorted_y[-<span class="hljs-number">1</span>].y<br>        dx, dy = xmax - xmin, ymax - ymin<br>        dmax = <span class="hljs-built_in">max</span>(dx, dy)<br>        xmid = xmin + dx * <span class="hljs-number">0.5</span><br>        ymid = ymin + dy * <span class="hljs-number">0.5</span><br><br>        <span class="hljs-keyword">return</span> Triangle(Point(xmid - <span class="hljs-number">20</span> * dmax, ymid - dmax),<br>                        Point(xmid, ymid + <span class="hljs-number">20</span> * dmax),<br>                        Point(xmid + <span class="hljs-number">20</span> * dmax, ymid - dmax))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addPoint</span>(<span class="hljs-params">self, point: Point</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        bad_triangles: <span class="hljs-type">List</span>[Triangle] = []<br>        <span class="hljs-comment"># first find all the triangles that are no longer valid due to the insertion</span><br>        <span class="hljs-keyword">for</span> triangle <span class="hljs-keyword">in</span> self.triangles:<br>            <span class="hljs-keyword">if</span> point.isInCircumcircleOf(triangle):<br>                bad_triangles.append(triangle)<br><br>        polygon: <span class="hljs-type">List</span>[Edge] = []<br>        <span class="hljs-comment"># Find the boundary of the polygonal hole</span><br>        <span class="hljs-keyword">for</span> triangle1 <span class="hljs-keyword">in</span> bad_triangles:<br>            <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> triangle1.edges:<br>                edge_shared = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">for</span> triangle2 <span class="hljs-keyword">in</span> bad_triangles:<br>                    <span class="hljs-keyword">if</span> triangle1 == triangle2:<br>                        <span class="hljs-keyword">continue</span><br>                    <span class="hljs-keyword">if</span> edge <span class="hljs-keyword">in</span> triangle2.edges:<br>                        edge_shared = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> edge_shared:<br>                    polygon.append(edge)<br><br>        <span class="hljs-comment"># Remove broken triangles from the triangulation list</span><br>        <span class="hljs-keyword">for</span> triangle <span class="hljs-keyword">in</span> bad_triangles:<br>            self.triangles.remove(triangle)<br><br>        <span class="hljs-comment"># Create triangles with the newly created edges</span><br>        <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> polygon:<br>            new_triangle = Triangle(edge.begin, edge.end, point)<br>            self.triangles.append(new_triangle)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeSuperTriangle</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-comment"># Remove the triangles that has connection to the super-triangle</span><br>        super_verticies = self.super_triangle.verticies<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.triangles) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            triangle = self.triangles[i]<br>            has_common = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">for</span> vertex1 <span class="hljs-keyword">in</span> triangle.verticies:<br>                <span class="hljs-keyword">for</span> vertex2 <span class="hljs-keyword">in</span> super_verticies:<br>                    <span class="hljs-keyword">if</span> vertex1 == vertex2:<br>                        has_common = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> has_common:<br>                self.triangles.remove(triangle)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exportTriangles</span>(<span class="hljs-params">self</span>):</span><br>        ps = [p <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> self.triangles <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> t.verticies]<br>        xs = [p.x <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> ps]<br>        ys = [p.y <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> ps]<br>        ts = [(ps.index(t.verticies[<span class="hljs-number">0</span>]), ps.index(t.verticies[<span class="hljs-number">1</span>]), ps.index(t.verticies[<span class="hljs-number">2</span>])) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> self.triangles]<br>        <span class="hljs-keyword">return</span> xs, ys, ts<br></code></pre></td></tr></table></figure>

<p>其中<code>exportTriangles</code>函数用于导出matplotlib库绘制剖分结果所需的数据。算法测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint, seed<br><span class="hljs-keyword">from</span> Delaunay_Triangulation <span class="hljs-keyword">import</span> Delaunay_Triangulation, Point<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    seed(<span class="hljs-number">5</span>)<br>    n = <span class="hljs-number">10</span><br>    xs = [randint(<span class="hljs-number">1</span>, <span class="hljs-number">98</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    ys = [randint(<span class="hljs-number">1</span>, <span class="hljs-number">98</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    seted_points = <span class="hljs-built_in">set</span>(<span class="hljs-built_in">zip</span>(xs, ys))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The actual number of input points: &quot;</span>, <span class="hljs-built_in">len</span>(seted_points))<br>    points = [Point(x, y) <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> seted_points]<br>    start_time = time.time()<br>    dt = Delaunay_Triangulation(points)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Triangulating <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(seted_points)&#125;</span> points takes <span class="hljs-subst">&#123;time.time() - start_time&#125;</span> s&quot;</span>)<br>    <span class="hljs-comment"># number of DT triangles</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(dt.triangles), <span class="hljs-string">&quot;Delaunay triangles&quot;</span>)<br><br>    <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>    <span class="hljs-keyword">import</span> matplotlib.tri <span class="hljs-keyword">as</span> tri<br><br>    <span class="hljs-comment"># Plot the triangulation.</span><br>    fig, ax = plt.subplots()<br>    ax.margins(<span class="hljs-number">0.1</span>)<br>    ax.set_aspect(<span class="hljs-string">&#x27;equal&#x27;</span>)<br>    xs1, ys1, ts = dt.exportTriangles()<br>    ax.triplot(tri.Triangulation(xs1, ys1, ts), <span class="hljs-string">&#x27;bo-&#x27;</span>)<br>    triang = tri.Triangulation(xs, ys)<br>    ax.triplot(triang, <span class="hljs-string">&#x27;ro-&#x27;</span>)<br>    ax.set_title(<span class="hljs-string">&#x27;triplot of Delaunay triangulation&#x27;</span>)<br>    plt.show()<br></code></pre></td></tr></table></figure>

<p>其中<code>seted_points = set(zip(xs, ys))</code>用于去除随机生成点集中的重复点，满足输入点集的坐标互异要求。否则，若随机生成的两点坐标相同，在计算点外接圆时，如下代码中，D为0，会抛出<code>ZeroDivisionError: division by zero</code>异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">D = <span class="hljs-number">2.0</span> * (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y))<br>center_x = (a2 * (B.y - C.y) + b2 * (C.y - A.y) + c2 * (A.y - B.y)) / D<br>center_y = (a2 * (C.x - B.x) + b2 * (A.x - C.x) + c2 * (B.x - A.x)) / D<br></code></pre></td></tr></table></figure>

<p>如下两行代码的作用是，调用<code>matplotlib.tri.Triangulation</code>构建三角剖分。用两种不同的颜色分别绘制我们编写的代码和调用第三方库函数进行三角剖分的结果，可以验证算法的正确性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">triang = tri.Triangulation(xs, ys)<br>ax.triplot(triang, <span class="hljs-string">&#x27;ro-&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205450735.png" srcset="/img/loading.gif" lazyload alt="image-20230528205450735"></p>
<p>经过测试发现，<code>matplotlib.tri.Triangulation</code>函数得到的三角剖分在随机生成点集数量比较大时，会和本算法的剖分结果有差异。</p>
<p><code>matplotlib.tri.Triangulation</code>函数剖分结果：</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205916411.png" srcset="/img/loading.gif" lazyload alt="image-20230528205916411"></p>
<p>我们编写的<code>Delaunay_Triangulation</code>类的剖分结果：</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205904484.png" srcset="/img/loading.gif" lazyload alt="image-20230528205904484"></p>
<p>出现这种问题的原因，我猜测可能是因为某四点共圆了。</p>
<blockquote>
<p>在Delaunay三角剖分的性质中，若点集$P$中任意四点不共圆，则存在唯一的Delaunay三角剖分$T$。若点集$P$中四点$A,B,C,D$共圆，且△ABC,△BCD属于Delaunay三角剖分T，那么将边$BC$翻转后得到的三角剖分$T’$(包含△ABD,△ACD)同样是一个Delaunay三角剖分。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/459884570">技术分享：Delaunay三角剖分算法介绍 - 知乎 (zhihu.com)</a></p>
</blockquote>
<p>通过输入一系列共圆点，得到下图结果。两种都属于Delaunay三角剖分。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230529004839957.png" srcset="/img/loading.gif" lazyload alt="image-20230529004839957"></p>
<p>在效率上，测试了三组数据。结果如下：</p>
<table>
<thead>
<tr>
<th>点集规模/个</th>
<th>耗时/s</th>
</tr>
</thead>
<tbody><tr>
<td>1000</td>
<td>4</td>
</tr>
<tr>
<td>4000</td>
<td>60</td>
</tr>
<tr>
<td>6000</td>
<td>150</td>
</tr>
</tbody></table>
<p>时间复杂度大概为$O(n^2)$，$n$为点集大小。</p>
<h3 id="4-2-分治法-1"><a href="#4-2-分治法-1" class="headerlink" title="4.2 分治法"></a>4.2 分治法</h3><blockquote>
<p>参考文献：</p>
<p><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/282918.282923">[1] Guibas L, Stolfi J. Primitives for the manipulation of general subdivisions and the computation of Voronoi[J]. ACM Transactions on Graphics, 1985, 4(2): 74–123.</a></p>
<p>L. Guibas 和 J. Stolfi 提出了Quad-Edge数据结构，并使用其简化了1975年Shamos和Hoey提出的Delaunay三角剖分分治算法。在上述的参考文献中，作者专门用了一节对分治法三角剖分进行介绍，并附有详细的伪代码。</p>
</blockquote>
<h4 id="4-2-1-Quad-Edge-1"><a href="#4-2-1-Quad-Edge-1" class="headerlink" title="4.2.1 Quad-Edge"></a>4.2.1 Quad-Edge</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/afs/andrew/scs/cs/15-463/2001/pub/src/a2/quadedge.html#guibas">Quad-Edge Data Structure and Library (cmu.edu)</a></p>
</blockquote>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/edge.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vertex</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y, _id = <span class="hljs-literal">None</span></span>):</span><br>        self.<span class="hljs-built_in">id</span> = _<span class="hljs-built_in">id</span><br>        self.x = x<br>        self.y = y<br><br>        self.name = <span class="hljs-string">f&#x27;v_<span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>&#x27;</span>  <span class="hljs-comment"># for debugging</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quad_Edge</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;A directed edge: org -&gt; dest.</span><br><span class="hljs-string">    When traversing edge ring: Next is CCW, Prev is CW.&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, org, dest</span>):</span><br>        self.org = org  <span class="hljs-comment"># Origin</span><br>        self.dest = dest  <span class="hljs-comment"># Destination</span><br>        self.onext = <span class="hljs-literal">None</span>  <span class="hljs-comment"># next edge around origin,with same origin</span><br>        self.oprev = <span class="hljs-literal">None</span>  <span class="hljs-comment"># prev edge around origin,with same origin</span><br>        self.sym = <span class="hljs-literal">None</span>  <span class="hljs-comment"># edge pointing opposite dest this edge</span><br>        self.deleted = <span class="hljs-literal">False</span>  <span class="hljs-comment"># Deleted flag</span><br><br>        self.name = <span class="hljs-string">f&#x27;e_<span class="hljs-subst">&#123;self.org.<span class="hljs-built_in">id</span>&#125;</span>_<span class="hljs-subst">&#123;self.dest.<span class="hljs-built_in">id</span>&#125;</span>&#x27;</span>  <span class="hljs-comment"># for debugging</span><br></code></pre></td></tr></table></figure>

<p>分治法三角剖分中我们使用Quad-Edge作为边的数据结构。下面我们将介绍一些边的拓扑操作。</p>
<blockquote>
<p>Reference: <a target="_blank" rel="noopener" href="https://github.com/alexbaryzhikov/triangulation">https://github.com/alexbaryzhikov/triangulation</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_edge</span>(<span class="hljs-params">org, dest, edges</span>) -&gt; Quad_Edge:</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Creates an edge, add it dest edges, and return it.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    e = Quad_Edge(org, dest)<br>    es = Quad_Edge(dest, org)<br>    e.sym, es.sym = es, e  <span class="hljs-comment"># make edges mutually symmetrical</span><br>    e.onext, e.oprev = e, e<br>    es.onext, es.oprev = es, es<br>    edges.append(e)<br>    <span class="hljs-keyword">return</span> e<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_next_prev</span>(<span class="hljs-params">e1: Quad_Edge, e2: Quad_Edge</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Either combines e1 and e2 into a single edge, or seperates them.</span><br><span class="hljs-string">    Which one is determined by the orientation of e1 and e2.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> e1 == e2:<br>        <span class="hljs-keyword">return</span><br>    e1.onext.oprev = e2<br>    e2.onext.oprev = e1<br>    <span class="hljs-comment"># Swap a.onext and b.onext</span><br>    e1.onext, e2.onext = e2.onext, e1.onext<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connect</span>(<span class="hljs-params">e1: Quad_Edge, e2: Quad_Edge, edges</span>) -&gt; Quad_Edge:</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Connecting destination of e1 with the origin of e2 with an edge</span><br><span class="hljs-string">    O(1) time and O(1) space</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    e = create_edge(e1.dest, e2.org, edges)<br>    <span class="hljs-comment"># Maintain the onext and oprev values</span><br>    update_next_prev(e, e1.sym.oprev)<br>    update_next_prev(e.sym, e2)<br>    <span class="hljs-keyword">return</span> e<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mark_edge_deleted</span>(<span class="hljs-params">e: Quad_Edge</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Delete edge from the edge list</span><br><span class="hljs-string">    O(1) time and O(1) space</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># Update the e.onext&#x27; and e.oprev&#x27;s values</span><br>    update_next_prev(e, e.oprev)<br>    update_next_prev(e.sym, e.sym.oprev)<br>    <span class="hljs-comment"># Mark the edge dest be deleted</span><br>    e.deleted = <span class="hljs-literal">True</span><br>    e.sym.deleted = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>

<h5 id="（1）create-edge-org-dest-edges-1"><a href="#（1）create-edge-org-dest-edges-1" class="headerlink" title="（1）create_edge(org, dest, edges)"></a>（1）create_edge(org, dest, edges)</h5><p>该函数用于返回以<code>org</code>为起点，<code>dest</code>为终点的边（这里及[本节](#4.2.1 Quad-Edge)中提到的边都指Quad-Edge），同时将这条边放入<code>edges</code>列表中。我们在该函数中初始化了新生成边的对称边，并且正确初始化了新边及其对称边的<code>onext</code>和<code>oprev</code>属性，因为新边未与任何其他边建立拓扑联系，所以这两个属性都是这两条边自身。具体实现细节参见文章^[1]^中提出的<code>MakeEdge</code>操作。</p>
<h5 id="（2）update-next-prev-e1-e2-1"><a href="#（2）update-next-prev-e1-e2-1" class="headerlink" title="（2）update_next_prev(e1, e2)"></a>（2）update_next_prev(e1, e2)</h5><p>该函数用于<strong>拼接</strong>e1边和e2边，实质上是更新了两条边的<code>onext</code>和<code>oprev</code>属性。具体实现细节参见文章^[1]^中提出的<code>Splice</code>操作。</p>
<h5 id="（3）connect-e1-e2-edges-1"><a href="#（3）connect-e1-e2-edges-1" class="headerlink" title="（3）connect(e1, e2, edges)"></a>（3）connect(e1, e2, edges)</h5><p>该函数使用一条新边连接e1边和e2边，并更新三者的拓扑关系。具体实现细节参见文章^[1]^中提出的<code>Connect</code>操作。</p>
<h5 id="（4）mark-edge-deleted-e-1"><a href="#（4）mark-edge-deleted-e-1" class="headerlink" title="（4）mark_edge_deleted(e)"></a>（4）mark_edge_deleted(e)</h5><p>该函数用于删除一条边，本质上是改变删除边和其他边的拓扑关系。具体实现细节参见文章^[1]^中提出的<code>DeleteEdge</code>操作。</p>
<h4 id="4-2-2-DCEL-1"><a href="#4-2-2-DCEL-1" class="headerlink" title="4.2.2 DCEL"></a>4.2.2 DCEL</h4><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13o4y1Q7eH/">https://www.bilibili.com/video/BV13o4y1Q7eH/</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;A sample implementation of the DCEL structure in Python&quot;&quot;&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vertex</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y</span>):</span><br>        self.x = x<br>        self.y = y<br>        self.coordinates = [x, y]  <span class="hljs-comment"># 顶点坐标</span><br>        self.incidentEdge = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 以该顶点为起点的半边</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Face</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.outerComponent = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 外边界上的某一条半边</span><br>        self.innerComponents = []  <span class="hljs-comment"># 内部包含的孔洞列表，其中每个孔洞用一条半边代表</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HalfEdge</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, origin = <span class="hljs-literal">None</span>, incidentFace = <span class="hljs-literal">None</span></span>):</span><br>        self.origin = origin  <span class="hljs-comment"># 半边的起始顶点</span><br>        self.twin = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 孪生半边</span><br>        self.incidentFace = incidentFace  <span class="hljs-comment"># 该半边指向的平面</span><br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 下一条半边</span><br>        self.prev = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 前一条半边</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DCEL</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, vertices = <span class="hljs-literal">None</span>, faces = <span class="hljs-literal">None</span>, half_edges = <span class="hljs-literal">None</span></span>):</span><br>        self.vertices = vertices<br>        self.faces = faces<br>        self.halfEdges = half_edges<br></code></pre></td></tr></table></figure>

<h4 id="4-2-3-工具算法-1"><a href="#4-2-3-工具算法-1" class="headerlink" title="4.2.3 工具算法"></a>4.2.3 工具算法</h4><h5 id="（1）判断点是否在三角形外接圆内-1"><a href="#（1）判断点是否在三角形外接圆内-1" class="headerlink" title="（1）判断点是否在三角形外接圆内"></a>（1）判断点是否在三角形外接圆内</h5><p>点$d$在三角形$(a,b,c)$外接圆内满足如下不等式：<br>$$<br>ret =\begin{vmatrix}a_x&amp;a_y&amp;a_x^2+a_y^2&amp;1\[0.3em]b_x&amp;b_y&amp;b_x^2+b_y^2&amp;1\[0.3em]c_x&amp;c_y&amp;c_x^2+c_y^2&amp;1\[0.3em]d_x&amp;d_y&amp;d_x^2+d_y^2&amp;1\end{vmatrix}&gt;0\tag{4-1}<br>$$<br>行列式每行减去第四行，得：<br>$$<br>ret =\begin{vmatrix}a_x-d_x&amp;a_y-d_y&amp;a_x^2+a_y^2-(d_x^2+d_y^2)&amp;0\[0.3em]b_x-d_x&amp;b_y-d_y&amp;b_x^2+b_y^2-(d_x^2+d_y^2)&amp;0\[0.3em]c_x-d_x&amp;c_y-d_y&amp;c_x^2+c_y^2-(d_x^2+d_y^2)&amp;0\[0.3em]d_x&amp;d_y&amp;d_x^2+d_y^2&amp;1\end{vmatrix}&gt;0\tag{4-2}<br>$$<br>简化得到下式：<br>$$<br>ret =\begin{vmatrix}a_x-d_x&amp;a_y-d_y&amp;a_x^2+a_y^2-(d_x^2+d_y^2)\[0.3em]b_x-d_x&amp;b_y-d_y&amp;b_x^2+b_y^2-(d_x^2+d_y^2)\[0.3em]c_x-d_x&amp;c_y-d_y&amp;c_x^2+c_y^2-(d_x^2+d_y^2)\end{vmatrix}&gt;0\tag{4-3}<br>$$<br>接下来，将式（4-3）中行列式第三列加上第一列和第二列的$-2d_x$倍，然后将第三列元素整理化成平方差形式，得到下式：<br>$$<br>ret =\begin{vmatrix}a_x-d_x&amp;a_y-d_y&amp;(a_x-d_x)^2+(a_y-d_y)^2\[0.3em]b_x-d_x&amp;b_y-d_y&amp;(b_x-d_x)^2+(b_y-d_y)^2\[0.3em]c_x-d_x&amp;c_y-d_y&amp;(c_x-d_x)^2+(c_y-d_y)^2\end{vmatrix}&gt;0\tag{4-4}<br>$$<br>形如$ad_x=a_x-d_x$替换相同元，得到下式：<br>$$<br>ret =\begin{vmatrix}ad_x&amp;ad_y&amp;ad_x^2+ad_y^2\[0.3em]bd_x&amp;bd_y&amp;bd_x^2+bd_y^2\[0.3em]cd_x&amp;cd_y&amp;cd_x^2+cd_y^2\end{vmatrix}&gt;0\tag{4-5}<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inCircle</span>(<span class="hljs-params">a: Vertex, b: Vertex, c: Vertex, d: Vertex</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;判断点d是否在由a,b,c构成的三角形外接圆内&quot;&quot;&quot;</span><br>    adx = a.x - d.x<br>    ady = a.y - d.y<br>    bdx = b.x - d.x<br>    bdy = b.y - d.y<br>    cdx = c.x - d.x<br>    cdy = c.y - d.y<br><br>    alift = adx * adx + ady * ady<br>    blift = bdx * bdx + bdy * bdy<br>    clift = cdx * cdx + cdy * cdy<br>    <br>    <span class="hljs-keyword">return</span> alift * (bdx * cdy - cdx * bdy) + blift * (cdx * ady - adx * cdy) + clift * (adx * bdy - bdx * ady) &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h5 id="（2）判断点与边的相对位置-1"><a href="#（2）判断点与边的相对位置-1" class="headerlink" title="（2）判断点与边的相对位置"></a>（2）判断点与边的相对位置</h5><p>设边的起点$a$，终点$b$，输入点为$p$。<br>$$<br>det=\begin{vmatrix}a_x&amp;a_y&amp;1\[0.3em]b_x&amp;b_y&amp;1\[0.3em]p_x&amp;p_y&amp;1\end{vmatrix}\tag{4-6}<br>$$</p>
<p>$$<br>det=(a_x-p_x)(b_y-p_y)-(a_y-p_y)(b_x-p_x)\tag{4-7}<br>$$</p>
<ul>
<li>$det&gt;0$，$p$在边左边；</li>
<li>$det&lt;0$，$p$在边右边；</li>
<li>$det=0$，$p$在边共线。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">left_test</span>(<span class="hljs-params">p, e</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Left test for point p relative to the line of edge e.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    a, b = e.org, e.sym.org<br>    det1 = (a.x - p.x) * (b.y - p.y)<br>    det2 = (a.y - p.y) * (b.x - p.x)<br>    <span class="hljs-keyword">return</span> det1 - det2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toRight</span>(<span class="hljs-params">p, e</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Does point p lie to the right of the line of edge e?&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> left_test(p, e) &lt; <span class="hljs-number">0</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toLeft</span>(<span class="hljs-params">p, e</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Does point p lie to the left of the line of edge e?&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> left_test(p, e) &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h4 id="4-2-4-主要程序-1"><a href="#4-2-4-主要程序-1" class="headerlink" title="4.2.4 主要程序"></a>4.2.4 主要程序</h4><p><strong>算法伪代码：</strong></p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230606140652092.png" srcset="/img/loading.gif" lazyload alt="image-20230606140652092"></p>
<p><strong>主程序：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Divide_Delaunay</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Triangulate the points using the divide and conquer delaunay triangulation algorithm.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, points</span>):</span><br>        self.points = points<br>        self.verticies = []<br>        self.init_points()  <span class="hljs-comment"># 初始化点集</span><br>        self.edges = []<br>        self.div_and_conq_triangulate(self.verticies)  <span class="hljs-comment"># 分治法构造三角网</span><br><br>        <span class="hljs-comment"># Remove edges that are not part of the triangulation</span><br>        self.edges = [e <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> self.edges <span class="hljs-keyword">if</span> e.deleted <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_points</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># Validate the input size</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.points) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># Sort points by x coordinate, y is a tiebreaker</span><br>        self.points.sort(key = <span class="hljs-keyword">lambda</span> point: (point[<span class="hljs-number">0</span>], point[<span class="hljs-number">1</span>]))<br><br>        <span class="hljs-comment"># Remove duplicates</span><br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(self.points) - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> self.points[i] == self.points[i + <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">del</span> self.points[i]<br>            <span class="hljs-keyword">else</span>:<br>                i += <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># Vertex naming</span><br>        <span class="hljs-keyword">for</span> i, point <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.points):<br>            self.verticies.append(Vertex(point[<span class="hljs-number">0</span>], point[<span class="hljs-number">1</span>], i))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">div_and_conq_triangulate</span>(<span class="hljs-params">self, points</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Computes the Delaunay triangulation of self.points and returns two edges, le and re,</span><br><span class="hljs-string">        which are the counterclockwise convex hull edge out of the leftmost vertex and the clockwise</span><br><span class="hljs-string">        convex hull edge out of the rightmost vertex, respectively.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(points)<br>        <span class="hljs-comment"># Base case: 2 points</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:<br>            edge = create_edge(points[<span class="hljs-number">0</span>], points[<span class="hljs-number">1</span>], self.edges)<br>            <span class="hljs-keyword">return</span> edge, edge.sym<br><br>        <span class="hljs-comment"># Base case: 3 points</span><br>        <span class="hljs-keyword">elif</span> n == <span class="hljs-number">3</span>:<br>            <span class="hljs-comment"># Create edge S[0]-S[1] and edge S[1]-S[2]</span><br>            edge1 = create_edge(points[<span class="hljs-number">0</span>], points[<span class="hljs-number">1</span>], self.edges)<br>            edge2 = create_edge(points[<span class="hljs-number">1</span>], points[<span class="hljs-number">2</span>], self.edges)<br>            update_next_prev(edge1.sym, edge2)<br><br>            <span class="hljs-comment"># Create edge S[2]-S[0]</span><br>            <span class="hljs-keyword">if</span> toRight(points[<span class="hljs-number">2</span>], edge1):  <span class="hljs-comment"># Right</span><br>                connect(edge2, edge1, self.edges)<br>                <span class="hljs-keyword">return</span> edge1, edge2.sym<br>            <span class="hljs-keyword">elif</span> toLeft(points[<span class="hljs-number">2</span>], edge1):  <span class="hljs-comment"># Left</span><br>                edge3 = connect(edge2, edge1, self.edges)<br>                <span class="hljs-keyword">return</span> edge3.sym, edge3<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># Points are linear</span><br>                <span class="hljs-keyword">return</span> edge1, edge2.sym<br><br>        <span class="hljs-comment"># Recurively triangulate the left and right halves</span><br>        <span class="hljs-keyword">else</span>:<br>            m = n // <span class="hljs-number">2</span><br>            ldo, ldi = self.div_and_conq_triangulate(points[:m])<br>            rdi, rdo = self.div_and_conq_triangulate(points[m:])<br>            ldo_r, rdo_r = self.merge(ldo, ldi, rdi, rdo)<br><br>            <span class="hljs-keyword">return</span> ldo_r, rdo_r<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">self, ldo, ldi, rdi, rdo</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Takes 2 halves of the triangulation and merges them into a single triangulation.</span><br><span class="hljs-string">        While doing so it uses previosly calculated values of these halves.</span><br><span class="hljs-string">        Reference: https://github.com/alexbaryzhikov/triangulation</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># Compute the upper common tangent of L and R.</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> toRight(rdi.org, ldi):<br>                <span class="hljs-comment"># Advance dest the next edge on the convex hull of L.</span><br>                ldi = ldi.sym.onext<br>            <span class="hljs-keyword">elif</span> toLeft(ldi.org, rdi):<br>                <span class="hljs-comment"># Advance dest the next edge on the convex hull of R.</span><br>                rdi = rdi.sym.oprev<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br><br>        <span class="hljs-comment"># Create a first cross edge base.</span><br>        base = connect(ldi.sym, rdi, self.edges)<br><br>        <span class="hljs-comment"># Adjust ldo and rdo</span><br>        <span class="hljs-keyword">if</span> ldi.org.x == ldo.org.x <span class="hljs-keyword">and</span> ldi.org.y == ldo.org.y:<br>            ldo = base<br>        <span class="hljs-keyword">if</span> rdi.org.x == rdo.org.x <span class="hljs-keyword">and</span> rdi.org.y == rdo.org.y:<br>            rdo = base.sym<br><br>        <span class="hljs-comment"># Merge two halves</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># Locate the first R and L points dest be encountered by the diving bubble.</span><br>            rcand, lcand = base.sym.onext, base.oprev<br><br>            <span class="hljs-comment"># If both lcand and rcand are invalid, then base is the lower common tangent.</span><br>            v_rcand, v_lcand = toRight(rcand.dest, base), toRight(lcand.dest, base)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (v_rcand <span class="hljs-keyword">or</span> v_lcand):<br>                <span class="hljs-keyword">break</span><br><br>            <span class="hljs-comment"># Delete R edges out of base.dest that fail the circle test.</span><br>            <span class="hljs-keyword">if</span> v_rcand:<br>                <span class="hljs-keyword">while</span> toRight(rcand.onext.dest, base) <span class="hljs-keyword">and</span> inCircle(base.dest, base.org, rcand.dest, rcand.onext.dest):<br>                    t = rcand.onext<br>                    mark_edge_deleted(rcand)<br>                    rcand = t<br><br>            <span class="hljs-comment"># Symmetrically, delete L edges.</span><br>            <span class="hljs-keyword">if</span> v_lcand:<br>                <span class="hljs-keyword">while</span> toRight(lcand.oprev.dest, base) <span class="hljs-keyword">and</span> inCircle(base.dest, base.org, lcand.dest, lcand.oprev.dest):<br>                    t = lcand.oprev<br>                    mark_edge_deleted(lcand)<br>                    lcand = t<br><br>            <span class="hljs-comment"># The next cross edge is dest be connected dest either lcand.dest or rcand.dest.</span><br>            <span class="hljs-comment"># If both are valid, then choose the appropriate one using the in_circle test.</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> v_rcand <span class="hljs-keyword">or</span> (v_lcand <span class="hljs-keyword">and</span> inCircle(rcand.dest, rcand.org, lcand.org, lcand.dest)):<br>                <span class="hljs-comment"># Add cross edge base from rcand.dest dest base.dest.</span><br>                base = connect(lcand, base.sym, self.edges)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># Add cross edge base from base.org dest lcand.dest</span><br>                base = connect(base.sym, rcand.sym, self.edges)<br><br>        <span class="hljs-keyword">return</span> ldo, rdo<br></code></pre></td></tr></table></figure>

<p><strong>测试程序：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">from</span> divide_delaunay <span class="hljs-keyword">import</span> Divide_Delaunay<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    np.random.seed(<span class="hljs-number">16</span>)<br>    num = <span class="hljs-number">10</span><br>    fig = plt.figure()<br>    plt.ion()<br>    ax = fig.add_subplot(<span class="hljs-number">111</span>)<br>    xs = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, num)<br>    ys = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, num)<br>    <span class="hljs-comment"># xs = np.array([0, 1, 2, 3, 4, 5])</span><br>    <span class="hljs-comment"># ys = np.array([0, 2, 1, 1, 4, 3])</span><br><br>    start_time = time.time()<br>    dt = Divide_Delaunay(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(xs, ys)))<br>    end_time = time.time()<br>    verticies, edges = dt.verticies, dt.edges<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Triangulating <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(verticies)&#125;</span> points takes <span class="hljs-subst">&#123;end_time - start_time&#125;</span> s&quot;</span>)<br><br>    <span class="hljs-comment"># draw points</span><br>    <span class="hljs-keyword">for</span> vertex <span class="hljs-keyword">in</span> verticies:<br>        ax.scatter(vertex.x, vertex.y, c = <span class="hljs-string">&#x27;b&#x27;</span>)<br><br>    <span class="hljs-comment"># draw edges</span><br>    <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> edges:<br>        a, b = edge.org, edge.sym.org<br>        ax.plot([a.x, b.x], [a.y, b.y], <span class="hljs-string">&#x27;bo-&#x27;</span>)<br>        plt.pause(<span class="hljs-number">0.5</span>)<br><br>    <span class="hljs-keyword">import</span> matplotlib.tri <span class="hljs-keyword">as</span> tri<br><br>    <span class="hljs-comment"># Plot the triangulation.</span><br>    triang = tri.Triangulation([v.x <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> verticies], [v.y <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> verticies])<br>    ax.triplot(triang, <span class="hljs-string">&#x27;ro-&#x27;</span>)<br><br>    fig.show()<br>    plt.pause(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/GIF%202023-6-6%2014-11-07.gif" srcset="/img/loading.gif" lazyload alt="GIF 2023-6-6 14-11-07"></p>
<blockquote>
<p>在我们写的代码中，合并部分最开始寻找的是左右子剖分的上公切线，然后从上到下进行连接合并。当然，也可以寻找下公切线，然后从下向上进行连接合并，两种方式都是一样的效果，是不过判断逻辑相反。</p>
</blockquote>
<p>在效率上，测试了三组数据。结果如下：</p>
<table>
<thead>
<tr>
<th>点集规模/个</th>
<th>耗时/s</th>
</tr>
</thead>
<tbody><tr>
<td>1000</td>
<td>0.09</td>
</tr>
<tr>
<td>4000</td>
<td>0.33</td>
</tr>
<tr>
<td>6000</td>
<td>0.49</td>
</tr>
</tbody></table>
<p>时间复杂度大概为$O(nlogn)$，$n$为点集大小。</p>
<hr>
<h2 id="更多关于网格划分生成的细节和拓展参见：Lecture-Notes-on-Delaunay-Mesh-Generation-1"><a href="#更多关于网格划分生成的细节和拓展参见：Lecture-Notes-on-Delaunay-Mesh-Generation-1" class="headerlink" title="更多关于网格划分生成的细节和拓展参见：Lecture Notes on Delaunay Mesh Generation"></a>更多关于网格划分生成的细节和拓展参见：<a target="_blank" rel="noopener" href="https://people.eecs.berkeley.edu/~jrs/meshpapers/delnotes.pdf">Lecture Notes on Delaunay Mesh Generation</a></h2><p>title: Delaunay三角剖分<br>date: 2023-06-06 14:36:39<br>tags: 学习记录</p>
<hr>
<p>[TOC]</p>
<h2 id="1-text-Voronoi-图-2"><a href="#1-text-Voronoi-图-2" class="headerlink" title="1 $\text{Voronoi}$图"></a>1 $\text{Voronoi}$图</h2><blockquote>
<p>在理解Delaunay三角剖分之前，先引入$\text{Voronoi}$图。</p>
</blockquote>
<h3 id="1-1-定义与性质-2"><a href="#1-1-定义与性质-2" class="headerlink" title="1.1 定义与性质"></a>1.1 定义与性质</h3><p><strong>定义</strong></p>
<p>设由任意$n$个互异平面点（也称基点）组成的点集$P={p_i|i=1,…,n}$。$P$对应的$\text{Voronoi}$图可以理解为对平面的一个区域（单元）划分。对于划分得到的每个区域（也称$\text{Voronoi}$多边形），都应当满足：在基点$p_i$对应的单元中任取一点，该点到$p_i$的（欧式）距离一定小于到$p_j，p_j\in{P},j\ne{i}$的（欧式）距离。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230522154118839.png" srcset="/img/loading.gif" lazyload alt="image-20230522154118839"></p>
<blockquote>
<p>$\text{Voronoi}$又称泰森多边形或$\text{Dirichlet}$图。</p>
<p>平面上的 V-图可以看作是数据点集合 P 中的每个点作为生长点，以相同的速率向 外扩散，直到彼此相遇为止在平面上所形成的图形。除最外层的点形成开放的区域外， 其余的每个点都形成一个凸多边形。</p>
</blockquote>
<p><strong>一些性质</strong></p>
<ul>
<li>每个$\text{Voronoi}$多边形内仅包含一个基点；</li>
<li>$\text{Voronoi}$多边形内的任一点到相应基点的（欧式）距离最近；</li>
<li>位于$\text{Voronoi}$多边形边上的点到其两边的离散点的距离相等；</li>
<li>$n$个点的集合$P$的$\text{Voronoi}$图最多有$2n-5$个顶点和$3n-6$条边；</li>
<li>假如任意四个基点都不共圆，则每个$\text{Voronoi}$顶点恰好是三条$\text{Voronoi}$边的交点，即由$P$中的三点所形成三角形外接圆的圆心。</li>
</ul>
<blockquote>
<p>参考：</p>
<p>[1] 高莉. 改进的Delaunay三角剖分算法研究[D]. 兰州交通大学, 2015.</p>
<p>[2] <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%B3%B0%E6%A3%AE%E5%A4%9A%E8%BE%B9%E5%BD%A2?fr=aladdin">泰森多边形_百度百科 (baidu.com)</a></p>
</blockquote>
<h2 id="2-三角剖分-2"><a href="#2-三角剖分-2" class="headerlink" title="2 三角剖分"></a>2 三角剖分</h2><h3 id="2-1-定义与性质-2"><a href="#2-1-定义与性质-2" class="headerlink" title="2.1 定义与性质"></a>2.1 定义与性质</h3><p>设由任意$n$个平面点组成的点集$P={p_i|i=1,…,n}$。三角剖分是指用<strong>互不相交</strong>的直线段连接$P_i$与$P_j$，$1≤i，j≤n，i≠j$，并且使其凸包中的每个划分区域都是一个三角形。</p>
<p>由于三角剖分是一个平面图，故满足以下几个条件：</p>
<ul>
<li>图中不存在相交的边（除线段端点外，不存在重叠的边）；</li>
<li>图中的边不包含集合$P$中的其他任何点，端点除外；</li>
<li>图中所有的面片都是三角形，并且所有三角形的集合构成$P$的凸包。</li>
</ul>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230523011544467.png" srcset="/img/loading.gif" lazyload alt="image-20230523011544467"></p>
<h3 id="2-2-质量-quality-评定标准-2"><a href="#2-2-质量-quality-评定标准-2" class="headerlink" title="2.2 质量(quality)评定标准"></a>2.2 质量(quality)评定标准</h3><p>由于对给定点集的三角剖分不唯一，对于不同的三角剖分我们有如下质量评定标准：</p>
<table>
<thead>
<tr>
<th>质量评定标准</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>最小角(minimum angle)</td>
<td>所有三角形的内角当中最小的角</td>
</tr>
<tr>
<td>纵横比(aspect ratio)</td>
<td>三角形最短边与最长边的比例</td>
</tr>
<tr>
<td>半径比(radius ratio)</td>
<td>三角形内接圆半径的两倍与外接圆半径的比例</td>
</tr>
</tbody></table>
<blockquote>
<p>参考：</p>
<p>[1] <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/459884570">技术分享：Delaunay三角剖分算法介绍 - 知乎 (zhihu.com)</a></p>
</blockquote>
<h2 id="3-Delaunay三角剖分-2"><a href="#3-Delaunay三角剖分-2" class="headerlink" title="3 Delaunay三角剖分"></a>3 Delaunay三角剖分</h2><blockquote>
<p>Delaunay剖分是一种三角剖分的标准。</p>
</blockquote>
<h3 id="3-1-定义-2"><a href="#3-1-定义-2" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><p><strong>Delaunay边</strong>：假设$E$（$E$为点集的三角剖分的边集）中的一条边$e$（两个端点分别为$a,b$），$e$为Delaunay边的条件为：存在一个圆经过$a,b$两点，圆内(最多三点共圆)不含点集$P$中任何其他的点，这一特性又称<strong>空圆特性</strong>。</p>
<p><strong>Delaunay三角剖分</strong>：如果点集$P$的一个三角剖分$T$只包含Delaunay边，那么该三角剖分称为Delaunay三角剖分。</p>
<p><strong>Delaunay三角剖分的另一种定义</strong>：因为Delaunay三角剖分与$\text{Voronoi}$图是对偶关系，Delaunay三角剖分是$\text{Voronoi}$图的伴生图形，两者可以相互转化。作$\text{Voronoi}$图的对偶图，即对每条$\text{Voronoi}$边(限有限长线段)作通过点集中某两点的中垂线，得到的即为Delaunay三角剖分。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230524001225163.png" srcset="/img/loading.gif" lazyload alt="image-20230524001225163"></p>
<h3 id="3-2-准则与性质-2"><a href="#3-2-准则与性质-2" class="headerlink" title="3.2 准则与性质"></a>3.2 准则与性质</h3><p>一个三角剖分必须符合以下两条重要准则，才可称之为Delaunay三角剖分。</p>
<ul>
<li><p><strong>空圆特性</strong></p>
<blockquote>
<p>Delaunay三角剖分是唯一的（任意四点不能共圆），在Delaunay三角剖分中任一三角形的外接圆内不会存在其它点。即满足Delaunay边的定义。</p>
</blockquote>
</li>
<li><p><strong>最大化最小角特性</strong></p>
<blockquote>
<p>在点集$P$的所有可能的三角剖分中，Delaunay三角剖分所形成的三角形<strong>最小角</strong>最大。</p>
</blockquote>
</li>
</ul>
<p>Delaunay三角剖分具备以下几点重要的性质：</p>
<p>(1)<strong>唯一性</strong>：无论从点集的任何位置开始建网，最终得到的Delaunay三角剖分都是唯一的。</p>
<p>(2)<strong>最接近</strong>：三角形是以最邻近的三点组成的，并且所形成的三角形的各边都不会相交。 </p>
<p>(3)<strong>最规则</strong>：假如将三角剖分中每个三角形的最小角度按升序进行排列，那么Delaunay三角剖分排列得到的数值最大。</p>
<p>(4)<strong>最优性</strong>：如果任意两个相邻三角形所组成的凸四边形的对角线相互交换，那么交换后两个三角形的六个内角中最小角角度不再增大。 </p>
<p>(5)<strong>区域性</strong>：移动、新增、删除三角剖分中某个顶点时只会影响相邻的三角形。 </p>
<p>(6)<strong>具有凸多边形的外壳</strong>：在所构建的三角剖分中，最外层的边界构成了点集的凸多边形“外壳”（即点集的凸包）。</p>
<h2 id="4-Delaunay三角剖分算法-2"><a href="#4-Delaunay三角剖分算法-2" class="headerlink" title="4 Delaunay三角剖分算法"></a>4 Delaunay三角剖分算法</h2><blockquote>
<p>Delaunay三角剖分的算法可以分为逐点插入法、三角网生长法，分治算法等。分治算法的效率最高，逐点插人法实现简单高效，占用内存较小，但它的时间复杂度差。三角网生长法由于效率相对较低，目前采用较少。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525011734005.png" srcset="/img/loading.gif" lazyload alt="image-20230525011734005"></p>
</blockquote>
<h3 id="4-1-Bowyer-Watson算法-2"><a href="#4-1-Bowyer-Watson算法-2" class="headerlink" title="4.1 Bowyer-Watson算法"></a>4.1 Bowyer-Watson算法</h3><p>Bowyer-Watson算法属于逐点插入法的一种，易于理解和实现。</p>
<h4 id="4-1-1-算法步骤：-2"><a href="#4-1-1-算法步骤：-2" class="headerlink" title="4.1.1 算法步骤："></a>4.1.1 算法步骤：</h4><p>Step1：构造一个包含点集中的所有点的超级三角形（super-triangle），放入三角形列表中；</p>
<blockquote>
<p>这个三角形列表可以理解为一个三角剖分，目前只包含一个三角形，即超级三角形。</p>
</blockquote>
<p>Step2：将点集中的点逐一插入现有的三角剖分中，并进行如下调整：</p>
<ul>
<li><p>在三角形列表中，找出所有外接圆包含该插入点的三角形（称为该点的影响三角形），所有影响三角形的合集构成一个“星形多边形”(star shaped polygon)。星形多边形的含义是多边形的任何一个顶点到插入点的连线都在多边形内部。</p>
</li>
<li><p>对于上述星形多边形，将其内部的三角形全部删除，形成一个“空穴”。将空穴边界的顶点与新插入的点连接得到新的三角形，替代剖分中被删除的三角形，从而完成一个点在Delaunay三角形列表中的插入，得到一个包含插入点的新Delaunay三角剖分。</p>
</li>
</ul>
<blockquote>
<p>还有一种说法是：在三角形列表中，找出其外接圆包含插入点的三角形（称为该点的影响三角形），删除影响三角形的公共边，将插入点同影响三角形的全部顶点连接起来，从而完成一个点在Delaunay三角形列表中的插入。该步骤的图示如下：</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/5.GIF" srcset="/img/loading.gif" lazyload alt="img"></p>
</blockquote>
<p>Step3：循环执行Step2，直到所有点插入完毕。</p>
<p>Step4：最后从三角形列表中删除与超级三角形关联的三角形，得到点集的Delaunay三角剖分。</p>
<h4 id="4-1-2-算法伪代码-2"><a href="#4-1-2-算法伪代码-2" class="headerlink" title="4.1.2 算法伪代码"></a>4.1.2 算法伪代码</h4><p><strong>版本一</strong></p>
<blockquote>
<p> from <a target="_blank" rel="noopener" href="http://paulbourke.net/papers/triangulate/">Triangulate: Pan Pacific Computer Conference, Beijing, China (paulbourke.net)</a></p>
</blockquote>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab">input : vertex list<br>output : triangle list<br>   initialize the triangle list<br>   determine the supertriangle<br>   add supertriangle vertices to the <span class="hljs-keyword">end</span> of the vertex list<br>   add the supertriangle to the triangle list<br>   <span class="hljs-keyword">for</span> each sample point in the vertex list<br>      initialize the edge buffer<br>      <span class="hljs-keyword">for</span> each triangle currently in the triangle list<br>         calculate the triangle circumcircle center and radius<br>         <span class="hljs-keyword">if</span> the point lies in the triangle circumcircle then<br>            add the three triangle edges to the edge buffer<br>            remove the triangle from the triangle list<br>         endif<br>      endfor<br>      delete all doubly specified edges from the edge buffer<br>         this leaves the edges of the enclosing polygon only<br>      add to the triangle list all triangles formed between the point <br>         and the edges of the enclosing polygon<br>   endfor<br>   remove any triangles from the triangle list that use the supertriangle vertices<br>   remove the supertriangle vertices from the vertex list<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p><strong>版本二</strong></p>
<blockquote>
<p>from <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bowyer%E2%80%93Watson_algorithm">Bowyer–Watson algorithm - Wikipedia</a>.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BowyerWatson</span> (<span class="hljs-params">pointList</span>)</span><br><span class="hljs-function">    // <span class="hljs-title">pointList</span> <span class="hljs-title">is</span> <span class="hljs-title">a</span> <span class="hljs-title">set</span> <span class="hljs-title">of</span> <span class="hljs-title">coordinates</span> <span class="hljs-title">defining</span> <span class="hljs-title">the</span> <span class="hljs-title">points</span> <span class="hljs-title">to</span> <span class="hljs-title">be</span> <span class="hljs-title">triangulated</span></span><br><span class="hljs-function">    <span class="hljs-title">triangulation</span> := <span class="hljs-title">empty</span> <span class="hljs-title">triangle</span> <span class="hljs-title">mesh</span> <span class="hljs-title">data</span> <span class="hljs-title">structure</span></span><br><span class="hljs-function">    <span class="hljs-title">add</span> <span class="hljs-title">super</span>-<span class="hljs-title">triangle</span> <span class="hljs-title">to</span> <span class="hljs-title">triangulation</span> // <span class="hljs-title">must</span> <span class="hljs-title">be</span> <span class="hljs-title">large</span> <span class="hljs-title">enough</span> <span class="hljs-title">to</span> <span class="hljs-title">completely</span> <span class="hljs-title">contain</span> <span class="hljs-title">all</span> <span class="hljs-title">the</span> <span class="hljs-title">points</span> <span class="hljs-title">in</span> <span class="hljs-title">pointList</span></span><br><span class="hljs-function">    <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">point</span> <span class="hljs-title">in</span> <span class="hljs-title">pointList</span> <span class="hljs-title">do</span> // <span class="hljs-title">add</span> <span class="hljs-title">all</span> <span class="hljs-title">the</span> <span class="hljs-title">points</span> <span class="hljs-title">one</span> <span class="hljs-title">at</span> <span class="hljs-title">a</span> <span class="hljs-title">time</span> <span class="hljs-title">to</span> <span class="hljs-title">the</span> <span class="hljs-title">triangulation</span></span><br><span class="hljs-function">        <span class="hljs-title">badTriangles</span> := <span class="hljs-title">empty</span> <span class="hljs-title">set</span></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">triangle</span> <span class="hljs-title">in</span> <span class="hljs-title">triangulation</span> <span class="hljs-title">do</span> // <span class="hljs-title">first</span> <span class="hljs-title">find</span> <span class="hljs-title">all</span> <span class="hljs-title">the</span> <span class="hljs-title">triangles</span> <span class="hljs-title">that</span> <span class="hljs-title">are</span> <span class="hljs-title">no</span> <span class="hljs-title">longer</span> <span class="hljs-title">valid</span> <span class="hljs-title">due</span> <span class="hljs-title">to</span> <span class="hljs-title">the</span> <span class="hljs-title">insertion</span></span><br><span class="hljs-function">            <span class="hljs-title">if</span> <span class="hljs-title">point</span> <span class="hljs-title">is</span> <span class="hljs-title">inside</span> <span class="hljs-title">circumcircle</span> <span class="hljs-title">of</span> <span class="hljs-title">triangle</span></span><br><span class="hljs-function">                <span class="hljs-title">add</span> <span class="hljs-title">triangle</span> <span class="hljs-title">to</span> <span class="hljs-title">badTriangles</span></span><br><span class="hljs-function">        <span class="hljs-title">polygon</span> := <span class="hljs-title">empty</span> <span class="hljs-title">set</span></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">triangle</span> <span class="hljs-title">in</span> <span class="hljs-title">badTriangles</span> <span class="hljs-title">do</span> // <span class="hljs-title">find</span> <span class="hljs-title">the</span> <span class="hljs-title">boundary</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">polygonal</span> <span class="hljs-title">hole</span></span><br><span class="hljs-function">            <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">edge</span> <span class="hljs-title">in</span> <span class="hljs-title">triangle</span> <span class="hljs-title">do</span></span><br><span class="hljs-function">                <span class="hljs-title">if</span> <span class="hljs-title">edge</span> <span class="hljs-title">is</span> <span class="hljs-title">not</span> <span class="hljs-title">shared</span> <span class="hljs-title">by</span> <span class="hljs-title">any</span> <span class="hljs-title">other</span> <span class="hljs-title">triangles</span> <span class="hljs-title">in</span> <span class="hljs-title">badTriangles</span></span><br><span class="hljs-function">                    <span class="hljs-title">add</span> <span class="hljs-title">edge</span> <span class="hljs-title">to</span> <span class="hljs-title">polygon</span></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">triangle</span> <span class="hljs-title">in</span> <span class="hljs-title">badTriangles</span> <span class="hljs-title">do</span> // <span class="hljs-title">remove</span> <span class="hljs-title">them</span> <span class="hljs-title">from</span> <span class="hljs-title">the</span> <span class="hljs-title">data</span> <span class="hljs-title">structure</span></span><br><span class="hljs-function">            <span class="hljs-title">remove</span> <span class="hljs-title">triangle</span> <span class="hljs-title">from</span> <span class="hljs-title">triangulation</span></span><br><span class="hljs-function">        <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">edge</span> <span class="hljs-title">in</span> <span class="hljs-title">polygon</span> <span class="hljs-title">do</span> // <span class="hljs-title">re</span>-<span class="hljs-title">triangulate</span> <span class="hljs-title">the</span> <span class="hljs-title">polygonal</span> <span class="hljs-title">hole</span></span><br><span class="hljs-function">            <span class="hljs-title">newTri</span> := <span class="hljs-title">form</span> <span class="hljs-title">a</span> <span class="hljs-title">triangle</span> <span class="hljs-title">from</span> <span class="hljs-title">edge</span> <span class="hljs-title">to</span> <span class="hljs-title">point</span></span><br><span class="hljs-function">            <span class="hljs-title">add</span> <span class="hljs-title">newTri</span> <span class="hljs-title">to</span> <span class="hljs-title">triangulation</span></span><br><span class="hljs-function">    <span class="hljs-title">for</span> <span class="hljs-title">each</span> <span class="hljs-title">triangle</span> <span class="hljs-title">in</span> <span class="hljs-title">triangulation</span> // <span class="hljs-title">done</span> <span class="hljs-title">inserting</span> <span class="hljs-title">points</span>, <span class="hljs-title">now</span> <span class="hljs-title">clean</span> <span class="hljs-title">up</span></span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-title">triangle</span> <span class="hljs-title">contains</span> <span class="hljs-title">a</span> <span class="hljs-title">vertex</span> <span class="hljs-title">from</span> <span class="hljs-title">original</span> <span class="hljs-title">super</span>-<span class="hljs-title">triangle</span></span><br><span class="hljs-function">            <span class="hljs-title">remove</span> <span class="hljs-title">triangle</span> <span class="hljs-title">from</span> <span class="hljs-title">triangulation</span></span><br><span class="hljs-function">    <span class="hljs-title">return</span> <span class="hljs-title">triangulation</span></span><br></code></pre></td></tr></table></figure>

<h4 id="4-1-3-算法解释示例-2"><a href="#4-1-3-算法解释示例-2" class="headerlink" title="4.1.3 算法解释示例"></a>4.1.3 算法解释示例</h4><p>这里我们以A,B,C,D四个点为例，画图说明整个Bowyer-Watson算法的流程。</p>
<ul>
<li><p>首先建立一个超级三角形（p1,p2,p3），这个三角形要把点集中所有的点都包含进去。将这个超级三角形加入三角形列表。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525133130002.png" srcset="/img/loading.gif" lazyload alt="image-20230525133130002"></p>
<blockquote>
<p>关于如何构建超级三角形，详见[4.1.5 实现细节](#4.1.5 实现细节)。</p>
</blockquote>
</li>
<li><p>我们先插入点A，因为原来的三角形列表中唯一的超级三角形外接圆必定包含点A，所以我们可以将三角形▲(p1,p2,p3)看作一个星形多边形，其内部没有三角形，所以我们直接将点A与其顶点相连，将原来的三角形拆分为三个三角形（▲(p1,A,p2），▲(p2,A,p3)，▲(p3,A,p1)）。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525135633264.png" srcset="/img/loading.gif" lazyload alt="image-20230525135633264"></p>
</li>
<li><p>再插入点B，做三角形列表中各个三角形的外接圆，我们找到了点B的影响三角形，即▲(p1,A,p3），▲(p2,A,p3)。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525140915264.png" srcset="/img/loading.gif" lazyload alt="image-20230525140915264"></p>
</li>
<li><p>删除影响三角形组成的星形多边形内部的三角形（公共边，这里即边(A,p3))。然后将点B同影响三角形的全部顶点连接起来。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525141540743.png" srcset="/img/loading.gif" lazyload alt="image-20230525141540743"></p>
</li>
<li><p>接下来再插入点C，同上面插入点B的流程一样，找到影响三角形，删除公共边，连接影响三角形的各个顶点。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142157546.png" srcset="/img/loading.gif" lazyload alt="image-20230525142157546"></p>
</li>
<li><p>然后相同的方法插入点D。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142614560.png" srcset="/img/loading.gif" lazyload alt="image-20230525142614560"></p>
</li>
<li><p>最后删除与超级三角形顶点（p1,p2,p3）相关联的三角形。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525142914270.png" srcset="/img/loading.gif" lazyload alt="image-20230525142914270"></p>
</li>
<li><p>最终点A,B,C,D的三角剖分结果如下图。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525143023480.png" srcset="/img/loading.gif" lazyload alt="image-20230525143023480"></p>
</li>
</ul>
<h4 id="4-1-4-算法的优化-2"><a href="#4-1-4-算法的优化-2" class="headerlink" title="4.1.4 算法的优化"></a>4.1.4 算法的优化</h4><p>Bowyer-Watson算法比较耗时的一步是关于新插入点的定位。在上文中，我们通过遍历三角形列表中的所有三角形，然后分别判断插入点是否落在其外接圆内。随着点集规模增大，三角形列表在Delaunay三角剖分的构造过程中会逐渐增大，插入点定位的耗时也会随之增加。因此针对点定位问题，有很多优化的改进算法。</p>
<h5 id="（1）排序优化-2"><a href="#（1）排序优化-2" class="headerlink" title="（1）排序优化"></a>（1）排序优化</h5><p>该算法优化的思路如下：首先将原始点集中的点按x坐标从小到大进行排序。在插入时，不再是随机插入，而是按照排序顺序进行。保证了新插入的点不会出现在之前插入点的左侧。还有一点不同，该算法中除了点集的列表外，还有已确定的三角形列表和未确定的三角形列表。每次对插入点进行定位时，只需要在未确定的三角形列表中对新插入点进行定位计算，而不再对所有生成的三角形进行查询。如个插入点在查询三角形外接圆的右侧，则说明查询三角形为合法的Delaunay三角形，移存到已确定的三角形列表中；若在外接圆外且不在右侧，则说明该查询三角形仍是一个未确定三角形，不进行任何操作；如在外接圆内，则说明该查询三角形不为Delaunay三角形，从未确定三角形列表中移除。</p>
<p><strong>伪代码：</strong></p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs glsl">input: 顶点列表(<span class="hljs-keyword">vertices</span>)                                      <span class="hljs-comment">//vertices为外部生成的随机或乱序顶点列表</span><br>output:已确定的三角形列表(<span class="hljs-keyword">triangles</span>)<br>　　　　初始化顶点列表<br>　　　　创建索引列表(indices = new Array(<span class="hljs-keyword">vertices</span>.<span class="hljs-built_in">length</span>))　　　　<span class="hljs-comment">//indices数组中的值为0,1,2,3,......,vertices.length-1</span><br>　　　　基于<span class="hljs-keyword">vertices</span>中的顶点x坐标对indices进行sort　　  　　　　　  <span class="hljs-comment">//sort后的indices值顺序为顶点坐标x从小到大排序（也可对y坐标，本例中针对x坐标）</span><br>　　　　确定超级三角形<br>　　　　将超级三角形保存至未确定三角形列表（temp <span class="hljs-keyword">triangles</span>）<br>　　　　将超级三角形push到<span class="hljs-keyword">triangles</span>列表<br>　　　　遍历基于indices顺序的<span class="hljs-keyword">vertices</span>中每一个点　　　　　　　　　  　<span class="hljs-comment">//基于indices后，则顶点则是由x从小到大出现</span><br>　　　　　　初始化边缓存数组（edge <span class="hljs-keyword">buffer</span>）<br>　　　　　　遍历temp <span class="hljs-keyword">triangles</span>中的每一个三角形<br>　　　　　　　　计算该三角形的圆心和半径<br>　　　　　　　　如果该点在外接圆的右侧<br>　　　　　　　　　　则该三角形为Delaunay三角形，保存到<span class="hljs-keyword">triangles</span><br>　　　　　　　　　　并在temp里去除掉<br>　　　　　　　　　　跳过<br>　　　　　　　　如果该点在外接圆外（即也不是外接圆右侧）<br>　　　　　　　　　　则该三角形为不确定        　　　　　　　　　     <span class="hljs-comment">//后面会在问题中讨论</span><br>　　　　　　　　　　跳过<br>　　　　　　　　如果该点在外接圆内<br>　　　　　　　　　　则该三角形不为Delaunay三角形<br>　　　　　　　　　　将三边保存至edge <span class="hljs-keyword">buffer</span><br>　　　　　　　　　　在temp中去除掉该三角形<br>　　　　　　对edge <span class="hljs-keyword">buffer</span>进行去重<br>　　　　　　将edge <span class="hljs-keyword">buffer</span>中的边与当前的点进行组合成若干三角形并保存至temp <span class="hljs-keyword">triangles</span>中<br>　　　　将<span class="hljs-keyword">triangles</span>与temp <span class="hljs-keyword">triangles</span>进行合并<br>　　　　除去与超级三角形有关的三角形<br>end<br></code></pre></td></tr></table></figure>

<p><strong>细节：</strong></p>
<p>当插入点在查询三角形外接圆右侧时。由于插入点按照x坐标大小从左往右依次插入，所以剩余的其他点都必然在该外接圆的右侧，即该查询三角形满足<strong>空圆特性</strong>，为Delaunay三角形。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160836087924338.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在查询三角形的外接圆中，插入点1时，符合在外侧的条件，但是不能保证后面所有的点都保持在外接圆外侧。如图中的点2及后面可能出现的点很有可能出现在圆内，而使该三角形被按边分解。所以在该优化算法中，如果碰到在点在外侧且非右侧的话，会跳过，该三角形一直在temp triangles中被检验，直到碰到下一个点在圆内或圆右才会从未确定三角形列表中去除，进行后面的操作。</p>
<p>而当点在圆上时，也是根据在圆内的方法对其进行操作，实际情况中会出现这种情况，该现象称为“退化”。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160838043703195.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<blockquote>
<p>参考：</p>
<p>[1] <a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhiyishou/p/4430017.html">三角剖分算法(delaunay) - 纸异兽 - 博客园 (cnblogs.com)</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://github.com/darkskyapp/delaunay-fast">darkskyapp/delaunay-fast: Fast Delaunay Triangulation in JavaScript. (github.com)</a></p>
</blockquote>
<h5 id="（2）快速点定位-2"><a href="#（2）快速点定位-2" class="headerlink" title="（2）快速点定位"></a>（2）快速点定位</h5><p><font color=orange size=4><b>TODO:</b></font></p>
<blockquote>
<p>参考：</p>
<p>[1] <a target="_blank" rel="noopener" href="https://blog.csdn.net/whb12345678feng/article/details/108110918">计算几何学习——点定位_Mathematic_feng的博客-CSDN博客</a></p>
<p>[2] 刘琴琴.平面域Delaunay三角网点定位算法研究综述[J].电子设计工程,2017,25(01):47-51.DOI:10.14022/j.cnki.dzsjgc.2017.01.012.</p>
<p>[3] 伯格 著, 邓俊辉. 计算几何:算法与应用(第3版)[M]. 清华大学出版社, 2009.</p>
</blockquote>
<h4 id="4-1-5-实现细节-2"><a href="#4-1-5-实现细节-2" class="headerlink" title="4.1.5 实现细节"></a>4.1.5 实现细节</h4><h5 id="（1）构造超级三角形-2"><a href="#（1）构造超级三角形-2" class="headerlink" title="（1）构造超级三角形"></a>（1）构造超级三角形</h5><p><strong>方法一：</strong></p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525231438652.png" srcset="/img/loading.gif" lazyload alt="image-20230525231438652"></p>
<blockquote>
<p>其中绿色四边形为点集的包围盒。</p>
</blockquote>
<p><strong>方法二：</strong></p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/160718101043903.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>根据相似三角形定理求得与矩形一半的小矩形的对角三角形，扩大一倍后则扩大后的直角三角形斜边经过点(Xmax,Ymin)。为了将所有的点包含在超级三角形内，在右下角对该三角形的顶点进行了横和高的扩展，并要保证这个扩展三角形底大于高。</p>
<blockquote>
<p>参考自：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhiyishou/p/4430017.html">三角剖分算法(delaunay) - 纸异兽 - 博客园 (cnblogs.com)</a></p>
</blockquote>
<p><strong>其他方法：</strong></p>
<p>上面两种方法的初始化图形都是一个三角形。除此之外，还有学者提出使用一个包含所有点的初始矩形，然后将矩形的任意一条对角线连接，划分为两个三角形加入初始三角剖分列表中。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230525232322324.png" srcset="/img/loading.gif" lazyload alt="image-20230525232322324"></p>
<p>上图中，$\text{K}$为一个正位移值。</p>
<h5 id="（2）计算三角形外接圆圆心和半径-2"><a href="#（2）计算三角形外接圆圆心和半径-2" class="headerlink" title="（2）计算三角形外接圆圆心和半径"></a>（2）计算三角形外接圆圆心和半径</h5><blockquote>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Circumscribed_circle#Circumcircle_equations">https://en.wikipedia.org/wiki/Circumscribed_circle#Circumcircle_equations</a></p>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Circumscribed_circle#Circumcenter_coordinates">https://en.wikipedia.org/wiki/Circumscribed_circle#Circumcenter_coordinates</a></p>
</blockquote>
<p><img src="C:\Users\MSTIFIY\AppData\Roaming\Typora\typora-user-images\image-20230527102334838.png" srcset="/img/loading.gif" lazyload alt="image-20230527102334838"></p>
<p>求出外接圆圆心坐标后，圆心与三角形任一顶点的距离即是外接圆半径。</p>
<blockquote>
<p>如果三点共线，那么其外接圆圆心将在无穷远处。</p>
</blockquote>
<h4 id="4-1-6-代码实现-2"><a href="#4-1-6-代码实现-2" class="headerlink" title="4.1.6 代码实现"></a>4.1.6 代码实现</h4><p>首先定义点、边、三角形的数据结构。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">float</span>, y: <span class="hljs-built_in">float</span></span>):</span><br>        self.x = x<br>        self.y = y<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__eq__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">return</span> self.x == other.x <span class="hljs-keyword">and</span> self.y == other.y<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dist2</span>(<span class="hljs-params">self, other</span>) -&gt; <span class="hljs-built_in">float</span>:</span><br>        <span class="hljs-keyword">return</span> (self.x - other.x) * (self.x - other.x) + (self.y - other.y) * (self.y - other.y)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isInCircumcircleOf</span>(<span class="hljs-params">self, t</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>        A, B, C = t.verticies[<span class="hljs-number">0</span>], t.verticies[<span class="hljs-number">1</span>], t.verticies[<span class="hljs-number">2</span>]<br>        a2 = A.x * A.x + A.y * A.y<br>        b2 = B.x * B.x + B.y * B.y<br>        c2 = C.x * C.x + C.y * C.y<br>        D = <span class="hljs-number">2.0</span> * (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y))<br>        center_x = (a2 * (B.y - C.y) + b2 * (C.y - A.y) + c2 * (A.y - B.y)) / D<br>        center_y = (a2 * (C.x - B.x) + b2 * (A.x - C.x) + c2 * (B.x - A.x)) / D<br>        center = Point(center_x, center_y)<br>        <span class="hljs-keyword">return</span> self.dist2(center) &lt;= A.dist2(center)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Edge</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, begin: Point, end: Point</span>):</span><br>        self.begin = begin<br>        self.end = end<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__eq__</span>(<span class="hljs-params">self, other</span>):</span><br>        <span class="hljs-keyword">return</span> (self.begin == other.begin <span class="hljs-keyword">and</span> self.end == other.end) <span class="hljs-keyword">or</span> (<br>                self.begin == other.end <span class="hljs-keyword">and</span> self.end == other.begin)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, A: Point, B: Point, C: Point</span>):</span><br>        self.verticies = [A, B, C]<br>        self.edges = [Edge(A, B), Edge(B, C), Edge(C, A)]<br></code></pre></td></tr></table></figure>

<p>然后定义一个用于delaunay三角剖分的类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Delaunay_Triangulation</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Bowyer Watson Algorithm&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, points: <span class="hljs-type">List</span>[Point]</span>):</span><br>        self.points: <span class="hljs-type">List</span>[Point] = points<br>        self.super_triangle = self.getSuperTriangle()<br>        self.triangles: <span class="hljs-type">List</span>[Triangle] = [self.super_triangle]  <span class="hljs-comment"># add super-triangle to triangulation</span><br>        <span class="hljs-keyword">for</span> point <span class="hljs-keyword">in</span> points:  <span class="hljs-comment"># add all the initial points one at a time to the triangulation</span><br>            self.addPoint(point)<br>        self.removeSuperTriangle()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getSuperTriangle</span>(<span class="hljs-params">self</span>) -&gt; Triangle:</span><br>        sorted_x = <span class="hljs-built_in">sorted</span>(self.points, key = <span class="hljs-keyword">lambda</span> p: p.x)<br>        sorted_y = <span class="hljs-built_in">sorted</span>(self.points, key = <span class="hljs-keyword">lambda</span> p: p.y)<br>        xmin, xmax = sorted_x[<span class="hljs-number">0</span>].x, sorted_x[-<span class="hljs-number">1</span>].x<br>        ymin, ymax = sorted_y[<span class="hljs-number">0</span>].y, sorted_y[-<span class="hljs-number">1</span>].y<br>        dx, dy = xmax - xmin, ymax - ymin<br>        dmax = <span class="hljs-built_in">max</span>(dx, dy)<br>        xmid = xmin + dx * <span class="hljs-number">0.5</span><br>        ymid = ymin + dy * <span class="hljs-number">0.5</span><br><br>        <span class="hljs-keyword">return</span> Triangle(Point(xmid - <span class="hljs-number">20</span> * dmax, ymid - dmax),<br>                        Point(xmid, ymid + <span class="hljs-number">20</span> * dmax),<br>                        Point(xmid + <span class="hljs-number">20</span> * dmax, ymid - dmax))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addPoint</span>(<span class="hljs-params">self, point: Point</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        bad_triangles: <span class="hljs-type">List</span>[Triangle] = []<br>        <span class="hljs-comment"># first find all the triangles that are no longer valid due to the insertion</span><br>        <span class="hljs-keyword">for</span> triangle <span class="hljs-keyword">in</span> self.triangles:<br>            <span class="hljs-keyword">if</span> point.isInCircumcircleOf(triangle):<br>                bad_triangles.append(triangle)<br><br>        polygon: <span class="hljs-type">List</span>[Edge] = []<br>        <span class="hljs-comment"># Find the boundary of the polygonal hole</span><br>        <span class="hljs-keyword">for</span> triangle1 <span class="hljs-keyword">in</span> bad_triangles:<br>            <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> triangle1.edges:<br>                edge_shared = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">for</span> triangle2 <span class="hljs-keyword">in</span> bad_triangles:<br>                    <span class="hljs-keyword">if</span> triangle1 == triangle2:<br>                        <span class="hljs-keyword">continue</span><br>                    <span class="hljs-keyword">if</span> edge <span class="hljs-keyword">in</span> triangle2.edges:<br>                        edge_shared = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> edge_shared:<br>                    polygon.append(edge)<br><br>        <span class="hljs-comment"># Remove broken triangles from the triangulation list</span><br>        <span class="hljs-keyword">for</span> triangle <span class="hljs-keyword">in</span> bad_triangles:<br>            self.triangles.remove(triangle)<br><br>        <span class="hljs-comment"># Create triangles with the newly created edges</span><br>        <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> polygon:<br>            new_triangle = Triangle(edge.begin, edge.end, point)<br>            self.triangles.append(new_triangle)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeSuperTriangle</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-comment"># Remove the triangles that has connection to the super-triangle</span><br>        super_verticies = self.super_triangle.verticies<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(self.triangles) - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            triangle = self.triangles[i]<br>            has_common = <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">for</span> vertex1 <span class="hljs-keyword">in</span> triangle.verticies:<br>                <span class="hljs-keyword">for</span> vertex2 <span class="hljs-keyword">in</span> super_verticies:<br>                    <span class="hljs-keyword">if</span> vertex1 == vertex2:<br>                        has_common = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> has_common:<br>                self.triangles.remove(triangle)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exportTriangles</span>(<span class="hljs-params">self</span>):</span><br>        ps = [p <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> self.triangles <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> t.verticies]<br>        xs = [p.x <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> ps]<br>        ys = [p.y <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> ps]<br>        ts = [(ps.index(t.verticies[<span class="hljs-number">0</span>]), ps.index(t.verticies[<span class="hljs-number">1</span>]), ps.index(t.verticies[<span class="hljs-number">2</span>])) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> self.triangles]<br>        <span class="hljs-keyword">return</span> xs, ys, ts<br></code></pre></td></tr></table></figure>

<p>其中<code>exportTriangles</code>函数用于导出matplotlib库绘制剖分结果所需的数据。算法测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint, seed<br><span class="hljs-keyword">from</span> Delaunay_Triangulation <span class="hljs-keyword">import</span> Delaunay_Triangulation, Point<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    seed(<span class="hljs-number">5</span>)<br>    n = <span class="hljs-number">10</span><br>    xs = [randint(<span class="hljs-number">1</span>, <span class="hljs-number">98</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    ys = [randint(<span class="hljs-number">1</span>, <span class="hljs-number">98</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>    seted_points = <span class="hljs-built_in">set</span>(<span class="hljs-built_in">zip</span>(xs, ys))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The actual number of input points: &quot;</span>, <span class="hljs-built_in">len</span>(seted_points))<br>    points = [Point(x, y) <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> seted_points]<br>    start_time = time.time()<br>    dt = Delaunay_Triangulation(points)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Triangulating <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(seted_points)&#125;</span> points takes <span class="hljs-subst">&#123;time.time() - start_time&#125;</span> s&quot;</span>)<br>    <span class="hljs-comment"># number of DT triangles</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(dt.triangles), <span class="hljs-string">&quot;Delaunay triangles&quot;</span>)<br><br>    <span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>    <span class="hljs-keyword">import</span> matplotlib.tri <span class="hljs-keyword">as</span> tri<br><br>    <span class="hljs-comment"># Plot the triangulation.</span><br>    fig, ax = plt.subplots()<br>    ax.margins(<span class="hljs-number">0.1</span>)<br>    ax.set_aspect(<span class="hljs-string">&#x27;equal&#x27;</span>)<br>    xs1, ys1, ts = dt.exportTriangles()<br>    ax.triplot(tri.Triangulation(xs1, ys1, ts), <span class="hljs-string">&#x27;bo-&#x27;</span>)<br>    triang = tri.Triangulation(xs, ys)<br>    ax.triplot(triang, <span class="hljs-string">&#x27;ro-&#x27;</span>)<br>    ax.set_title(<span class="hljs-string">&#x27;triplot of Delaunay triangulation&#x27;</span>)<br>    plt.show()<br></code></pre></td></tr></table></figure>

<p>其中<code>seted_points = set(zip(xs, ys))</code>用于去除随机生成点集中的重复点，满足输入点集的坐标互异要求。否则，若随机生成的两点坐标相同，在计算点外接圆时，如下代码中，D为0，会抛出<code>ZeroDivisionError: division by zero</code>异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">D = <span class="hljs-number">2.0</span> * (A.x * (B.y - C.y) + B.x * (C.y - A.y) + C.x * (A.y - B.y))<br>center_x = (a2 * (B.y - C.y) + b2 * (C.y - A.y) + c2 * (A.y - B.y)) / D<br>center_y = (a2 * (C.x - B.x) + b2 * (A.x - C.x) + c2 * (B.x - A.x)) / D<br></code></pre></td></tr></table></figure>

<p>如下两行代码的作用是，调用<code>matplotlib.tri.Triangulation</code>构建三角剖分。用两种不同的颜色分别绘制我们编写的代码和调用第三方库函数进行三角剖分的结果，可以验证算法的正确性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">triang = tri.Triangulation(xs, ys)<br>ax.triplot(triang, <span class="hljs-string">&#x27;ro-&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205450735.png" srcset="/img/loading.gif" lazyload alt="image-20230528205450735"></p>
<p>经过测试发现，<code>matplotlib.tri.Triangulation</code>函数得到的三角剖分在随机生成点集数量比较大时，会和本算法的剖分结果有差异。</p>
<p><code>matplotlib.tri.Triangulation</code>函数剖分结果：</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205916411.png" srcset="/img/loading.gif" lazyload alt="image-20230528205916411"></p>
<p>我们编写的<code>Delaunay_Triangulation</code>类的剖分结果：</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230528205904484.png" srcset="/img/loading.gif" lazyload alt="image-20230528205904484"></p>
<p>出现这种问题的原因，我猜测可能是因为某四点共圆了。</p>
<blockquote>
<p>在Delaunay三角剖分的性质中，若点集$P$中任意四点不共圆，则存在唯一的Delaunay三角剖分$T$。若点集$P$中四点$A,B,C,D$共圆，且△ABC,△BCD属于Delaunay三角剖分T，那么将边$BC$翻转后得到的三角剖分$T’$(包含△ABD,△ACD)同样是一个Delaunay三角剖分。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/459884570">技术分享：Delaunay三角剖分算法介绍 - 知乎 (zhihu.com)</a></p>
</blockquote>
<p>通过输入一系列共圆点，得到下图结果。两种都属于Delaunay三角剖分。</p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230529004839957.png" srcset="/img/loading.gif" lazyload alt="image-20230529004839957"></p>
<p>在效率上，测试了三组数据。结果如下：</p>
<table>
<thead>
<tr>
<th>点集规模/个</th>
<th>耗时/s</th>
</tr>
</thead>
<tbody><tr>
<td>1000</td>
<td>4</td>
</tr>
<tr>
<td>4000</td>
<td>60</td>
</tr>
<tr>
<td>6000</td>
<td>150</td>
</tr>
</tbody></table>
<p>时间复杂度大概为$O(n^2)$，$n$为点集大小。</p>
<h3 id="4-2-分治法-2"><a href="#4-2-分治法-2" class="headerlink" title="4.2 分治法"></a>4.2 分治法</h3><blockquote>
<p>参考文献：</p>
<p><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/10.1145/282918.282923">[1] Guibas L, Stolfi J. Primitives for the manipulation of general subdivisions and the computation of Voronoi[J]. ACM Transactions on Graphics, 1985, 4(2): 74–123.</a></p>
<p>L. Guibas 和 J. Stolfi 提出了Quad-Edge数据结构，并使用其简化了1975年Shamos和Hoey提出的Delaunay三角剖分分治算法。在上述的参考文献中，作者专门用了一节对分治法三角剖分进行介绍，并附有详细的伪代码。</p>
</blockquote>
<h4 id="4-2-1-Quad-Edge-2"><a href="#4-2-1-Quad-Edge-2" class="headerlink" title="4.2.1 Quad-Edge"></a>4.2.1 Quad-Edge</h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/afs/andrew/scs/cs/15-463/2001/pub/src/a2/quadedge.html#guibas">Quad-Edge Data Structure and Library (cmu.edu)</a></p>
</blockquote>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/edge.jpeg" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vertex</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y, _id = <span class="hljs-literal">None</span></span>):</span><br>        self.<span class="hljs-built_in">id</span> = _<span class="hljs-built_in">id</span><br>        self.x = x<br>        self.y = y<br><br>        self.name = <span class="hljs-string">f&#x27;v_<span class="hljs-subst">&#123;self.<span class="hljs-built_in">id</span>&#125;</span>&#x27;</span>  <span class="hljs-comment"># for debugging</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Quad_Edge</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;A directed edge: org -&gt; dest.</span><br><span class="hljs-string">    When traversing edge ring: Next is CCW, Prev is CW.&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, org, dest</span>):</span><br>        self.org = org  <span class="hljs-comment"># Origin</span><br>        self.dest = dest  <span class="hljs-comment"># Destination</span><br>        self.onext = <span class="hljs-literal">None</span>  <span class="hljs-comment"># next edge around origin,with same origin</span><br>        self.oprev = <span class="hljs-literal">None</span>  <span class="hljs-comment"># prev edge around origin,with same origin</span><br>        self.sym = <span class="hljs-literal">None</span>  <span class="hljs-comment"># edge pointing opposite dest this edge</span><br>        self.deleted = <span class="hljs-literal">False</span>  <span class="hljs-comment"># Deleted flag</span><br><br>        self.name = <span class="hljs-string">f&#x27;e_<span class="hljs-subst">&#123;self.org.<span class="hljs-built_in">id</span>&#125;</span>_<span class="hljs-subst">&#123;self.dest.<span class="hljs-built_in">id</span>&#125;</span>&#x27;</span>  <span class="hljs-comment"># for debugging</span><br></code></pre></td></tr></table></figure>

<p>分治法三角剖分中我们使用Quad-Edge作为边的数据结构。下面我们将介绍一些边的拓扑操作。</p>
<blockquote>
<p>Reference: <a target="_blank" rel="noopener" href="https://github.com/alexbaryzhikov/triangulation">https://github.com/alexbaryzhikov/triangulation</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_edge</span>(<span class="hljs-params">org, dest, edges</span>) -&gt; Quad_Edge:</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Creates an edge, add it dest edges, and return it.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    e = Quad_Edge(org, dest)<br>    es = Quad_Edge(dest, org)<br>    e.sym, es.sym = es, e  <span class="hljs-comment"># make edges mutually symmetrical</span><br>    e.onext, e.oprev = e, e<br>    es.onext, es.oprev = es, es<br>    edges.append(e)<br>    <span class="hljs-keyword">return</span> e<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_next_prev</span>(<span class="hljs-params">e1: Quad_Edge, e2: Quad_Edge</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Either combines e1 and e2 into a single edge, or seperates them.</span><br><span class="hljs-string">    Which one is determined by the orientation of e1 and e2.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> e1 == e2:<br>        <span class="hljs-keyword">return</span><br>    e1.onext.oprev = e2<br>    e2.onext.oprev = e1<br>    <span class="hljs-comment"># Swap a.onext and b.onext</span><br>    e1.onext, e2.onext = e2.onext, e1.onext<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connect</span>(<span class="hljs-params">e1: Quad_Edge, e2: Quad_Edge, edges</span>) -&gt; Quad_Edge:</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Connecting destination of e1 with the origin of e2 with an edge</span><br><span class="hljs-string">    O(1) time and O(1) space</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    e = create_edge(e1.dest, e2.org, edges)<br>    <span class="hljs-comment"># Maintain the onext and oprev values</span><br>    update_next_prev(e, e1.sym.oprev)<br>    update_next_prev(e.sym, e2)<br>    <span class="hljs-keyword">return</span> e<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mark_edge_deleted</span>(<span class="hljs-params">e: Quad_Edge</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Delete edge from the edge list</span><br><span class="hljs-string">    O(1) time and O(1) space</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># Update the e.onext&#x27; and e.oprev&#x27;s values</span><br>    update_next_prev(e, e.oprev)<br>    update_next_prev(e.sym, e.sym.oprev)<br>    <span class="hljs-comment"># Mark the edge dest be deleted</span><br>    e.deleted = <span class="hljs-literal">True</span><br>    e.sym.deleted = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>

<h5 id="（1）create-edge-org-dest-edges-2"><a href="#（1）create-edge-org-dest-edges-2" class="headerlink" title="（1）create_edge(org, dest, edges)"></a>（1）create_edge(org, dest, edges)</h5><p>该函数用于返回以<code>org</code>为起点，<code>dest</code>为终点的边（这里及[本节](#4.2.1 Quad-Edge)中提到的边都指Quad-Edge），同时将这条边放入<code>edges</code>列表中。我们在该函数中初始化了新生成边的对称边，并且正确初始化了新边及其对称边的<code>onext</code>和<code>oprev</code>属性，因为新边未与任何其他边建立拓扑联系，所以这两个属性都是这两条边自身。具体实现细节参见文章^[1]^中提出的<code>MakeEdge</code>操作。</p>
<h5 id="（2）update-next-prev-e1-e2-2"><a href="#（2）update-next-prev-e1-e2-2" class="headerlink" title="（2）update_next_prev(e1, e2)"></a>（2）update_next_prev(e1, e2)</h5><p>该函数用于<strong>拼接</strong>e1边和e2边，实质上是更新了两条边的<code>onext</code>和<code>oprev</code>属性。具体实现细节参见文章^[1]^中提出的<code>Splice</code>操作。</p>
<h5 id="（3）connect-e1-e2-edges-2"><a href="#（3）connect-e1-e2-edges-2" class="headerlink" title="（3）connect(e1, e2, edges)"></a>（3）connect(e1, e2, edges)</h5><p>该函数使用一条新边连接e1边和e2边，并更新三者的拓扑关系。具体实现细节参见文章^[1]^中提出的<code>Connect</code>操作。</p>
<h5 id="（4）mark-edge-deleted-e-2"><a href="#（4）mark-edge-deleted-e-2" class="headerlink" title="（4）mark_edge_deleted(e)"></a>（4）mark_edge_deleted(e)</h5><p>该函数用于删除一条边，本质上是改变删除边和其他边的拓扑关系。具体实现细节参见文章^[1]^中提出的<code>DeleteEdge</code>操作。</p>
<h4 id="4-2-2-DCEL-2"><a href="#4-2-2-DCEL-2" class="headerlink" title="4.2.2 DCEL"></a>4.2.2 DCEL</h4><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV13o4y1Q7eH/">https://www.bilibili.com/video/BV13o4y1Q7eH/</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;A sample implementation of the DCEL structure in Python&quot;&quot;&quot;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vertex</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x, y</span>):</span><br>        self.x = x<br>        self.y = y<br>        self.coordinates = [x, y]  <span class="hljs-comment"># 顶点坐标</span><br>        self.incidentEdge = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 以该顶点为起点的半边</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Face</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.outerComponent = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 外边界上的某一条半边</span><br>        self.innerComponents = []  <span class="hljs-comment"># 内部包含的孔洞列表，其中每个孔洞用一条半边代表</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HalfEdge</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, origin = <span class="hljs-literal">None</span>, incidentFace = <span class="hljs-literal">None</span></span>):</span><br>        self.origin = origin  <span class="hljs-comment"># 半边的起始顶点</span><br>        self.twin = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 孪生半边</span><br>        self.incidentFace = incidentFace  <span class="hljs-comment"># 该半边指向的平面</span><br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 下一条半边</span><br>        self.prev = <span class="hljs-literal">None</span>  <span class="hljs-comment"># 前一条半边</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DCEL</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, vertices = <span class="hljs-literal">None</span>, faces = <span class="hljs-literal">None</span>, half_edges = <span class="hljs-literal">None</span></span>):</span><br>        self.vertices = vertices<br>        self.faces = faces<br>        self.halfEdges = half_edges<br></code></pre></td></tr></table></figure>

<h4 id="4-2-3-工具算法-2"><a href="#4-2-3-工具算法-2" class="headerlink" title="4.2.3 工具算法"></a>4.2.3 工具算法</h4><h5 id="（1）判断点是否在三角形外接圆内-2"><a href="#（1）判断点是否在三角形外接圆内-2" class="headerlink" title="（1）判断点是否在三角形外接圆内"></a>（1）判断点是否在三角形外接圆内</h5><p>点$d$在三角形$(a,b,c)$外接圆内满足如下不等式：<br>$$<br>ret =\begin{vmatrix}a_x&amp;a_y&amp;a_x^2+a_y^2&amp;1\[0.3em]b_x&amp;b_y&amp;b_x^2+b_y^2&amp;1\[0.3em]c_x&amp;c_y&amp;c_x^2+c_y^2&amp;1\[0.3em]d_x&amp;d_y&amp;d_x^2+d_y^2&amp;1\end{vmatrix}&gt;0\tag{4-1}<br>$$<br>行列式每行减去第四行，得：<br>$$<br>ret =\begin{vmatrix}a_x-d_x&amp;a_y-d_y&amp;a_x^2+a_y^2-(d_x^2+d_y^2)&amp;0\[0.3em]b_x-d_x&amp;b_y-d_y&amp;b_x^2+b_y^2-(d_x^2+d_y^2)&amp;0\[0.3em]c_x-d_x&amp;c_y-d_y&amp;c_x^2+c_y^2-(d_x^2+d_y^2)&amp;0\[0.3em]d_x&amp;d_y&amp;d_x^2+d_y^2&amp;1\end{vmatrix}&gt;0\tag{4-2}<br>$$<br>简化得到下式：<br>$$<br>ret =\begin{vmatrix}a_x-d_x&amp;a_y-d_y&amp;a_x^2+a_y^2-(d_x^2+d_y^2)\[0.3em]b_x-d_x&amp;b_y-d_y&amp;b_x^2+b_y^2-(d_x^2+d_y^2)\[0.3em]c_x-d_x&amp;c_y-d_y&amp;c_x^2+c_y^2-(d_x^2+d_y^2)\end{vmatrix}&gt;0\tag{4-3}<br>$$<br>接下来，将式（4-3）中行列式第三列加上第一列和第二列的$-2d_x$倍，然后将第三列元素整理化成平方差形式，得到下式：<br>$$<br>ret =\begin{vmatrix}a_x-d_x&amp;a_y-d_y&amp;(a_x-d_x)^2+(a_y-d_y)^2\[0.3em]b_x-d_x&amp;b_y-d_y&amp;(b_x-d_x)^2+(b_y-d_y)^2\[0.3em]c_x-d_x&amp;c_y-d_y&amp;(c_x-d_x)^2+(c_y-d_y)^2\end{vmatrix}&gt;0\tag{4-4}<br>$$<br>形如$ad_x=a_x-d_x$替换相同元，得到下式：<br>$$<br>ret =\begin{vmatrix}ad_x&amp;ad_y&amp;ad_x^2+ad_y^2\[0.3em]bd_x&amp;bd_y&amp;bd_x^2+bd_y^2\[0.3em]cd_x&amp;cd_y&amp;cd_x^2+cd_y^2\end{vmatrix}&gt;0\tag{4-5}<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inCircle</span>(<span class="hljs-params">a: Vertex, b: Vertex, c: Vertex, d: Vertex</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;判断点d是否在由a,b,c构成的三角形外接圆内&quot;&quot;&quot;</span><br>    adx = a.x - d.x<br>    ady = a.y - d.y<br>    bdx = b.x - d.x<br>    bdy = b.y - d.y<br>    cdx = c.x - d.x<br>    cdy = c.y - d.y<br><br>    alift = adx * adx + ady * ady<br>    blift = bdx * bdx + bdy * bdy<br>    clift = cdx * cdx + cdy * cdy<br>    <br>    <span class="hljs-keyword">return</span> alift * (bdx * cdy - cdx * bdy) + blift * (cdx * ady - adx * cdy) + clift * (adx * bdy - bdx * ady) &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h5 id="（2）判断点与边的相对位置-2"><a href="#（2）判断点与边的相对位置-2" class="headerlink" title="（2）判断点与边的相对位置"></a>（2）判断点与边的相对位置</h5><p>设边的起点$a$，终点$b$，输入点为$p$。<br>$$<br>det=\begin{vmatrix}a_x&amp;a_y&amp;1\[0.3em]b_x&amp;b_y&amp;1\[0.3em]p_x&amp;p_y&amp;1\end{vmatrix}\tag{4-6}<br>$$</p>
<p>$$<br>det=(a_x-p_x)(b_y-p_y)-(a_y-p_y)(b_x-p_x)\tag{4-7}<br>$$</p>
<ul>
<li>$det&gt;0$，$p$在边左边；</li>
<li>$det&lt;0$，$p$在边右边；</li>
<li>$det=0$，$p$在边共线。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">left_test</span>(<span class="hljs-params">p, e</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Left test for point p relative to the line of edge e.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    a, b = e.org, e.sym.org<br>    det1 = (a.x - p.x) * (b.y - p.y)<br>    det2 = (a.y - p.y) * (b.x - p.x)<br>    <span class="hljs-keyword">return</span> det1 - det2<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toRight</span>(<span class="hljs-params">p, e</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Does point p lie to the right of the line of edge e?&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> left_test(p, e) &lt; <span class="hljs-number">0</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toLeft</span>(<span class="hljs-params">p, e</span>) -&gt; <span class="hljs-built_in">bool</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Does point p lie to the left of the line of edge e?&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> left_test(p, e) &gt; <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h4 id="4-2-4-主要程序-2"><a href="#4-2-4-主要程序-2" class="headerlink" title="4.2.4 主要程序"></a>4.2.4 主要程序</h4><p><strong>算法伪代码：</strong></p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/image-20230606140652092.png" srcset="/img/loading.gif" lazyload alt="image-20230606140652092"></p>
<p><strong>主程序：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Divide_Delaunay</span>:</span><br>    <span class="hljs-string">&quot;&quot;&quot;Triangulate the points using the divide and conquer delaunay triangulation algorithm.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, points</span>):</span><br>        self.points = points<br>        self.verticies = []<br>        self.init_points()  <span class="hljs-comment"># 初始化点集</span><br>        self.edges = []<br>        self.div_and_conq_triangulate(self.verticies)  <span class="hljs-comment"># 分治法构造三角网</span><br><br>        <span class="hljs-comment"># Remove edges that are not part of the triangulation</span><br>        self.edges = [e <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> self.edges <span class="hljs-keyword">if</span> e.deleted <span class="hljs-keyword">is</span> <span class="hljs-literal">False</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init_points</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># Validate the input size</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.points) &lt; <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span><br><br>        <span class="hljs-comment"># Sort points by x coordinate, y is a tiebreaker</span><br>        self.points.sort(key = <span class="hljs-keyword">lambda</span> point: (point[<span class="hljs-number">0</span>], point[<span class="hljs-number">1</span>]))<br><br>        <span class="hljs-comment"># Remove duplicates</span><br>        i = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(self.points) - <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">if</span> self.points[i] == self.points[i + <span class="hljs-number">1</span>]:<br>                <span class="hljs-keyword">del</span> self.points[i]<br>            <span class="hljs-keyword">else</span>:<br>                i += <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># Vertex naming</span><br>        <span class="hljs-keyword">for</span> i, point <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(self.points):<br>            self.verticies.append(Vertex(point[<span class="hljs-number">0</span>], point[<span class="hljs-number">1</span>], i))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">div_and_conq_triangulate</span>(<span class="hljs-params">self, points</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Computes the Delaunay triangulation of self.points and returns two edges, le and re,</span><br><span class="hljs-string">        which are the counterclockwise convex hull edge out of the leftmost vertex and the clockwise</span><br><span class="hljs-string">        convex hull edge out of the rightmost vertex, respectively.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        n = <span class="hljs-built_in">len</span>(points)<br>        <span class="hljs-comment"># Base case: 2 points</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span>:<br>            edge = create_edge(points[<span class="hljs-number">0</span>], points[<span class="hljs-number">1</span>], self.edges)<br>            <span class="hljs-keyword">return</span> edge, edge.sym<br><br>        <span class="hljs-comment"># Base case: 3 points</span><br>        <span class="hljs-keyword">elif</span> n == <span class="hljs-number">3</span>:<br>            <span class="hljs-comment"># Create edge S[0]-S[1] and edge S[1]-S[2]</span><br>            edge1 = create_edge(points[<span class="hljs-number">0</span>], points[<span class="hljs-number">1</span>], self.edges)<br>            edge2 = create_edge(points[<span class="hljs-number">1</span>], points[<span class="hljs-number">2</span>], self.edges)<br>            update_next_prev(edge1.sym, edge2)<br><br>            <span class="hljs-comment"># Create edge S[2]-S[0]</span><br>            <span class="hljs-keyword">if</span> toRight(points[<span class="hljs-number">2</span>], edge1):  <span class="hljs-comment"># Right</span><br>                connect(edge2, edge1, self.edges)<br>                <span class="hljs-keyword">return</span> edge1, edge2.sym<br>            <span class="hljs-keyword">elif</span> toLeft(points[<span class="hljs-number">2</span>], edge1):  <span class="hljs-comment"># Left</span><br>                edge3 = connect(edge2, edge1, self.edges)<br>                <span class="hljs-keyword">return</span> edge3.sym, edge3<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># Points are linear</span><br>                <span class="hljs-keyword">return</span> edge1, edge2.sym<br><br>        <span class="hljs-comment"># Recurively triangulate the left and right halves</span><br>        <span class="hljs-keyword">else</span>:<br>            m = n // <span class="hljs-number">2</span><br>            ldo, ldi = self.div_and_conq_triangulate(points[:m])<br>            rdi, rdo = self.div_and_conq_triangulate(points[m:])<br>            ldo_r, rdo_r = self.merge(ldo, ldi, rdi, rdo)<br><br>            <span class="hljs-keyword">return</span> ldo_r, rdo_r<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">self, ldo, ldi, rdi, rdo</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Takes 2 halves of the triangulation and merges them into a single triangulation.</span><br><span class="hljs-string">        While doing so it uses previosly calculated values of these halves.</span><br><span class="hljs-string">        Reference: https://github.com/alexbaryzhikov/triangulation</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># Compute the upper common tangent of L and R.</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> toRight(rdi.org, ldi):<br>                <span class="hljs-comment"># Advance dest the next edge on the convex hull of L.</span><br>                ldi = ldi.sym.onext<br>            <span class="hljs-keyword">elif</span> toLeft(ldi.org, rdi):<br>                <span class="hljs-comment"># Advance dest the next edge on the convex hull of R.</span><br>                rdi = rdi.sym.oprev<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br><br>        <span class="hljs-comment"># Create a first cross edge base.</span><br>        base = connect(ldi.sym, rdi, self.edges)<br><br>        <span class="hljs-comment"># Adjust ldo and rdo</span><br>        <span class="hljs-keyword">if</span> ldi.org.x == ldo.org.x <span class="hljs-keyword">and</span> ldi.org.y == ldo.org.y:<br>            ldo = base<br>        <span class="hljs-keyword">if</span> rdi.org.x == rdo.org.x <span class="hljs-keyword">and</span> rdi.org.y == rdo.org.y:<br>            rdo = base.sym<br><br>        <span class="hljs-comment"># Merge two halves</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># Locate the first R and L points dest be encountered by the diving bubble.</span><br>            rcand, lcand = base.sym.onext, base.oprev<br><br>            <span class="hljs-comment"># If both lcand and rcand are invalid, then base is the lower common tangent.</span><br>            v_rcand, v_lcand = toRight(rcand.dest, base), toRight(lcand.dest, base)<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (v_rcand <span class="hljs-keyword">or</span> v_lcand):<br>                <span class="hljs-keyword">break</span><br><br>            <span class="hljs-comment"># Delete R edges out of base.dest that fail the circle test.</span><br>            <span class="hljs-keyword">if</span> v_rcand:<br>                <span class="hljs-keyword">while</span> toRight(rcand.onext.dest, base) <span class="hljs-keyword">and</span> inCircle(base.dest, base.org, rcand.dest, rcand.onext.dest):<br>                    t = rcand.onext<br>                    mark_edge_deleted(rcand)<br>                    rcand = t<br><br>            <span class="hljs-comment"># Symmetrically, delete L edges.</span><br>            <span class="hljs-keyword">if</span> v_lcand:<br>                <span class="hljs-keyword">while</span> toRight(lcand.oprev.dest, base) <span class="hljs-keyword">and</span> inCircle(base.dest, base.org, lcand.dest, lcand.oprev.dest):<br>                    t = lcand.oprev<br>                    mark_edge_deleted(lcand)<br>                    lcand = t<br><br>            <span class="hljs-comment"># The next cross edge is dest be connected dest either lcand.dest or rcand.dest.</span><br>            <span class="hljs-comment"># If both are valid, then choose the appropriate one using the in_circle test.</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> v_rcand <span class="hljs-keyword">or</span> (v_lcand <span class="hljs-keyword">and</span> inCircle(rcand.dest, rcand.org, lcand.org, lcand.dest)):<br>                <span class="hljs-comment"># Add cross edge base from rcand.dest dest base.dest.</span><br>                base = connect(lcand, base.sym, self.edges)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># Add cross edge base from base.org dest lcand.dest</span><br>                base = connect(base.sym, rcand.sym, self.edges)<br><br>        <span class="hljs-keyword">return</span> ldo, rdo<br></code></pre></td></tr></table></figure>

<p><strong>测试程序：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">from</span> divide_delaunay <span class="hljs-keyword">import</span> Divide_Delaunay<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    np.random.seed(<span class="hljs-number">16</span>)<br>    num = <span class="hljs-number">10</span><br>    fig = plt.figure()<br>    plt.ion()<br>    ax = fig.add_subplot(<span class="hljs-number">111</span>)<br>    xs = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, num)<br>    ys = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, num)<br>    <span class="hljs-comment"># xs = np.array([0, 1, 2, 3, 4, 5])</span><br>    <span class="hljs-comment"># ys = np.array([0, 2, 1, 1, 4, 3])</span><br><br>    start_time = time.time()<br>    dt = Divide_Delaunay(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(xs, ys)))<br>    end_time = time.time()<br>    verticies, edges = dt.verticies, dt.edges<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Triangulating <span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(verticies)&#125;</span> points takes <span class="hljs-subst">&#123;end_time - start_time&#125;</span> s&quot;</span>)<br><br>    <span class="hljs-comment"># draw points</span><br>    <span class="hljs-keyword">for</span> vertex <span class="hljs-keyword">in</span> verticies:<br>        ax.scatter(vertex.x, vertex.y, c = <span class="hljs-string">&#x27;b&#x27;</span>)<br><br>    <span class="hljs-comment"># draw edges</span><br>    <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> edges:<br>        a, b = edge.org, edge.sym.org<br>        ax.plot([a.x, b.x], [a.y, b.y], <span class="hljs-string">&#x27;bo-&#x27;</span>)<br>        plt.pause(<span class="hljs-number">0.5</span>)<br><br>    <span class="hljs-keyword">import</span> matplotlib.tri <span class="hljs-keyword">as</span> tri<br><br>    <span class="hljs-comment"># Plot the triangulation.</span><br>    triang = tri.Triangulation([v.x <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> verticies], [v.y <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> verticies])<br>    ax.triplot(triang, <span class="hljs-string">&#x27;ro-&#x27;</span>)<br><br>    fig.show()<br>    plt.pause(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<p><strong>测试结果：</strong></p>
<p><img src="https://gitee.com/mstifiy/img-load/raw/master/noteImg/GIF%202023-6-6%2014-11-07.gif" srcset="/img/loading.gif" lazyload alt="GIF 2023-6-6 14-11-07"></p>
<blockquote>
<p>在我们写的代码中，合并部分最开始寻找的是左右子剖分的上公切线，然后从上到下进行连接合并。当然，也可以寻找下公切线，然后从下向上进行连接合并，两种方式都是一样的效果，是不过判断逻辑相反。</p>
</blockquote>
<p>在效率上，测试了三组数据。结果如下：</p>
<table>
<thead>
<tr>
<th>点集规模/个</th>
<th>耗时/s</th>
</tr>
</thead>
<tbody><tr>
<td>1000</td>
<td>0.09</td>
</tr>
<tr>
<td>4000</td>
<td>0.33</td>
</tr>
<tr>
<td>6000</td>
<td>0.49</td>
</tr>
</tbody></table>
<p>时间复杂度大概为$O(nlogn)$，$n$为点集大小。</p>
<hr>
<p>更多关于网格划分生成的细节和拓展参见：<a target="_blank" rel="noopener" href="https://people.eecs.berkeley.edu/~jrs/meshpapers/delnotes.pdf">Lecture Notes on Delaunay Mesh Generation</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">学习记录</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/08/02/%E7%BD%91%E6%A0%BC%E7%AE%80%E5%8C%96(QEM)/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">网格简化(QEM)</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/05/Zotero%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">
                        <span class="hidden-mobile">Zotero | 快速入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"SS90JJ96HGAB2tRm4Xh34VrB-MdYXbMMI","appKey":"SenUiYEnAA6z6s0OlqwHxST5","path":"window.location.pathname","placeholder":"欢迎交流讨论~(目前只能通过科学sw访问评论区)","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":false,"serverURLs":"https://ss90jj96.api.lncldglobal.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <span>2023</span> <i class="iconfont icon-love"></i> <a href="https://github.com/mstifiy" target="_blank" rel="nofollow noopener"><span>MSTIFIY</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


  <!-- 页面点击烟花特效 -->
  <script type="text/javascript" src="/js/fireworks.js"></script>

  <!--浏览器搞笑标题-->
  <script type="text/javascript" src="/js/FunnyTitle.js"></script>

  <!--动态线条背景-->
  <script type="text/javascript" color="34,34,34" opacity='0.5' zIndex="-2" count="200" src="/lib/canvas-nest/canvas-nest.min.js">
  </script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":200,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
